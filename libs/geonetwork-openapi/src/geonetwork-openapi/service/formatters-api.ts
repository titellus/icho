/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { FormatterDataResponse } from "../../..//geonetwork-openapi/model";
/**
 * FormattersApi - axios parameter creator
 * @export
 */
export const FormattersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
     * @param {Array<any>} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFormatter: async (
      file: Array<any>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists("addFormatter", "file", file);
      const localVarPath = `/formatters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (file) {
        localVarQueryParameter["file"] = file;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
     * @summary Clear formatter cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearFormatterCache: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/formatters/cache`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a formatter
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFormatter: async (
      formatter: string,
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists("deleteFormatter", "formatter", formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("deleteFormatter", "schema", schema);
      const localVarPath = `/formatters/{schema}/{formatter}`
        .replace(`{${"formatter"}}`, encodeURIComponent(String(formatter)))
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download a formatter as ZIP
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFormatter: async (
      formatter: string,
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists("downloadFormatter", "formatter", formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("downloadFormatter", "schema", schema);
      const localVarPath = `/formatters/{schema}/{formatter}`
        .replace(`{${"formatter"}}`, encodeURIComponent(String(formatter)))
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get formatter file content
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFileContent: async (
      formatter: string,
      schema: string,
      file: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists("getFormatterFileContent", "formatter", formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("getFormatterFileContent", "schema", schema);
      // verify required parameter 'file' is not null or undefined
      assertParamExists("getFormatterFileContent", "file", file);
      const localVarPath = `/formatters/{schema}/{formatter}/files/{file}`
        .replace(`{${"formatter"}}`, encodeURIComponent(String(formatter)))
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)))
        .replace(`{${"file"}}`, encodeURIComponent(String(file)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get formatter files
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFiles: async (
      formatter: string,
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists("getFormatterFiles", "formatter", formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("getFormatterFiles", "schema", schema);
      const localVarPath = `/formatters/{schema}/{formatter}/files`
        .replace(`{${"formatter"}}`, encodeURIComponent(String(formatter)))
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get formatters
     * @param {string} [id]
     * @param {string} [uuid]
     * @param {string} [schema]
     * @param {boolean} [pluginOnly]
     * @param {boolean} [publishedOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFormatters: async (
      id?: string,
      uuid?: string,
      schema?: string,
      pluginOnly?: boolean,
      publishedOnly?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/formatters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (uuid !== undefined) {
        localVarQueryParameter["uuid"] = uuid;
      }

      if (schema !== undefined) {
        localVarQueryParameter["schema"] = schema;
      }

      if (pluginOnly !== undefined) {
        localVarQueryParameter["pluginOnly"] = pluginOnly;
      }

      if (publishedOnly !== undefined) {
        localVarQueryParameter["publishedOnly"] = publishedOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update formatter file
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {string} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFormatterFile: async (
      formatter: string,
      schema: string,
      file: string,
      data: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists("updateFormatterFile", "formatter", formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("updateFormatterFile", "schema", schema);
      // verify required parameter 'file' is not null or undefined
      assertParamExists("updateFormatterFile", "file", file);
      // verify required parameter 'data' is not null or undefined
      assertParamExists("updateFormatterFile", "data", data);
      const localVarPath = `/formatters/{schema}/{formatter}/files/{file}`
        .replace(`{${"formatter"}}`, encodeURIComponent(String(formatter)))
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)))
        .replace(`{${"file"}}`, encodeURIComponent(String(file)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (data !== undefined) {
        localVarQueryParameter["data"] = data;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FormattersApi - functional programming interface
 * @export
 */
export const FormattersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FormattersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
     * @param {Array<any>} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFormatter(
      file: Array<any>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addFormatter(
        file,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
     * @summary Clear formatter cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clearFormatterCache(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clearFormatterCache(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete a formatter
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFormatter(
      formatter: string,
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFormatter(
        formatter,
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Download a formatter as ZIP
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFormatter(
      formatter: string,
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.downloadFormatter(
          formatter,
          schema,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get formatter file content
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormatterFileContent(
      formatter: string,
      schema: string,
      file: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFormatterFileContent(
          formatter,
          schema,
          file,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get formatter files
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormatterFiles(
      formatter: string,
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFormatterFiles(
          formatter,
          schema,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get formatters
     * @param {string} [id]
     * @param {string} [uuid]
     * @param {string} [schema]
     * @param {boolean} [pluginOnly]
     * @param {boolean} [publishedOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFormatters(
      id?: string,
      uuid?: string,
      schema?: string,
      pluginOnly?: boolean,
      publishedOnly?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FormatterDataResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listFormatters(
        id,
        uuid,
        schema,
        pluginOnly,
        publishedOnly,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update formatter file
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {string} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFormatterFile(
      formatter: string,
      schema: string,
      file: string,
      data: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFormatterFile(
          formatter,
          schema,
          file,
          data,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FormattersApi - factory interface
 * @export
 */
export const FormattersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FormattersApiFp(configuration);
  return {
    /**
     *
     * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
     * @param {Array<any>} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFormatter(file: Array<any>, options?: any): AxiosPromise<void> {
      return localVarFp
        .addFormatter(file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
     * @summary Clear formatter cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearFormatterCache(options?: any): AxiosPromise<void> {
      return localVarFp
        .clearFormatterCache(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a formatter
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFormatter(
      formatter: string,
      schema: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFormatter(formatter, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download a formatter as ZIP
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFormatter(
      formatter: string,
      schema: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadFormatter(formatter, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get formatter file content
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFileContent(
      formatter: string,
      schema: string,
      file: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getFormatterFileContent(formatter, schema, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get formatter files
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFiles(
      formatter: string,
      schema: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getFormatterFiles(formatter, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get formatters
     * @param {string} [id]
     * @param {string} [uuid]
     * @param {string} [schema]
     * @param {boolean} [pluginOnly]
     * @param {boolean} [publishedOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFormatters(
      id?: string,
      uuid?: string,
      schema?: string,
      pluginOnly?: boolean,
      publishedOnly?: boolean,
      options?: any
    ): AxiosPromise<FormatterDataResponse> {
      return localVarFp
        .listFormatters(id, uuid, schema, pluginOnly, publishedOnly, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update formatter file
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {string} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFormatterFile(
      formatter: string,
      schema: string,
      file: string,
      data: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateFormatterFile(formatter, schema, file, data, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FormattersApi - object-oriented interface
 * @export
 * @class FormattersApi
 * @extends {BaseAPI}
 */
export class FormattersApi extends BaseAPI {
  /**
   *
   * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
   * @param {Array<any>} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public addFormatter(file: Array<any>, options?: AxiosRequestConfig) {
    return FormattersApiFp(this.configuration)
      .addFormatter(file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
   * @summary Clear formatter cache
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public clearFormatterCache(options?: AxiosRequestConfig) {
    return FormattersApiFp(this.configuration)
      .clearFormatterCache(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a formatter
   * @param {string} formatter
   * @param {string} schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public deleteFormatter(
    formatter: string,
    schema: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .deleteFormatter(formatter, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download a formatter as ZIP
   * @param {string} formatter
   * @param {string} schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public downloadFormatter(
    formatter: string,
    schema: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .downloadFormatter(formatter, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get formatter file content
   * @param {string} formatter
   * @param {string} schema
   * @param {string} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public getFormatterFileContent(
    formatter: string,
    schema: string,
    file: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .getFormatterFileContent(formatter, schema, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get formatter files
   * @param {string} formatter
   * @param {string} schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public getFormatterFiles(
    formatter: string,
    schema: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .getFormatterFiles(formatter, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get formatters
   * @param {string} [id]
   * @param {string} [uuid]
   * @param {string} [schema]
   * @param {boolean} [pluginOnly]
   * @param {boolean} [publishedOnly]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public listFormatters(
    id?: string,
    uuid?: string,
    schema?: string,
    pluginOnly?: boolean,
    publishedOnly?: boolean,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .listFormatters(id, uuid, schema, pluginOnly, publishedOnly, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update formatter file
   * @param {string} formatter
   * @param {string} schema
   * @param {string} file
   * @param {string} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public updateFormatterFile(
    formatter: string,
    schema: string,
    file: string,
    data: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .updateFormatterFile(formatter, schema, file, data, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
