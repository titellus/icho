/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { OwnerResponse } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { PasswordResetDto } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { PasswordUpdateParameter } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { TransferRequest } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { User } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { UserDto } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { UserGroup } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { UserGroupsResponse } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { UserRegisterDto } from "../../..//geonetwork-openapi/model";
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Check if a user property already exist
     * @param {string} property The user property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserPropertyExist: async (
      property: string,
      exist: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'property' is not null or undefined
      assertParamExists("checkUserPropertyExist", "property", property);
      // verify required parameter 'exist' is not null or undefined
      assertParamExists("checkUserPropertyExist", "exist", exist);
      const localVarPath = `/users/properties/{property}`.replace(
        `{${"property"}}`,
        encodeURIComponent(String(property))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (exist !== undefined) {
        localVarQueryParameter["exist"] = exist;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a catalog user.
     * @summary Creates a user
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      userDto: UserDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userDto' is not null or undefined
      assertParamExists("createUser", "userDto", userDto);
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a catalog user by identifier.
     * @summary Delete a user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("deleteUser", "userIdentifier", userIdentifier);
      const localVarPath = `/users/{userIdentifier}`.replace(
        `{${"userIdentifier"}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return users who actually owns one or more records.
     * @summary Get owners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordOwners: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/owners`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (
      userIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("getUser", "userIdentifier", userIdentifier);
      const localVarPath = `/users/{userIdentifier}`.replace(
        `{${"userIdentifier"}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user identicon
     * @param {number} userIdentifier User identifier.
     * @param {number} [size] Size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdenticon: async (
      userIdentifier: number,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("getUserIdenticon", "userIdentifier", userIdentifier);
      const localVarPath = `/users/{userIdentifier}.png`.replace(
        `{${"userIdentifier"}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
     * @summary Create user account
     * @param {UserRegisterDto} userRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      userRegisterDto: UserRegisterDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userRegisterDto' is not null or undefined
      assertParamExists("registerUser", "userRegisterDto", userRegisterDto);
      const localVarPath = `/user/actions/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRegisterDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resets the user password.
     * @summary Resets user password
     * @param {number} userIdentifier User identifier.
     * @param {PasswordResetDto} passwordResetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword: async (
      userIdentifier: number,
      passwordResetDto: PasswordResetDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("resetUserPassword", "userIdentifier", userIdentifier);
      // verify required parameter 'passwordResetDto' is not null or undefined
      assertParamExists(
        "resetUserPassword",
        "passwordResetDto",
        passwordResetDto
      );
      const localVarPath =
        `/users/{userIdentifier}/actions/forget-password`.replace(
          `{${"userIdentifier"}}`,
          encodeURIComponent(String(userIdentifier))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        passwordResetDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAllUserGroups: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve the user groups.
     * @summary Retrieve user groups
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveUserGroups: async (
      userIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("retrieveUserGroups", "userIdentifier", userIdentifier);
      const localVarPath = `/users/{userIdentifier}/groups`.replace(
        `{${"userIdentifier"}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Transfer privileges
     * @param {TransferRequest} transferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOwners: async (
      transferRequest: TransferRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'transferRequest' is not null or undefined
      assertParamExists("saveOwners", "transferRequest", transferRequest);
      const localVarPath = `/users/owners`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        transferRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
     * @summary Send user password reminder by email
     * @param {string} username The user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPasswordByEmail: async (
      username: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("sendPasswordByEmail", "username", username);
      const localVarPath = `/user/actions/forgot-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a valid changekey by email first and then update your password.
     * @summary Update user password
     * @param {string} username The user name
     * @param {PasswordUpdateParameter} passwordUpdateParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword: async (
      username: string,
      passwordUpdateParameter: PasswordUpdateParameter,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("updatePassword", "username", username);
      // verify required parameter 'passwordUpdateParameter' is not null or undefined
      assertParamExists(
        "updatePassword",
        "passwordUpdateParameter",
        passwordUpdateParameter
      );
      const localVarPath = `/user/{username}`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        passwordUpdateParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a catalog user.
     * @summary Update a user
     * @param {number} userIdentifier User identifier.
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userIdentifier: number,
      userDto: UserDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("updateUser", "userIdentifier", userIdentifier);
      // verify required parameter 'userDto' is not null or undefined
      assertParamExists("updateUser", "userDto", userDto);
      const localVarPath = `/users/{userIdentifier}`.replace(
        `{${"userIdentifier"}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Check if a user property already exist
     * @param {string} property The user property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkUserPropertyExist(
      property: string,
      exist: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkUserPropertyExist(
          property,
          exist,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Creates a catalog user.
     * @summary Creates a user
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      userDto: UserDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        userDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes a catalog user by identifier.
     * @summary Delete a user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        userIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return users who actually owns one or more records.
     * @summary Get owners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordOwners(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OwnerResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordOwners(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        userIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user identicon
     * @param {number} userIdentifier User identifier.
     * @param {number} [size] Size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserIdenticon(
      userIdentifier: number,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserIdenticon(
          userIdentifier,
          size,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
     * @summary Create user account
     * @param {UserRegisterDto} userRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      userRegisterDto: UserRegisterDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        userRegisterDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Resets the user password.
     * @summary Resets user password
     * @param {number} userIdentifier User identifier.
     * @param {PasswordResetDto} passwordResetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetUserPassword(
      userIdentifier: number,
      passwordResetDto: PasswordResetDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resetUserPassword(
          userIdentifier,
          passwordResetDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Retrieve all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveAllUserGroups(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserGroupsResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.retrieveAllUserGroups(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve the user groups.
     * @summary Retrieve user groups
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveUserGroups(
      userIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserGroup>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.retrieveUserGroups(
          userIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Transfer privileges
     * @param {TransferRequest} transferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveOwners(
      transferRequest: TransferRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveOwners(
        transferRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
     * @summary Send user password reminder by email
     * @param {string} username The user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendPasswordByEmail(
      username: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendPasswordByEmail(username, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a valid changekey by email first and then update your password.
     * @summary Update user password
     * @param {string} username The user name
     * @param {PasswordUpdateParameter} passwordUpdateParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePassword(
      username: string,
      passwordUpdateParameter: PasswordUpdateParameter,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(
        username,
        passwordUpdateParameter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Updates a catalog user.
     * @summary Update a user
     * @param {number} userIdentifier User identifier.
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userIdentifier: number,
      userDto: UserDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        userIdentifier,
        userDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Check if a user property already exist
     * @param {string} property The user property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserPropertyExist(
      property: string,
      exist: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .checkUserPropertyExist(property, exist, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a catalog user.
     * @summary Creates a user
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(userDto: UserDto, options?: any): AxiosPromise<string> {
      return localVarFp
        .createUser(userDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a catalog user by identifier.
     * @summary Delete a user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userIdentifier: number, options?: any): AxiosPromise<string> {
      return localVarFp
        .deleteUser(userIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return users who actually owns one or more records.
     * @summary Get owners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordOwners(options?: any): AxiosPromise<Array<OwnerResponse>> {
      return localVarFp
        .getRecordOwners(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userIdentifier: number, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUser(userIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user identicon
     * @param {number} userIdentifier User identifier.
     * @param {number} [size] Size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdenticon(
      userIdentifier: number,
      size?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getUserIdenticon(userIdentifier, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
     * @summary Create user account
     * @param {UserRegisterDto} userRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      userRegisterDto: UserRegisterDto,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .registerUser(userRegisterDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Resets the user password.
     * @summary Resets user password
     * @param {number} userIdentifier User identifier.
     * @param {PasswordResetDto} passwordResetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(
      userIdentifier: number,
      passwordResetDto: PasswordResetDto,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .resetUserPassword(userIdentifier, passwordResetDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAllUserGroups(
      options?: any
    ): AxiosPromise<Array<UserGroupsResponse>> {
      return localVarFp
        .retrieveAllUserGroups(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve the user groups.
     * @summary Retrieve user groups
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveUserGroups(
      userIdentifier: number,
      options?: any
    ): AxiosPromise<Array<UserGroup>> {
      return localVarFp
        .retrieveUserGroups(userIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Transfer privileges
     * @param {TransferRequest} transferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOwners(
      transferRequest: TransferRequest,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .saveOwners(transferRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
     * @summary Send user password reminder by email
     * @param {string} username The user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPasswordByEmail(username: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .sendPasswordByEmail(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a valid changekey by email first and then update your password.
     * @summary Update user password
     * @param {string} username The user name
     * @param {PasswordUpdateParameter} passwordUpdateParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword(
      username: string,
      passwordUpdateParameter: PasswordUpdateParameter,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updatePassword(username, passwordUpdateParameter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a catalog user.
     * @summary Update a user
     * @param {number} userIdentifier User identifier.
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      userIdentifier: number,
      userDto: UserDto,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updateUser(userIdentifier, userDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Check if a user property already exist
   * @param {string} property The user property to check
   * @param {string} exist The value to search
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public checkUserPropertyExist(
    property: string,
    exist: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .checkUserPropertyExist(property, exist, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a catalog user.
   * @summary Creates a user
   * @param {UserDto} userDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(userDto: UserDto, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createUser(userDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a catalog user by identifier.
   * @summary Delete a user
   * @param {number} userIdentifier User identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(userIdentifier: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUser(userIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return users who actually owns one or more records.
   * @summary Get owners
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getRecordOwners(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getRecordOwners(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user
   * @param {number} userIdentifier User identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUser(userIdentifier: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUser(userIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user identicon
   * @param {number} userIdentifier User identifier.
   * @param {number} [size] Size.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserIdenticon(
    userIdentifier: number,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUserIdenticon(userIdentifier, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
   * @summary Create user account
   * @param {UserRegisterDto} userRegisterDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public registerUser(
    userRegisterDto: UserRegisterDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .registerUser(userRegisterDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Resets the user password.
   * @summary Resets user password
   * @param {number} userIdentifier User identifier.
   * @param {PasswordResetDto} passwordResetDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public resetUserPassword(
    userIdentifier: number,
    passwordResetDto: PasswordResetDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .resetUserPassword(userIdentifier, passwordResetDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve all user groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public retrieveAllUserGroups(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .retrieveAllUserGroups(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve the user groups.
   * @summary Retrieve user groups
   * @param {number} userIdentifier User identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public retrieveUserGroups(
    userIdentifier: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .retrieveUserGroups(userIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Transfer privileges
   * @param {TransferRequest} transferRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public saveOwners(
    transferRequest: TransferRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .saveOwners(transferRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
   * @summary Send user password reminder by email
   * @param {string} username The user name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public sendPasswordByEmail(username: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .sendPasswordByEmail(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a valid changekey by email first and then update your password.
   * @summary Update user password
   * @param {string} username The user name
   * @param {PasswordUpdateParameter} passwordUpdateParameter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updatePassword(
    username: string,
    passwordUpdateParameter: PasswordUpdateParameter,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updatePassword(username, passwordUpdateParameter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates a catalog user.
   * @summary Update a user
   * @param {number} userIdentifier User identifier.
   * @param {UserDto} userDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(
    userIdentifier: number,
    userDto: UserDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateUser(userIdentifier, userDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
