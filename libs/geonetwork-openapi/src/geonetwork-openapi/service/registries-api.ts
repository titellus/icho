/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { Crs } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { InlineObject4 } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { InlineObject5 } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SimpleMetadataProcessingReport } from "../../..//geonetwork-openapi/model";
/**
 * RegistriesApi - axios parameter creator
 * @export
 */
export const RegistriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a thesaurus.
     * @summary Delete a thesaurus by name
     * @param {string} thesaurus Thesaurus to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThesaurus: async (
      thesaurus: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists("deleteThesaurus", "thesaurus", thesaurus);
      const localVarPath = `/registries/vocabularies/{thesaurus}`.replace(
        `{${"thesaurus"}}`,
        encodeURIComponent(String(thesaurus))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Extracts directory entries from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists("extractEntries", "xpath", xpath);
      const localVarPath = `/registries/actions/entries/collect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter["xpath"] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter["identifierXpath"] = identifierXpath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get CRS
     * @param {string} id CRS identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrs: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getCrs", "id", id);
      const localVarPath = `/registries/crs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of CRS type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrsTypes: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/crs/types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
     * @summary Get a directory entry
     * @param {string} uuid Directory entry UUID.
     * @param {Array<string>} [process] Process
     * @param {string} [transformation] Transformation
     * @param {Array<string>} [lang] lang
     * @param {string} [schema] schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntry: async (
      uuid: string,
      process?: Array<string>,
      transformation?: string,
      lang?: Array<string>,
      schema?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getEntry", "uuid", uuid);
      const localVarPath = `/registries/entries/{uuid}`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (process) {
        localVarQueryParameter["process"] = process;
      }

      if (transformation !== undefined) {
        localVarQueryParameter["transformation"] = transformation;
      }

      if (lang) {
        localVarQueryParameter["lang"] = lang;
      }

      if (schema !== undefined) {
        localVarQueryParameter["schema"] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById: async (
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getKeywordById", "id", id);
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists("getKeywordById", "thesaurus", thesaurus);
      const localVarPath = `/registries/vocabularies/keyword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (thesaurus !== undefined) {
        localVarQueryParameter["thesaurus"] = thesaurus;
      }

      if (lang) {
        localVarQueryParameter["lang"] = lang;
      }

      if (keywordOnly !== undefined) {
        localVarQueryParameter["keywordOnly"] = keywordOnly;
      }

      if (transformation !== undefined) {
        localVarQueryParameter["transformation"] = transformation;
      }

      if (langMap !== undefined) {
        localVarQueryParameter["langMap"] = langMap;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById1: async (
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getKeywordById1", "id", id);
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists("getKeywordById1", "thesaurus", thesaurus);
      const localVarPath = `/registries/vocabularies/keyword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (thesaurus !== undefined) {
        localVarQueryParameter["thesaurus"] = thesaurus;
      }

      if (lang) {
        localVarQueryParameter["lang"] = lang;
      }

      if (keywordOnly !== undefined) {
        localVarQueryParameter["keywordOnly"] = keywordOnly;
      }

      if (transformation !== undefined) {
        localVarQueryParameter["transformation"] = transformation;
      }

      if (langMap !== undefined) {
        localVarQueryParameter["langMap"] = langMap;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download the thesaurus in SKOS format.
     * @summary Download a thesaurus by name
     * @param {string} thesaurus Thesaurus to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThesaurus: async (
      thesaurus: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists("getThesaurus", "thesaurus", thesaurus);
      const localVarPath = `/registries/vocabularies/{thesaurus}`.replace(
        `{${"thesaurus"}}`,
        encodeURIComponent(String(thesaurus))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
     * @summary Uploads a CSV file and convert it to SKOS format
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [encoding] Encoding. Default is UTF-8.
     * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
     * @param {Array<string>} [languages] Thesaurus languages
     * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
     * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
     * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
     * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
     * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
     * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
     * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
     * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
     * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importCsvAsThesaurus: async (
      type?: "external" | "local",
      dir?: string,
      encoding?: string,
      thesaurusNs?: string,
      languages?: Array<string>,
      thesaurusTitle?: string,
      conceptIdColumn?: string,
      conceptLabelColumn?: string,
      conceptDescriptionColumn?: string,
      conceptBroaderIdColumn?: string,
      conceptNarrowerIdColumn?: string,
      conceptRelatedIdColumn?: string,
      conceptLinkSeparator?: string,
      importAsThesaurus?: boolean,
      inlineObject5?: InlineObject5,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies/import/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (dir !== undefined) {
        localVarQueryParameter["dir"] = dir;
      }

      if (encoding !== undefined) {
        localVarQueryParameter["encoding"] = encoding;
      }

      if (thesaurusNs !== undefined) {
        localVarQueryParameter["thesaurusNs"] = thesaurusNs;
      }

      if (languages) {
        localVarQueryParameter["languages"] = languages;
      }

      if (thesaurusTitle !== undefined) {
        localVarQueryParameter["thesaurusTitle"] = thesaurusTitle;
      }

      if (conceptIdColumn !== undefined) {
        localVarQueryParameter["conceptIdColumn"] = conceptIdColumn;
      }

      if (conceptLabelColumn !== undefined) {
        localVarQueryParameter["conceptLabelColumn"] = conceptLabelColumn;
      }

      if (conceptDescriptionColumn !== undefined) {
        localVarQueryParameter["conceptDescriptionColumn"] =
          conceptDescriptionColumn;
      }

      if (conceptBroaderIdColumn !== undefined) {
        localVarQueryParameter["conceptBroaderIdColumn"] =
          conceptBroaderIdColumn;
      }

      if (conceptNarrowerIdColumn !== undefined) {
        localVarQueryParameter["conceptNarrowerIdColumn"] =
          conceptNarrowerIdColumn;
      }

      if (conceptRelatedIdColumn !== undefined) {
        localVarQueryParameter["conceptRelatedIdColumn"] =
          conceptRelatedIdColumn;
      }

      if (conceptLinkSeparator !== undefined) {
        localVarQueryParameter["conceptLinkSeparator"] = conceptLinkSeparator;
      }

      if (importAsThesaurus !== undefined) {
        localVarQueryParameter["importAsThesaurus"] = importAsThesaurus;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject5,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
     * @summary Import spatial directory entries
     * @param {any} file The ZIP file to upload containing the Shapefile.
     * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
     * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
     * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
     * @param {string} [geomProjectionTo] geomProjectionTo
     * @param {boolean} [lenient] lenient
     * @param {string} [charset] Attribute table charset
     * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
     * @param {string} [process] Process
     * @param {string} [schema] Schema identifier
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {number} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importSpatialEntries: async (
      file: any,
      uuidAttribute?: string,
      uuidPattern?: string,
      descriptionAttribute?: string,
      geomProjectionTo?: string,
      lenient?: boolean,
      charset?: string,
      onlyBoundingBox?: boolean,
      process?: string,
      schema?: string,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists("importSpatialEntries", "file", file);
      const localVarPath = `/registries/actions/entries/import/spatial`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (uuidAttribute !== undefined) {
        localVarQueryParameter["uuidAttribute"] = uuidAttribute;
      }

      if (uuidPattern !== undefined) {
        localVarQueryParameter["uuidPattern"] = uuidPattern;
      }

      if (descriptionAttribute !== undefined) {
        localVarQueryParameter["descriptionAttribute"] = descriptionAttribute;
      }

      if (geomProjectionTo !== undefined) {
        localVarQueryParameter["geomProjectionTo"] = geomProjectionTo;
      }

      if (lenient !== undefined) {
        localVarQueryParameter["lenient"] = lenient;
      }

      if (charset !== undefined) {
        localVarQueryParameter["charset"] = charset;
      }

      if (onlyBoundingBox !== undefined) {
        localVarQueryParameter["onlyBoundingBox"] = onlyBoundingBox;
      }

      if (process !== undefined) {
        localVarQueryParameter["process"] = process;
      }

      if (schema !== undefined) {
        localVarQueryParameter["schema"] = schema;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter["uuidProcessing"] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Preview directory entries extracted from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewExtractedEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists("previewExtractedEntries", "xpath", xpath);
      const localVarPath = `/registries/actions/entries/collect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter["xpath"] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter["identifierXpath"] = identifierXpath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Preview updated matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewUpdatedRecordEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists("previewUpdatedRecordEntries", "xpath", xpath);
      const localVarPath = `/registries/actions/entries/synchronize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter["xpath"] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter["identifierXpath"] = identifierXpath;
      }

      if (propertiesToCopy) {
        localVarQueryParameter["propertiesToCopy"] = propertiesToCopy;
      }

      if (substituteAsXLink !== undefined) {
        localVarQueryParameter["substituteAsXLink"] = substituteAsXLink;
      }

      if (fq !== undefined) {
        localVarQueryParameter["fq"] = fq;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
     * @summary Search coordinate reference system (CRS)
     * @param {string} [q] Search value
     * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
     * @param {number} [rows] Number of results. Default is: 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCrs: async (
      q?: string,
      type?:
        | "CoordinateReferenceSystem"
        | "VerticalCRS"
        | "GeographicCRS"
        | "ProjectedCRS",
      rows?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/crs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter["q"] = q;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (rows !== undefined) {
        localVarQueryParameter["rows"] = rows;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search keywords
     * @param {string} [q] Query
     * @param {string} [lang] Query in that language
     * @param {number} [rows] Number of rows
     * @param {number} [start] Start from
     * @param {Array<string>} [pLang] Return keyword information in one or more languages
     * @param {Array<string>} [thesaurus] Thesaurus identifier
     * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
     * @param {string} [uri] URI query
     * @param {string} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchKeywords: async (
      q?: string,
      lang?: string,
      rows?: number,
      start?: number,
      pLang?: Array<string>,
      thesaurus?: Array<string>,
      type?: "STARTS_WITH" | "CONTAINS" | "MATCH",
      uri?: string,
      sort?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter["q"] = q;
      }

      if (lang !== undefined) {
        localVarQueryParameter["lang"] = lang;
      }

      if (rows !== undefined) {
        localVarQueryParameter["rows"] = rows;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (pLang) {
        localVarQueryParameter["pLang"] = pLang;
      }

      if (thesaurus) {
        localVarQueryParameter["thesaurus"] = thesaurus;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (uri !== undefined) {
        localVarQueryParameter["uri"] = uri;
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Update matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecordEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists("updateRecordEntries", "xpath", xpath);
      const localVarPath = `/registries/actions/entries/synchronize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter["xpath"] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter["identifierXpath"] = identifierXpath;
      }

      if (propertiesToCopy) {
        localVarQueryParameter["propertiesToCopy"] = propertiesToCopy;
      }

      if (substituteAsXLink !== undefined) {
        localVarQueryParameter["substituteAsXLink"] = substituteAsXLink;
      }

      if (fq !== undefined) {
        localVarQueryParameter["fq"] = fq;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from a file
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurus: async (
      type?: "external" | "local",
      dir?: string,
      stylesheet?: string,
      inlineObject4?: InlineObject4,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (dir !== undefined) {
        localVarQueryParameter["dir"] = dir;
      }

      if (stylesheet !== undefined) {
        localVarQueryParameter["stylesheet"] = stylesheet;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject4,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from URL or Registry
     * @param {string} [url] If set, try to download from the Internet.
     * @param {string} [registryUrl] If set, try to download from a registry.
     * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
     * @param {Array<string>} [registryLanguage] Languages to download from a registry.
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurusFromUrl: async (
      url?: string,
      registryUrl?: string,
      registryType?: "re3gistry" | "ldRegistry",
      registryLanguage?: Array<string>,
      type?: "external" | "local",
      dir?: string,
      stylesheet?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (url !== undefined) {
        localVarQueryParameter["url"] = url;
      }

      if (registryUrl !== undefined) {
        localVarQueryParameter["registryUrl"] = registryUrl;
      }

      if (registryType !== undefined) {
        localVarQueryParameter["registryType"] = registryType;
      }

      if (registryLanguage) {
        localVarQueryParameter["registryLanguage"] = registryLanguage;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (dir !== undefined) {
        localVarQueryParameter["dir"] = dir;
      }

      if (stylesheet !== undefined) {
        localVarQueryParameter["stylesheet"] = stylesheet;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RegistriesApi - functional programming interface
 * @export
 */
export const RegistriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RegistriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a thesaurus.
     * @summary Delete a thesaurus by name
     * @param {string} thesaurus Thesaurus to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteThesaurus(
      thesaurus: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThesaurus(
        thesaurus,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Extracts directory entries from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async extractEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.extractEntries(
        xpath,
        uuids,
        bucket,
        identifierXpath,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get CRS
     * @param {string} id CRS identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCrs(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Crs>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCrs(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of CRS type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCrsTypes(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCrsTypes(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
     * @summary Get a directory entry
     * @param {string} uuid Directory entry UUID.
     * @param {Array<string>} [process] Process
     * @param {string} [transformation] Transformation
     * @param {Array<string>} [lang] lang
     * @param {string} [schema] schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntry(
      uuid: string,
      process?: Array<string>,
      transformation?: string,
      lang?: Array<string>,
      schema?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntry(
        uuid,
        process,
        transformation,
        lang,
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeywordById(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywordById(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeywordById1(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywordById1(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Download the thesaurus in SKOS format.
     * @summary Download a thesaurus by name
     * @param {string} thesaurus Thesaurus to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThesaurus(
      thesaurus: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThesaurus(
        thesaurus,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
     * @summary Uploads a CSV file and convert it to SKOS format
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [encoding] Encoding. Default is UTF-8.
     * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
     * @param {Array<string>} [languages] Thesaurus languages
     * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
     * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
     * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
     * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
     * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
     * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
     * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
     * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
     * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importCsvAsThesaurus(
      type?: "external" | "local",
      dir?: string,
      encoding?: string,
      thesaurusNs?: string,
      languages?: Array<string>,
      thesaurusTitle?: string,
      conceptIdColumn?: string,
      conceptLabelColumn?: string,
      conceptDescriptionColumn?: string,
      conceptBroaderIdColumn?: string,
      conceptNarrowerIdColumn?: string,
      conceptRelatedIdColumn?: string,
      conceptLinkSeparator?: string,
      importAsThesaurus?: boolean,
      inlineObject5?: InlineObject5,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.importCsvAsThesaurus(
          type,
          dir,
          encoding,
          thesaurusNs,
          languages,
          thesaurusTitle,
          conceptIdColumn,
          conceptLabelColumn,
          conceptDescriptionColumn,
          conceptBroaderIdColumn,
          conceptNarrowerIdColumn,
          conceptRelatedIdColumn,
          conceptLinkSeparator,
          importAsThesaurus,
          inlineObject5,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
     * @summary Import spatial directory entries
     * @param {any} file The ZIP file to upload containing the Shapefile.
     * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
     * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
     * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
     * @param {string} [geomProjectionTo] geomProjectionTo
     * @param {boolean} [lenient] lenient
     * @param {string} [charset] Attribute table charset
     * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
     * @param {string} [process] Process
     * @param {string} [schema] Schema identifier
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {number} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importSpatialEntries(
      file: any,
      uuidAttribute?: string,
      uuidPattern?: string,
      descriptionAttribute?: string,
      geomProjectionTo?: string,
      lenient?: boolean,
      charset?: string,
      onlyBoundingBox?: boolean,
      process?: string,
      schema?: string,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.importSpatialEntries(
          file,
          uuidAttribute,
          uuidPattern,
          descriptionAttribute,
          geomProjectionTo,
          lenient,
          charset,
          onlyBoundingBox,
          process,
          schema,
          uuidProcessing,
          group,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Preview directory entries extracted from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewExtractedEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewExtractedEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Preview updated matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewUpdatedRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewUpdatedRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
     * @summary Search coordinate reference system (CRS)
     * @param {string} [q] Search value
     * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
     * @param {number} [rows] Number of results. Default is: 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCrs(
      q?: string,
      type?:
        | "CoordinateReferenceSystem"
        | "VerticalCRS"
        | "GeographicCRS"
        | "ProjectedCRS",
      rows?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Crs>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchCrs(
        q,
        type,
        rows,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Search keywords
     * @param {string} [q] Query
     * @param {string} [lang] Query in that language
     * @param {number} [rows] Number of rows
     * @param {number} [start] Start from
     * @param {Array<string>} [pLang] Return keyword information in one or more languages
     * @param {Array<string>} [thesaurus] Thesaurus identifier
     * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
     * @param {string} [uri] URI query
     * @param {string} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchKeywords(
      q?: string,
      lang?: string,
      rows?: number,
      start?: number,
      pLang?: Array<string>,
      thesaurus?: Array<string>,
      type?: "STARTS_WITH" | "CONTAINS" | "MATCH",
      uri?: string,
      sort?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchKeywords(
        q,
        lang,
        rows,
        start,
        pLang,
        thesaurus,
        type,
        uri,
        sort,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Update matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from a file
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadThesaurus(
      type?: "external" | "local",
      dir?: string,
      stylesheet?: string,
      inlineObject4?: InlineObject4,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadThesaurus(
        type,
        dir,
        stylesheet,
        inlineObject4,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from URL or Registry
     * @param {string} [url] If set, try to download from the Internet.
     * @param {string} [registryUrl] If set, try to download from a registry.
     * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
     * @param {Array<string>} [registryLanguage] Languages to download from a registry.
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadThesaurusFromUrl(
      url?: string,
      registryUrl?: string,
      registryType?: "re3gistry" | "ldRegistry",
      registryLanguage?: Array<string>,
      type?: "external" | "local",
      dir?: string,
      stylesheet?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uploadThesaurusFromUrl(
          url,
          registryUrl,
          registryType,
          registryLanguage,
          type,
          dir,
          stylesheet,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RegistriesApi - factory interface
 * @export
 */
export const RegistriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RegistriesApiFp(configuration);
  return {
    /**
     * Delete a thesaurus.
     * @summary Delete a thesaurus by name
     * @param {string} thesaurus Thesaurus to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThesaurus(thesaurus: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteThesaurus(thesaurus, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Extracts directory entries from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .extractEntries(xpath, uuids, bucket, identifierXpath, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get CRS
     * @param {string} id CRS identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrs(id: string, options?: any): AxiosPromise<Crs> {
      return localVarFp
        .getCrs(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of CRS type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrsTypes(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .getCrsTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
     * @summary Get a directory entry
     * @param {string} uuid Directory entry UUID.
     * @param {Array<string>} [process] Process
     * @param {string} [transformation] Transformation
     * @param {Array<string>} [lang] lang
     * @param {string} [schema] schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntry(
      uuid: string,
      process?: Array<string>,
      transformation?: string,
      lang?: Array<string>,
      schema?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getEntry(uuid, process, transformation, lang, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getKeywordById(
          id,
          thesaurus,
          lang,
          keywordOnly,
          transformation,
          langMap,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById1(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getKeywordById1(
          id,
          thesaurus,
          lang,
          keywordOnly,
          transformation,
          langMap,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Download the thesaurus in SKOS format.
     * @summary Download a thesaurus by name
     * @param {string} thesaurus Thesaurus to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThesaurus(thesaurus: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getThesaurus(thesaurus, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
     * @summary Uploads a CSV file and convert it to SKOS format
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [encoding] Encoding. Default is UTF-8.
     * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
     * @param {Array<string>} [languages] Thesaurus languages
     * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
     * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
     * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
     * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
     * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
     * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
     * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
     * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
     * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importCsvAsThesaurus(
      type?: "external" | "local",
      dir?: string,
      encoding?: string,
      thesaurusNs?: string,
      languages?: Array<string>,
      thesaurusTitle?: string,
      conceptIdColumn?: string,
      conceptLabelColumn?: string,
      conceptDescriptionColumn?: string,
      conceptBroaderIdColumn?: string,
      conceptNarrowerIdColumn?: string,
      conceptRelatedIdColumn?: string,
      conceptLinkSeparator?: string,
      importAsThesaurus?: boolean,
      inlineObject5?: InlineObject5,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .importCsvAsThesaurus(
          type,
          dir,
          encoding,
          thesaurusNs,
          languages,
          thesaurusTitle,
          conceptIdColumn,
          conceptLabelColumn,
          conceptDescriptionColumn,
          conceptBroaderIdColumn,
          conceptNarrowerIdColumn,
          conceptRelatedIdColumn,
          conceptLinkSeparator,
          importAsThesaurus,
          inlineObject5,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
     * @summary Import spatial directory entries
     * @param {any} file The ZIP file to upload containing the Shapefile.
     * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
     * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
     * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
     * @param {string} [geomProjectionTo] geomProjectionTo
     * @param {boolean} [lenient] lenient
     * @param {string} [charset] Attribute table charset
     * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
     * @param {string} [process] Process
     * @param {string} [schema] Schema identifier
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {number} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importSpatialEntries(
      file: any,
      uuidAttribute?: string,
      uuidPattern?: string,
      descriptionAttribute?: string,
      geomProjectionTo?: string,
      lenient?: boolean,
      charset?: string,
      onlyBoundingBox?: boolean,
      process?: string,
      schema?: string,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: number,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .importSpatialEntries(
          file,
          uuidAttribute,
          uuidPattern,
          descriptionAttribute,
          geomProjectionTo,
          lenient,
          charset,
          onlyBoundingBox,
          process,
          schema,
          uuidProcessing,
          group,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Preview directory entries extracted from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewExtractedEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewExtractedEntries(xpath, uuids, bucket, identifierXpath, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Preview updated matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewUpdatedRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewUpdatedRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
     * @summary Search coordinate reference system (CRS)
     * @param {string} [q] Search value
     * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
     * @param {number} [rows] Number of results. Default is: 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCrs(
      q?: string,
      type?:
        | "CoordinateReferenceSystem"
        | "VerticalCRS"
        | "GeographicCRS"
        | "ProjectedCRS",
      rows?: number,
      options?: any
    ): AxiosPromise<Array<Crs>> {
      return localVarFp
        .searchCrs(q, type, rows, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search keywords
     * @param {string} [q] Query
     * @param {string} [lang] Query in that language
     * @param {number} [rows] Number of rows
     * @param {number} [start] Start from
     * @param {Array<string>} [pLang] Return keyword information in one or more languages
     * @param {Array<string>} [thesaurus] Thesaurus identifier
     * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
     * @param {string} [uri] URI query
     * @param {string} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchKeywords(
      q?: string,
      lang?: string,
      rows?: number,
      start?: number,
      pLang?: Array<string>,
      thesaurus?: Array<string>,
      type?: "STARTS_WITH" | "CONTAINS" | "MATCH",
      uri?: string,
      sort?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .searchKeywords(
          q,
          lang,
          rows,
          start,
          pLang,
          thesaurus,
          type,
          uri,
          sort,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Update matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .updateRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from a file
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurus(
      type?: "external" | "local",
      dir?: string,
      stylesheet?: string,
      inlineObject4?: InlineObject4,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .uploadThesaurus(type, dir, stylesheet, inlineObject4, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from URL or Registry
     * @param {string} [url] If set, try to download from the Internet.
     * @param {string} [registryUrl] If set, try to download from a registry.
     * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
     * @param {Array<string>} [registryLanguage] Languages to download from a registry.
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurusFromUrl(
      url?: string,
      registryUrl?: string,
      registryType?: "re3gistry" | "ldRegistry",
      registryLanguage?: Array<string>,
      type?: "external" | "local",
      dir?: string,
      stylesheet?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .uploadThesaurusFromUrl(
          url,
          registryUrl,
          registryType,
          registryLanguage,
          type,
          dir,
          stylesheet,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RegistriesApi - object-oriented interface
 * @export
 * @class RegistriesApi
 * @extends {BaseAPI}
 */
export class RegistriesApi extends BaseAPI {
  /**
   * Delete a thesaurus.
   * @summary Delete a thesaurus by name
   * @param {string} thesaurus Thesaurus to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public deleteThesaurus(thesaurus: string, options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .deleteThesaurus(thesaurus, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
   * @summary Extracts directory entries from records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .extractEntries(xpath, uuids, bucket, identifierXpath, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get CRS
   * @param {string} id CRS identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getCrs(id: string, options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .getCrs(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of CRS type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getCrsTypes(options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .getCrsTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
   * @summary Get a directory entry
   * @param {string} uuid Directory entry UUID.
   * @param {Array<string>} [process] Process
   * @param {string} [transformation] Transformation
   * @param {Array<string>} [lang] lang
   * @param {string} [schema] schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .getEntry(uuid, process, transformation, lang, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
   * @summary Get keyword by id
   * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
   * @param {string} thesaurus Thesaurus to look info for the keyword(s).
   * @param {Array<string>} [lang] Languages.
   * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
   * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .getKeywordById(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
   * @summary Get keyword by id
   * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
   * @param {string} thesaurus Thesaurus to look info for the keyword(s).
   * @param {Array<string>} [lang] Languages.
   * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
   * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .getKeywordById1(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download the thesaurus in SKOS format.
   * @summary Download a thesaurus by name
   * @param {string} thesaurus Thesaurus to download.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getThesaurus(thesaurus: string, options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .getThesaurus(thesaurus, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
   * @summary Uploads a CSV file and convert it to SKOS format
   * @param {'external' | 'local'} [type] Local or external (default).
   * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param {string} [encoding] Encoding. Default is UTF-8.
   * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
   * @param {Array<string>} [languages] Thesaurus languages
   * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
   * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
   * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
   * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
   * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
   * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
   * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
   * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
   * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
   * @param {InlineObject5} [inlineObject5]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public importCsvAsThesaurus(
    type?: "external" | "local",
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    inlineObject5?: InlineObject5,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .importCsvAsThesaurus(
        type,
        dir,
        encoding,
        thesaurusNs,
        languages,
        thesaurusTitle,
        conceptIdColumn,
        conceptLabelColumn,
        conceptDescriptionColumn,
        conceptBroaderIdColumn,
        conceptNarrowerIdColumn,
        conceptRelatedIdColumn,
        conceptLinkSeparator,
        importAsThesaurus,
        inlineObject5,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
   * @summary Import spatial directory entries
   * @param {any} file The ZIP file to upload containing the Shapefile.
   * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
   * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
   * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
   * @param {string} [geomProjectionTo] geomProjectionTo
   * @param {boolean} [lenient] lenient
   * @param {string} [charset] Attribute table charset
   * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
   * @param {string} [process] Process
   * @param {string} [schema] Schema identifier
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {number} [group] The group the record is attached to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public importSpatialEntries(
    file: any,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
    group?: number,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .importSpatialEntries(
        file,
        uuidAttribute,
        uuidPattern,
        descriptionAttribute,
        geomProjectionTo,
        lenient,
        charset,
        onlyBoundingBox,
        process,
        schema,
        uuidProcessing,
        group,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
   * @summary Preview directory entries extracted from records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .previewExtractedEntries(xpath, uuids, bucket, identifierXpath, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @summary Preview updated matching entries in records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
   * @param {boolean} [substituteAsXLink] Replace entry by XLink.
   * @param {string} [fq] Filter query for directory search.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .previewUpdatedRecordEntries(
        xpath,
        uuids,
        bucket,
        identifierXpath,
        propertiesToCopy,
        substituteAsXLink,
        fq,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
   * @summary Search coordinate reference system (CRS)
   * @param {string} [q] Search value
   * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
   * @param {number} [rows] Number of results. Default is: 100
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public searchCrs(
    q?: string,
    type?:
      | "CoordinateReferenceSystem"
      | "VerticalCRS"
      | "GeographicCRS"
      | "ProjectedCRS",
    rows?: number,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .searchCrs(q, type, rows, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search keywords
   * @param {string} [q] Query
   * @param {string} [lang] Query in that language
   * @param {number} [rows] Number of rows
   * @param {number} [start] Start from
   * @param {Array<string>} [pLang] Return keyword information in one or more languages
   * @param {Array<string>} [thesaurus] Thesaurus identifier
   * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
   * @param {string} [uri] URI query
   * @param {string} [sort] Sort by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: "STARTS_WITH" | "CONTAINS" | "MATCH",
    uri?: string,
    sort?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .searchKeywords(
        q,
        lang,
        rows,
        start,
        pLang,
        thesaurus,
        type,
        uri,
        sort,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @summary Update matching entries in records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
   * @param {boolean} [substituteAsXLink] Replace entry by XLink.
   * @param {string} [fq] Filter query for directory search.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .updateRecordEntries(
        xpath,
        uuids,
        bucket,
        identifierXpath,
        propertiesToCopy,
        substituteAsXLink,
        fq,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Uploads a new thesaurus.
   * @summary Uploads a new thesaurus from a file
   * @param {'external' | 'local'} [type] Local or external (default).
   * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
   * @param {InlineObject4} [inlineObject4]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public uploadThesaurus(
    type?: "external" | "local",
    dir?: string,
    stylesheet?: string,
    inlineObject4?: InlineObject4,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .uploadThesaurus(type, dir, stylesheet, inlineObject4, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Uploads a new thesaurus.
   * @summary Uploads a new thesaurus from URL or Registry
   * @param {string} [url] If set, try to download from the Internet.
   * @param {string} [registryUrl] If set, try to download from a registry.
   * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
   * @param {Array<string>} [registryLanguage] Languages to download from a registry.
   * @param {'external' | 'local'} [type] Local or external (default).
   * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: "re3gistry" | "ldRegistry",
    registryLanguage?: Array<string>,
    type?: "external" | "local",
    dir?: string,
    stylesheet?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .uploadThesaurusFromUrl(
        url,
        registryUrl,
        registryType,
        registryLanguage,
        type,
        dir,
        stylesheet,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
