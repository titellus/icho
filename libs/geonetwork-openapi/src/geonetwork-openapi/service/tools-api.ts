/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { Translations } from "../../..//geonetwork-openapi/model";
/**
 * ToolsApi - axios parameter creator
 * @export
 */
export const ToolsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add or update all database translations.
     * @param {Array<Translations>} translations
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslations: async (
      translations: Array<Translations>,
      replace?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'translations' is not null or undefined
      assertParamExists("addTranslations", "translations", translations);
      const localVarPath = `/i18n/db/translations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (replace !== undefined) {
        localVarQueryParameter["replace"] = replace;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        translations,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Database translations can be used to customize labels in the UI for different languages.
     * @summary Add or update database translations for a key.
     * @param {string} key Untranslated key for which translations are provided.
     * @param {{ [key: string]: string; }} requestBody An object where keys are valid 3-letter language codes (e.g. &#x60;eng&#x60; or &#x60;fre&#x60;) and values are custom translations for the corresponding language.
     * @param {boolean} [replace] Set to &#x60;true&#x60; to erase all existing translations for that key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslationsFor: async (
      key: string,
      requestBody: { [key: string]: string },
      replace?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("addTranslationsFor", "key", key);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("addTranslationsFor", "requestBody", requestBody);
      const localVarPath = `/i18n/db/translations/{key}`.replace(
        `{${"key"}}`,
        encodeURIComponent(String(key))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (replace !== undefined) {
        localVarQueryParameter["replace"] = replace;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
     * @summary Generate a SLD with a new filter
     * @param {string} url The WMS server URL
     * @param {string} layers The layers
     * @param {string} filters The filters in JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    buildSLD: async (
      url: string,
      layers: string,
      filters: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'url' is not null or undefined
      assertParamExists("buildSLD", "url", url);
      // verify required parameter 'layers' is not null or undefined
      assertParamExists("buildSLD", "layers", layers);
      // verify required parameter 'filters' is not null or undefined
      assertParamExists("buildSLD", "filters", filters);
      const localVarPath = `/tools/ogc/sld`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (url !== undefined) {
        localVarQueryParameter["url"] = url;
      }

      if (layers !== undefined) {
        localVarQueryParameter["layers"] = layers;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Call a migration step
     * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callStep: async (
      stepName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stepName' is not null or undefined
      assertParamExists("callStep", "stepName", stepName);
      const localVarPath = `/tools/migration/steps/{stepName}`.replace(
        `{${"stepName"}}`,
        encodeURIComponent(String(stepName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Clean translation packages cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanTranslationsPackagesCache: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/cache`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete custom translations stored in the database.
     * @summary Delete database translations.
     * @param {string} key Untranslated key for which all translations will be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTranslations: async (
      key: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteTranslations", "key", key);
      const localVarPath = `/i18n/db/translations/{key}`.replace(
        `{${"key"}}`,
        encodeURIComponent(String(key))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Clean all SLD generated previously
     * @summary Remove all SLD files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deteleSLD: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tools/ogc/sld`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download a SLD
     * @param {number} id The SLD identifier
     * @param {string} extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSLD: async (
      id: number,
      extension: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("downloadSLD", "id", id);
      // verify required parameter 'extension' is not null or undefined
      assertParamExists("downloadSLD", "extension", extension);
      const localVarPath = `/tools/ogc/sld/{id}.{extension}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"extension"}}`, encodeURIComponent(String(extension)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List custom user translations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomTranslations: async (
      type?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db/custom`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter["type"] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List database translations (used to overrides client application translations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDbTranslations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db/translations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the list of SLD available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSLD: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/tools/ogc/sld`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List translations for database description table
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslations: async (
      type?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter["type"] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of translation packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/packages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a translation package.
     * @param {string} pack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage1: async (
      pack: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pack' is not null or undefined
      assertParamExists("getTranslationsPackage1", "pack", pack);
      const localVarPath = `/i18n/packages/{pack}`.replace(
        `{${"pack"}}`,
        encodeURIComponent(String(pack))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove all database translations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAllTranslations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db/translations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send an email to the catalog feedback email.
     * @summary Test mail configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testMailConfiguration: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tools/mail/test`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ToolsApi - functional programming interface
 * @export
 */
export const ToolsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ToolsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add or update all database translations.
     * @param {Array<Translations>} translations
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTranslations(
      translations: Array<Translations>,
      replace?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTranslations(
        translations,
        replace,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Database translations can be used to customize labels in the UI for different languages.
     * @summary Add or update database translations for a key.
     * @param {string} key Untranslated key for which translations are provided.
     * @param {{ [key: string]: string; }} requestBody An object where keys are valid 3-letter language codes (e.g. &#x60;eng&#x60; or &#x60;fre&#x60;) and values are custom translations for the corresponding language.
     * @param {boolean} [replace] Set to &#x60;true&#x60; to erase all existing translations for that key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTranslationsFor(
      key: string,
      requestBody: { [key: string]: string },
      replace?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addTranslationsFor(
          key,
          requestBody,
          replace,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
     * @summary Generate a SLD with a new filter
     * @param {string} url The WMS server URL
     * @param {string} layers The layers
     * @param {string} filters The filters in JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async buildSLD(
      url: string,
      layers: string,
      filters: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.buildSLD(
        url,
        layers,
        filters,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Call a migration step
     * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callStep(
      stepName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callStep(
        stepName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Clean translation packages cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cleanTranslationsPackagesCache(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cleanTranslationsPackagesCache(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete custom translations stored in the database.
     * @summary Delete database translations.
     * @param {string} key Untranslated key for which all translations will be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTranslations(
      key: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteTranslations(key, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Clean all SLD generated previously
     * @summary Remove all SLD files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deteleSLD(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deteleSLD(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Download a SLD
     * @param {number} id The SLD identifier
     * @param {string} extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadSLD(
      id: number,
      extension: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSLD(
        id,
        extension,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List custom user translations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomTranslations(
      type?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Translations>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCustomTranslations(type, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List database translations (used to overrides client application translations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDbTranslations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<String>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDbTranslations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the list of SLD available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSLD(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSLD(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List translations for database description table
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranslations(
      type?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTranslations(
        type,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of translation packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranslationsPackage(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: Array<string> }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTranslationsPackage(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a translation package.
     * @param {string} pack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranslationsPackage1(
      pack: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTranslationsPackage1(pack, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove all database translations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeAllTranslations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeAllTranslations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Send an email to the catalog feedback email.
     * @summary Test mail configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async testMailConfiguration(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.testMailConfiguration(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ToolsApi - factory interface
 * @export
 */
export const ToolsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ToolsApiFp(configuration);
  return {
    /**
     *
     * @summary Add or update all database translations.
     * @param {Array<Translations>} translations
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslations(
      translations: Array<Translations>,
      replace?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .addTranslations(translations, replace, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Database translations can be used to customize labels in the UI for different languages.
     * @summary Add or update database translations for a key.
     * @param {string} key Untranslated key for which translations are provided.
     * @param {{ [key: string]: string; }} requestBody An object where keys are valid 3-letter language codes (e.g. &#x60;eng&#x60; or &#x60;fre&#x60;) and values are custom translations for the corresponding language.
     * @param {boolean} [replace] Set to &#x60;true&#x60; to erase all existing translations for that key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslationsFor(
      key: string,
      requestBody: { [key: string]: string },
      replace?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .addTranslationsFor(key, requestBody, replace, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
     * @summary Generate a SLD with a new filter
     * @param {string} url The WMS server URL
     * @param {string} layers The layers
     * @param {string} filters The filters in JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    buildSLD(
      url: string,
      layers: string,
      filters: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .buildSLD(url, layers, filters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Call a migration step
     * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callStep(stepName: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .callStep(stepName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Clean translation packages cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanTranslationsPackagesCache(options?: any): AxiosPromise<void> {
      return localVarFp
        .cleanTranslationsPackagesCache(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete custom translations stored in the database.
     * @summary Delete database translations.
     * @param {string} key Untranslated key for which all translations will be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTranslations(key: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteTranslations(key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Clean all SLD generated previously
     * @summary Remove all SLD files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deteleSLD(options?: any): AxiosPromise<void> {
      return localVarFp
        .deteleSLD(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download a SLD
     * @param {number} id The SLD identifier
     * @param {string} extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSLD(
      id: number,
      extension: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadSLD(id, extension, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List custom user translations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomTranslations(
      type?: Array<string>,
      options?: any
    ): AxiosPromise<Array<Translations>> {
      return localVarFp
        .getCustomTranslations(type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List database translations (used to overrides client application translations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDbTranslations(options?: any): AxiosPromise<String> {
      return localVarFp
        .getDbTranslations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the list of SLD available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSLD(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .getSLD(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List translations for database description table
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslations(
      type?: Array<string>,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getTranslations(type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of translation packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage(
      options?: any
    ): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp
        .getTranslationsPackage(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a translation package.
     * @param {string} pack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage1(
      pack: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getTranslationsPackage1(pack, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove all database translations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAllTranslations(options?: any): AxiosPromise<void> {
      return localVarFp
        .removeAllTranslations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Send an email to the catalog feedback email.
     * @summary Test mail configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testMailConfiguration(options?: any): AxiosPromise<string> {
      return localVarFp
        .testMailConfiguration(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ToolsApi - object-oriented interface
 * @export
 * @class ToolsApi
 * @extends {BaseAPI}
 */
export class ToolsApi extends BaseAPI {
  /**
   *
   * @summary Add or update all database translations.
   * @param {Array<Translations>} translations
   * @param {boolean} [replace]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public addTranslations(
    translations: Array<Translations>,
    replace?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .addTranslations(translations, replace, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Database translations can be used to customize labels in the UI for different languages.
   * @summary Add or update database translations for a key.
   * @param {string} key Untranslated key for which translations are provided.
   * @param {{ [key: string]: string; }} requestBody An object where keys are valid 3-letter language codes (e.g. &#x60;eng&#x60; or &#x60;fre&#x60;) and values are custom translations for the corresponding language.
   * @param {boolean} [replace] Set to &#x60;true&#x60; to erase all existing translations for that key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public addTranslationsFor(
    key: string,
    requestBody: { [key: string]: string },
    replace?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .addTranslationsFor(key, requestBody, replace, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
   * @summary Generate a SLD with a new filter
   * @param {string} url The WMS server URL
   * @param {string} layers The layers
   * @param {string} filters The filters in JSON
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public buildSLD(
    url: string,
    layers: string,
    filters: string,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .buildSLD(url, layers, filters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Call a migration step
   * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public callStep(stepName: string, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .callStep(stepName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Clean translation packages cache.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public cleanTranslationsPackagesCache(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .cleanTranslationsPackagesCache(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete custom translations stored in the database.
   * @summary Delete database translations.
   * @param {string} key Untranslated key for which all translations will be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public deleteTranslations(key: string, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .deleteTranslations(key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Clean all SLD generated previously
   * @summary Remove all SLD files
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public deteleSLD(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .deteleSLD(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download a SLD
   * @param {number} id The SLD identifier
   * @param {string} extension
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public downloadSLD(
    id: number,
    extension: string,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .downloadSLD(id, extension, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List custom user translations
   * @param {Array<string>} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getCustomTranslations(
    type?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .getCustomTranslations(type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List database translations (used to overrides client application translations).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getDbTranslations(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getDbTranslations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the list of SLD available
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getSLD(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getSLD(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List translations for database description table
   * @param {Array<string>} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getTranslations(type?: Array<string>, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getTranslations(type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of translation packages.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getTranslationsPackage(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getTranslationsPackage(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a translation package.
   * @param {string} pack
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getTranslationsPackage1(pack: string, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getTranslationsPackage1(pack, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove all database translations.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public removeAllTranslations(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .removeAllTranslations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send an email to the catalog feedback email.
   * @summary Test mail configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public testMailConfiguration(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .testMailConfiguration(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
