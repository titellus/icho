/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { MetadataReplacementProcessingReport } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { ProcessingReport } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { XsltMetadataProcessingReport } from "../../..//geonetwork-openapi/model";
/**
 * ProcessesApi - axios parameter creator
 * @export
 */
export const ProcessesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Clear process reports list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/processes/reports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
     * @summary Get current process reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessReport: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/processes/reports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview process result applied to one or more records
     * @param {string} process Process identifier
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [appendFirst] Append documents before processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessRecords: async (
      process: string,
      diffType?: "patch" | "diff" | "diffhtml",
      uuids?: Array<string>,
      bucket?: string,
      appendFirst?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'process' is not null or undefined
      assertParamExists("previewProcessRecords", "process", process);
      const localVarPath = `/processes/{process}`.replace(
        `{${"process"}}`,
        encodeURIComponent(String(process))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (diffType !== undefined) {
        localVarQueryParameter["diffType"] = diffType;
      }

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (appendFirst !== undefined) {
        localVarQueryParameter["appendFirst"] = appendFirst;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview of search and replace text.
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessSearchAndReplace: async (
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      diffType?: "patch" | "diff" | "diffhtml",
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'search' is not null or undefined
      assertParamExists("previewProcessSearchAndReplace", "search", search);
      const localVarPath = `/processes/db/search-and-replace`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (useRegexp !== undefined) {
        localVarQueryParameter["useRegexp"] = useRegexp;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (replace !== undefined) {
        localVarQueryParameter["replace"] = replace;
      }

      if (regexpFlags !== undefined) {
        localVarQueryParameter["regexpFlags"] = regexpFlags;
      }

      if (diffType !== undefined) {
        localVarQueryParameter["diffType"] = diffType;
      }

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process to one or more records
     * @param {string} process Process identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecords: async (
      process: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'process' is not null or undefined
      assertParamExists("processRecords", "process", process);
      const localVarPath = `/processes/{process}`.replace(
        `{${"process"}}`,
        encodeURIComponent(String(process))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (updateDateStamp !== undefined) {
        localVarQueryParameter["updateDateStamp"] = updateDateStamp;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a database search and replace to one or more records
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processSearchAndReplace: async (
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'search' is not null or undefined
      assertParamExists("processSearchAndReplace", "search", search);
      const localVarPath = `/processes/db/search-and-replace`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (useRegexp !== undefined) {
        localVarQueryParameter["useRegexp"] = useRegexp;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (replace !== undefined) {
        localVarQueryParameter["replace"] = replace;
      }

      if (regexpFlags !== undefined) {
        localVarQueryParameter["regexpFlags"] = regexpFlags;
      }

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (updateDateStamp !== undefined) {
        localVarQueryParameter["updateDateStamp"] = updateDateStamp;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
     * @summary Search and replace values in one or more records
     * @param {string} [process]
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
     * @param {boolean} [isCaseInsensitive] Case insensitive search.
     * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAndReplace: async (
      process?: string,
      uuids?: Array<string>,
      bucket?: string,
      isTesting?: boolean,
      isCaseInsensitive?: boolean,
      vacuumMode?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/processes/search-and-replace`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (process !== undefined) {
        localVarQueryParameter["process"] = process;
      }

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (isTesting !== undefined) {
        localVarQueryParameter["isTesting"] = isTesting;
      }

      if (isCaseInsensitive !== undefined) {
        localVarQueryParameter["isCaseInsensitive"] = isCaseInsensitive;
      }

      if (vacuumMode !== undefined) {
        localVarQueryParameter["vacuumMode"] = vacuumMode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProcessesApi - functional programming interface
 * @export
 */
export const ProcessesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProcessesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Clear process reports list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
     * @summary Get current process reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProcessReport(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProcessingReport>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProcessReport(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview process result applied to one or more records
     * @param {string} process Process identifier
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [appendFirst] Append documents before processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewProcessRecords(
      process: string,
      diffType?: "patch" | "diff" | "diffhtml",
      uuids?: Array<string>,
      bucket?: string,
      appendFirst?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewProcessRecords(
          process,
          diffType,
          uuids,
          bucket,
          appendFirst,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *  When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview of search and replace text.
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewProcessSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      diffType?: "patch" | "diff" | "diffhtml",
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewProcessSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          diffType,
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process to one or more records
     * @param {string} process Process identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processRecords(
      process: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<XsltMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.processRecords(
        process,
        uuids,
        bucket,
        updateDateStamp,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a database search and replace to one or more records
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<XsltMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.processSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          uuids,
          bucket,
          updateDateStamp,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
     * @summary Search and replace values in one or more records
     * @param {string} [process]
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
     * @param {boolean} [isCaseInsensitive] Case insensitive search.
     * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAndReplace(
      process?: string,
      uuids?: Array<string>,
      bucket?: string,
      isTesting?: boolean,
      isCaseInsensitive?: boolean,
      vacuumMode?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataReplacementProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchAndReplace(
          process,
          uuids,
          bucket,
          isTesting,
          isCaseInsensitive,
          vacuumMode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProcessesApi - factory interface
 * @export
 */
export const ProcessesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProcessesApiFp(configuration);
  return {
    /**
     *
     * @summary Clear process reports list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(options?: any): AxiosPromise<void> {
      return localVarFp
        ._delete(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
     * @summary Get current process reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessReport(options?: any): AxiosPromise<Array<ProcessingReport>> {
      return localVarFp
        .getProcessReport(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview process result applied to one or more records
     * @param {string} process Process identifier
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [appendFirst] Append documents before processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessRecords(
      process: string,
      diffType?: "patch" | "diff" | "diffhtml",
      uuids?: Array<string>,
      bucket?: string,
      appendFirst?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewProcessRecords(
          process,
          diffType,
          uuids,
          bucket,
          appendFirst,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview of search and replace text.
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      diffType?: "patch" | "diff" | "diffhtml",
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewProcessSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          diffType,
          uuids,
          bucket,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process to one or more records
     * @param {string} process Process identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecords(
      process: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: any
    ): AxiosPromise<XsltMetadataProcessingReport> {
      return localVarFp
        .processRecords(process, uuids, bucket, updateDateStamp, index, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a database search and replace to one or more records
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: any
    ): AxiosPromise<XsltMetadataProcessingReport> {
      return localVarFp
        .processSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          uuids,
          bucket,
          updateDateStamp,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
     * @summary Search and replace values in one or more records
     * @param {string} [process]
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
     * @param {boolean} [isCaseInsensitive] Case insensitive search.
     * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAndReplace(
      process?: string,
      uuids?: Array<string>,
      bucket?: string,
      isTesting?: boolean,
      isCaseInsensitive?: boolean,
      vacuumMode?: string,
      options?: any
    ): AxiosPromise<MetadataReplacementProcessingReport> {
      return localVarFp
        .searchAndReplace(
          process,
          uuids,
          bucket,
          isTesting,
          isCaseInsensitive,
          vacuumMode,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProcessesApi - object-oriented interface
 * @export
 * @class ProcessesApi
 * @extends {BaseAPI}
 */
export class ProcessesApi extends BaseAPI {
  /**
   *
   * @summary Clear process reports list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public _delete(options?: AxiosRequestConfig) {
    return ProcessesApiFp(this.configuration)
      ._delete(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
   * @summary Get current process reports
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public getProcessReport(options?: AxiosRequestConfig) {
    return ProcessesApiFp(this.configuration)
      .getProcessReport(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
   * @summary Preview process result applied to one or more records
   * @param {string} process Process identifier
   * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [appendFirst] Append documents before processing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public previewProcessRecords(
    process: string,
    diffType?: "patch" | "diff" | "diffhtml",
    uuids?: Array<string>,
    bucket?: string,
    appendFirst?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .previewProcessRecords(
        process,
        diffType,
        uuids,
        bucket,
        appendFirst,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  When errors occur during processing, the processing report is returned in JSON format.
   * @summary Preview of search and replace text.
   * @param {string} search Value to search for
   * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   * @param {string} [replace] Replacement
   * @param {string} [regexpFlags] regexpFlags
   * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public previewProcessSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    diffType?: "patch" | "diff" | "diffhtml",
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .previewProcessSearchAndReplace(
        search,
        useRegexp,
        replace,
        regexpFlags,
        diffType,
        uuids,
        bucket,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Apply a process to one or more records
   * @param {string} process Process identifier
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param {boolean} [index] Index after processing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public processRecords(
    process: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .processRecords(process, uuids, bucket, updateDateStamp, index, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Apply a database search and replace to one or more records
   * @param {string} search Value to search for
   * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   * @param {string} [replace] Replacement
   * @param {string} [regexpFlags] regexpFlags
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param {boolean} [index] Index after processing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public processSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .processSearchAndReplace(
        search,
        useRegexp,
        replace,
        regexpFlags,
        uuids,
        bucket,
        updateDateStamp,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
   * @summary Search and replace values in one or more records
   * @param {string} [process]
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
   * @param {boolean} [isCaseInsensitive] Case insensitive search.
   * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public searchAndReplace(
    process?: string,
    uuids?: Array<string>,
    bucket?: string,
    isTesting?: boolean,
    isCaseInsensitive?: boolean,
    vacuumMode?: string,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .searchAndReplace(
        process,
        uuids,
        bucket,
        isTesting,
        isCaseInsensitive,
        vacuumMode,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
