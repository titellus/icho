/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { LogFileResponse } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { Setting } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SettingsListResponse } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SiteInformation } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { Status } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SystemInfo } from "../../..//geonetwork-openapi/model";
/**
 * SiteApi - axios parameter creator
 * @export
 */
export const SiteApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * May be used when indexing task is hanging.
     * @summary Force to commit pending documents in index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitIndexChanges: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/commit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get site informations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInformation: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get last activity
     * @param {number} [lines] Number of lines to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivity: async (
      lines?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/logging/activity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lines !== undefined) {
        localVarQueryParameter["lines"] = lines;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get last activity in a ZIP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivityInAZip: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/logging/activity/zip`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get log files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogFiles: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/logging`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary robots.txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotsText: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/robots.txt`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provides also setting properties.
     * @summary Get settings with details
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsDetails: async (
      set?: Array<
        | "INSPIRE"
        | "CSW"
        | "HARVESTER"
        | "USER_GROUP_ONLY"
        | "AUTH"
        | "READ_ONLY"
        | "INDEX"
        | "SYSTEMINFO"
        | "STAGING_PROFILE"
        | "TYPE"
      >,
      key?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/settings/details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (set) {
        localVarQueryParameter["set"] = set;
      }

      if (key) {
        localVarQueryParameter["key"] = key;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return public settings for anonymous users, internals are allowed for authenticated.
     * @summary Get settings
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsSet: async (
      set?: Array<
        | "INSPIRE"
        | "CSW"
        | "HARVESTER"
        | "USER_GROUP_ONLY"
        | "AUTH"
        | "READ_ONLY"
        | "INDEX"
        | "SYSTEMINFO"
        | "STAGING_PROFILE"
        | "TYPE"
      >,
      key?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (set) {
        localVarQueryParameter["set"] = set;
      }

      if (key) {
        localVarQueryParameter["key"] = key;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get site (or portal) description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSiteOrPortalDescription: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get sitemap
     * @param {string} [format] Format (xml or html).
     * @param {number} [doc] page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemap: async (
      format?: string,
      doc?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sitemap`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (doc !== undefined) {
        localVarQueryParameter["doc"] = doc;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To know when and how this version of the application was built.
     * @summary Get build details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/build`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * XSL transformations may be applied while importing or harvesting records.
     * @summary Get XSL tranformations available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getXslTransformations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/transforms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index
     * @param {boolean} [reset] Drop and recreate index
     * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
     * @param {boolean} [havingXlinkOnly] Records having only XLinks
     * @param {Array<string>} [indices] Index. By default only remove record index.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index1: async (
      reset?: boolean,
      asynchronous?: boolean,
      havingXlinkOnly?: boolean,
      indices?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (reset !== undefined) {
        localVarQueryParameter["reset"] = reset;
      }

      if (asynchronous !== undefined) {
        localVarQueryParameter["asynchronous"] = asynchronous;
      }

      if (havingXlinkOnly !== undefined) {
        localVarQueryParameter["havingXlinkOnly"] = havingXlinkOnly;
      }

      if (indices) {
        localVarQueryParameter["indices"] = indices;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index synchronized with database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexAndDbSynchronizationStatus: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/synchronized`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexCommit: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/commit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexStatus: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Is CAS enabled?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCasEnabled: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/isCasEnabled`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Is indexing?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isIndexing: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/indexing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Is in read-only mode?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isReadOnly: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/readonly`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save settings
     * @param {{ [key: string]: string; }} allRequestParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveSettings: async (
      allRequestParams: { [key: string]: string },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'allRequestParams' is not null or undefined
      assertParamExists("saveSettings", "allRequestParams", allRequestParams);
      const localVarPath = `/site/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (allRequestParams !== undefined) {
        localVarQueryParameter["allRequestParams"] = allRequestParams;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
     * @summary Set catalog logo
     * @param {string} file Logo to use for the catalog
     * @param {boolean} [asFavicon] Create favicon too
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLogo: async (
      file: string,
      asFavicon?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists("setLogo", "file", file);
      const localVarPath = `/site/logo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (file !== undefined) {
        localVarQueryParameter["file"] = file;
      }

      if (asFavicon !== undefined) {
        localVarQueryParameter["asFavicon"] = asFavicon;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * TODO: Needs doc
     * @summary Update staging profile
     * @param {'testing' | 'development' | 'production'} profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStagingProfile: async (
      profile: "testing" | "development" | "production",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'profile' is not null or undefined
      assertParamExists("updateStagingProfile", "profile", profile);
      const localVarPath = `/site/info/staging/{profile}`.replace(
        `{${"profile"}}`,
        encodeURIComponent(String(profile))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SiteApi - functional programming interface
 * @export
 */
export const SiteApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SiteApiAxiosParamCreator(configuration);
  return {
    /**
     * May be used when indexing task is hanging.
     * @summary Force to commit pending documents in index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commitIndexChanges(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.commitIndexChanges(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get site informations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInformation(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SiteInformation>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInformation(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get last activity
     * @param {number} [lines] Number of lines to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLastActivity(
      lines?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLastActivity(
        lines,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get last activity in a ZIP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLastActivityInAZip(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLastActivityInAZip(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get log files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogFiles(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<LogFileResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogFiles(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary robots.txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRobotsText(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRobotsText(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Provides also setting properties.
     * @summary Get settings with details
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettingsDetails(
      set?: Array<
        | "INSPIRE"
        | "CSW"
        | "HARVESTER"
        | "USER_GROUP_ONLY"
        | "AUTH"
        | "READ_ONLY"
        | "INDEX"
        | "SYSTEMINFO"
        | "STAGING_PROFILE"
        | "TYPE"
      >,
      key?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Setting>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSettingsDetails(set, key, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return public settings for anonymous users, internals are allowed for authenticated.
     * @summary Get settings
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettingsSet(
      set?: Array<
        | "INSPIRE"
        | "CSW"
        | "HARVESTER"
        | "USER_GROUP_ONLY"
        | "AUTH"
        | "READ_ONLY"
        | "INDEX"
        | "SYSTEMINFO"
        | "STAGING_PROFILE"
        | "TYPE"
      >,
      key?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SettingsListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingsSet(
        set,
        key,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get site (or portal) description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSiteOrPortalDescription(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SettingsListResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSiteOrPortalDescription(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get sitemap
     * @param {string} [format] Format (xml or html).
     * @param {number} [doc] page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSitemap(
      format?: string,
      doc?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSitemap(
        format,
        doc,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * To know when and how this version of the application was built.
     * @summary Get build details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemInfo(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemInfo(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * XSL transformations may be applied while importing or harvesting records.
     * @summary Get XSL tranformations available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getXslTransformations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getXslTransformations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index
     * @param {boolean} [reset] Drop and recreate index
     * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
     * @param {boolean} [havingXlinkOnly] Records having only XLinks
     * @param {Array<string>} [indices] Index. By default only remove record index.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async index1(
      reset?: boolean,
      asynchronous?: boolean,
      havingXlinkOnly?: boolean,
      indices?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.index1(
        reset,
        asynchronous,
        havingXlinkOnly,
        indices,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index synchronized with database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async indexAndDbSynchronizationStatus(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.indexAndDbSynchronizationStatus(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async indexCommit(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.indexCommit(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async indexStatus(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.indexStatus(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Is CAS enabled?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isCasEnabled(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isCasEnabled(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Is indexing?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isIndexing(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isIndexing(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Is in read-only mode?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isReadOnly(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isReadOnly(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Save settings
     * @param {{ [key: string]: string; }} allRequestParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveSettings(
      allRequestParams: { [key: string]: string },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveSettings(
        allRequestParams,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
     * @summary Set catalog logo
     * @param {string} file Logo to use for the catalog
     * @param {boolean} [asFavicon] Create favicon too
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setLogo(
      file: string,
      asFavicon?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setLogo(
        file,
        asFavicon,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * TODO: Needs doc
     * @summary Update staging profile
     * @param {'testing' | 'development' | 'production'} profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateStagingProfile(
      profile: "testing" | "development" | "production",
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateStagingProfile(profile, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SiteApi - factory interface
 * @export
 */
export const SiteApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SiteApiFp(configuration);
  return {
    /**
     * May be used when indexing task is hanging.
     * @summary Force to commit pending documents in index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitIndexChanges(options?: any): AxiosPromise<void> {
      return localVarFp
        .commitIndexChanges(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get site informations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInformation(options?: any): AxiosPromise<SiteInformation> {
      return localVarFp
        .getInformation(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get last activity
     * @param {number} [lines] Number of lines to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivity(lines?: number, options?: any): AxiosPromise<string> {
      return localVarFp
        .getLastActivity(lines, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get last activity in a ZIP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivityInAZip(options?: any): AxiosPromise<void> {
      return localVarFp
        .getLastActivityInAZip(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get log files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogFiles(options?: any): AxiosPromise<Array<LogFileResponse>> {
      return localVarFp
        .getLogFiles(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary robots.txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotsText(options?: any): AxiosPromise<string> {
      return localVarFp
        .getRobotsText(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Provides also setting properties.
     * @summary Get settings with details
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsDetails(
      set?: Array<
        | "INSPIRE"
        | "CSW"
        | "HARVESTER"
        | "USER_GROUP_ONLY"
        | "AUTH"
        | "READ_ONLY"
        | "INDEX"
        | "SYSTEMINFO"
        | "STAGING_PROFILE"
        | "TYPE"
      >,
      key?: Array<string>,
      options?: any
    ): AxiosPromise<Array<Setting>> {
      return localVarFp
        .getSettingsDetails(set, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return public settings for anonymous users, internals are allowed for authenticated.
     * @summary Get settings
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsSet(
      set?: Array<
        | "INSPIRE"
        | "CSW"
        | "HARVESTER"
        | "USER_GROUP_ONLY"
        | "AUTH"
        | "READ_ONLY"
        | "INDEX"
        | "SYSTEMINFO"
        | "STAGING_PROFILE"
        | "TYPE"
      >,
      key?: Array<string>,
      options?: any
    ): AxiosPromise<SettingsListResponse> {
      return localVarFp
        .getSettingsSet(set, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get site (or portal) description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSiteOrPortalDescription(
      options?: any
    ): AxiosPromise<SettingsListResponse> {
      return localVarFp
        .getSiteOrPortalDescription(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get sitemap
     * @param {string} [format] Format (xml or html).
     * @param {number} [doc] page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemap(
      format?: string,
      doc?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getSitemap(format, doc, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * To know when and how this version of the application was built.
     * @summary Get build details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo(options?: any): AxiosPromise<SystemInfo> {
      return localVarFp
        .getSystemInfo(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * XSL transformations may be applied while importing or harvesting records.
     * @summary Get XSL tranformations available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getXslTransformations(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .getXslTransformations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index
     * @param {boolean} [reset] Drop and recreate index
     * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
     * @param {boolean} [havingXlinkOnly] Records having only XLinks
     * @param {Array<string>} [indices] Index. By default only remove record index.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index1(
      reset?: boolean,
      asynchronous?: boolean,
      havingXlinkOnly?: boolean,
      indices?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .index1(reset, asynchronous, havingXlinkOnly, indices, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index synchronized with database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexAndDbSynchronizationStatus(
      options?: any
    ): AxiosPromise<{ [key: string]: object }> {
      return localVarFp
        .indexAndDbSynchronizationStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexCommit(options?: any): AxiosPromise<void> {
      return localVarFp
        .indexCommit(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexStatus(options?: any): AxiosPromise<Status> {
      return localVarFp
        .indexStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Is CAS enabled?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCasEnabled(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .isCasEnabled(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Is indexing?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isIndexing(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .isIndexing(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Is in read-only mode?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isReadOnly(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .isReadOnly(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Save settings
     * @param {{ [key: string]: string; }} allRequestParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveSettings(
      allRequestParams: { [key: string]: string },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .saveSettings(allRequestParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
     * @summary Set catalog logo
     * @param {string} file Logo to use for the catalog
     * @param {boolean} [asFavicon] Create favicon too
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLogo(
      file: string,
      asFavicon?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .setLogo(file, asFavicon, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * TODO: Needs doc
     * @summary Update staging profile
     * @param {'testing' | 'development' | 'production'} profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStagingProfile(
      profile: "testing" | "development" | "production",
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateStagingProfile(profile, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SiteApi - object-oriented interface
 * @export
 * @class SiteApi
 * @extends {BaseAPI}
 */
export class SiteApi extends BaseAPI {
  /**
   * May be used when indexing task is hanging.
   * @summary Force to commit pending documents in index.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public commitIndexChanges(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .commitIndexChanges(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get site informations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getInformation(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getInformation(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get last activity
   * @param {number} [lines] Number of lines to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getLastActivity(lines?: number, options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getLastActivity(lines, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get last activity in a ZIP
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getLastActivityInAZip(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getLastActivityInAZip(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get log files
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getLogFiles(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getLogFiles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary robots.txt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getRobotsText(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getRobotsText(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Provides also setting properties.
   * @summary Get settings with details
   * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
   * @param {Array<string>} [key] Setting key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSettingsDetails(
    set?: Array<
      | "INSPIRE"
      | "CSW"
      | "HARVESTER"
      | "USER_GROUP_ONLY"
      | "AUTH"
      | "READ_ONLY"
      | "INDEX"
      | "SYSTEMINFO"
      | "STAGING_PROFILE"
      | "TYPE"
    >,
    key?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .getSettingsDetails(set, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return public settings for anonymous users, internals are allowed for authenticated.
   * @summary Get settings
   * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
   * @param {Array<string>} [key] Setting key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSettingsSet(
    set?: Array<
      | "INSPIRE"
      | "CSW"
      | "HARVESTER"
      | "USER_GROUP_ONLY"
      | "AUTH"
      | "READ_ONLY"
      | "INDEX"
      | "SYSTEMINFO"
      | "STAGING_PROFILE"
      | "TYPE"
    >,
    key?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .getSettingsSet(set, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get site (or portal) description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSiteOrPortalDescription(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getSiteOrPortalDescription(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get sitemap
   * @param {string} [format] Format (xml or html).
   * @param {number} [doc] page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSitemap(
    format?: string,
    doc?: number,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .getSitemap(format, doc, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * To know when and how this version of the application was built.
   * @summary Get build details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSystemInfo(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getSystemInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * XSL transformations may be applied while importing or harvesting records.
   * @summary Get XSL tranformations available
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getXslTransformations(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getXslTransformations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index
   * @param {boolean} [reset] Drop and recreate index
   * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
   * @param {boolean} [havingXlinkOnly] Records having only XLinks
   * @param {Array<string>} [indices] Index. By default only remove record index.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public index1(
    reset?: boolean,
    asynchronous?: boolean,
    havingXlinkOnly?: boolean,
    indices?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .index1(reset, asynchronous, havingXlinkOnly, indices, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index synchronized with database
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public indexAndDbSynchronizationStatus(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .indexAndDbSynchronizationStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index commit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public indexCommit(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .indexCommit(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public indexStatus(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .indexStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Is CAS enabled?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public isCasEnabled(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .isCasEnabled(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Is indexing?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public isIndexing(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .isIndexing(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Is in read-only mode?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public isReadOnly(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .isReadOnly(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Save settings
   * @param {{ [key: string]: string; }} allRequestParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public saveSettings(
    allRequestParams: { [key: string]: string },
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .saveSettings(allRequestParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
   * @summary Set catalog logo
   * @param {string} file Logo to use for the catalog
   * @param {boolean} [asFavicon] Create favicon too
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public setLogo(
    file: string,
    asFavicon?: boolean,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .setLogo(file, asFavicon, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * TODO: Needs doc
   * @summary Update staging profile
   * @param {'testing' | 'development' | 'production'} profile
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public updateStagingProfile(
    profile: "testing" | "development" | "production",
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .updateStagingProfile(profile, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
