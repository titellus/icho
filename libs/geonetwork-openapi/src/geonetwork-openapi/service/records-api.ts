/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { BatchEditParameter } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { ExtentDto } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { FeatureResponse } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { IProcessingReport } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { InlineObject2 } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { MetadataCategory } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { MetadataProcessingReport } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { MetadataResource } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { MetadataStatusParameter } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { RelatedResponse } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { Reports } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SavedQuery } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SharingParameter } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SharingResponse } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SimpleMetadataProcessingReport } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { SuggestionType } from "../../..//geonetwork-openapi/model";
/**
 * RecordsApi - axios parameter creator
 * @export
 */
export const RecordsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Reorder element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the element to move.
     * @param {'up' | 'down'} direction Direction
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement: async (
      metadataUuid: string,
      ref: string,
      direction: "up" | "down",
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("addElement", "metadataUuid", metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists("addElement", "ref", ref);
      // verify required parameter 'direction' is not null or undefined
      assertParamExists("addElement", "direction", direction);
      const localVarPath = `/records/{metadataUuid}/editor/elements/{direction}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref !== undefined) {
        localVarQueryParameter["ref"] = ref;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter["displayAttributes"] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the insertion point.
     * @param {string} name Name of the element to add (with prefix)
     * @param {string} [child] Use geonet:attribute for attributes or child name.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement1: async (
      metadataUuid: string,
      ref: string,
      name: string,
      child?: string,
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("addElement1", "metadataUuid", metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists("addElement1", "ref", ref);
      // verify required parameter 'name' is not null or undefined
      assertParamExists("addElement1", "name", name);
      const localVarPath = `/records/{metadataUuid}/editor/elements`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref !== undefined) {
        localVarQueryParameter["ref"] = ref;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (child !== undefined) {
        localVarQueryParameter["child"] = child;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter["displayAttributes"] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
     * @summary Add samples
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSamples: async (
      schema: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("addSamples", "schema", schema);
      const localVarPath = `/records/samples`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (schema) {
        localVarQueryParameter["schema"] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
     * @summary Add templates
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTemplates: async (
      schema: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("addTemplates", "schema", schema);
      const localVarPath = `/records/templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (schema) {
        localVarQueryParameter["schema"] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
     * @summary Apply a saved query for this metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} savedQuery The saved query to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applyQuery: async (
      metadataUuid: string,
      savedQuery: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("applyQuery", "metadataUuid", metadataUuid);
      // verify required parameter 'savedQuery' is not null or undefined
      assertParamExists("applyQuery", "savedQuery", savedQuery);
      const localVarPath = `/records/{metadataUuid}/query/{savedQuery}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"savedQuery"}}`, encodeURIComponent(String(savedQuery)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchEdit: async (
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'batchEditParameter' is not null or undefined
      assertParamExists("batchEdit", "batchEditParameter", batchEditParameter);
      const localVarPath = `/records/batchediting`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (updateDateStamp !== undefined) {
        localVarQueryParameter["updateDateStamp"] = updateDateStamp;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchEditParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel current editing session.
     * @summary Cancel edits
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelEdits: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("cancelEdits", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/editor`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkDoiStatus: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("checkDoiStatus", "metadataUuid", metadataUuid);
      const localVarPath =
        `/records/{metadataUuid}/doi/checkPreConditions`.replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
     * @summary Check the status of validation with the INSPIRE service.
     * @param {string} testId Test identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkValidation: async (
      testId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testId' is not null or undefined
      assertParamExists("checkValidation", "testId", testId);
      const localVarPath = `/records/{testId}/validate/inspire`.replace(
        `{${"testId"}}`,
        encodeURIComponent(String(testId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Clear validation status of one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanValidationStatus: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Close a record task
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {string} closeDate Close date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTask: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      closeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("closeTask", "metadataUuid", metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists("closeTask", "statusId", statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("closeTask", "userId", userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists("closeTask", "changeDate", changeDate);
      // verify required parameter 'closeDate' is not null or undefined
      assertParamExists("closeTask", "closeDate", closeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/close`
          .replace(
            `{${"metadataUuid"}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${"statusId"}}`, encodeURIComponent(String(statusId)))
          .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"changeDate"}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (closeDate !== undefined) {
        localVarQueryParameter["closeDate"] = closeDate;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
     * @summary Create a new record
     * @param {string} sourceUuid UUID of the source record to copy.
     * @param {string} group The group the record is attached to.
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
     * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [hasCategoryOfSource] Copy categories from source?
     * @param {boolean} [isChildOfSource] Is child of the record to copy?
     * @param {boolean} [hasAttachmentsOfSource] Copy attachments from source?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      sourceUuid: string,
      group: string,
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      targetUuid?: string,
      isVisibleByAllGroupMembers?: boolean,
      category?: Array<string>,
      hasCategoryOfSource?: boolean,
      isChildOfSource?: boolean,
      hasAttachmentsOfSource?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sourceUuid' is not null or undefined
      assertParamExists("create", "sourceUuid", sourceUuid);
      // verify required parameter 'group' is not null or undefined
      assertParamExists("create", "group", group);
      const localVarPath = `/records/duplicate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadataType !== undefined) {
        localVarQueryParameter["metadataType"] = metadataType;
      }

      if (sourceUuid !== undefined) {
        localVarQueryParameter["sourceUuid"] = sourceUuid;
      }

      if (targetUuid !== undefined) {
        localVarQueryParameter["targetUuid"] = targetUuid;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (isVisibleByAllGroupMembers !== undefined) {
        localVarQueryParameter["isVisibleByAllGroupMembers"] =
          isVisibleByAllGroupMembers;
      }

      if (category) {
        localVarQueryParameter["category"] = category;
      }

      if (hasCategoryOfSource !== undefined) {
        localVarQueryParameter["hasCategoryOfSource"] = hasCategoryOfSource;
      }

      if (isChildOfSource !== undefined) {
        localVarQueryParameter["isChildOfSource"] = isChildOfSource;
      }

      if (hasAttachmentsOfSource !== undefined) {
        localVarQueryParameter["hasAttachmentsOfSource"] =
          hasAttachmentsOfSource;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit a record to the Datacite metadata store in order to create a DOI.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDoi: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("createDoi", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/doi`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResource: async (
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("delResource", "metadataUuid", metadataUuid);
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists("delResource", "resourceId", resourceId);
      const localVarPath = `/records/{metadataUuid}/attachments/{resourceId}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete all uploaded metadata resources
     * @param {string} metadataUuid The metadata UUID
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResources: async (
      metadataUuid: string,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("delResources", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete all record status
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllRecordStatus: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("deleteAllRecordStatus", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/status`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete attribute
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the attribute to remove.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttribute: async (
      metadataUuid: string,
      ref: string,
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("deleteAttribute", "metadataUuid", metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists("deleteAttribute", "ref", ref);
      const localVarPath = `/records/{metadataUuid}/editor/attributes`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref !== undefined) {
        localVarQueryParameter["ref"] = ref;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter["displayAttributes"] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete element
     * @param {string} metadataUuid Record UUID.
     * @param {Array<string>} ref Reference of the element to remove.
     * @param {string} parent Name of the parent.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteElement: async (
      metadataUuid: string,
      ref: Array<string>,
      parent: string,
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("deleteElement", "metadataUuid", metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists("deleteElement", "ref", ref);
      // verify required parameter 'parent' is not null or undefined
      assertParamExists("deleteElement", "parent", parent);
      const localVarPath = `/records/{metadataUuid}/editor/elements`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref) {
        localVarQueryParameter["ref"] = ref;
      }

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter["displayAttributes"] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
     * @summary Delete a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecord: async (
      metadataUuid: string,
      withBackup?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("deleteRecord", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (withBackup !== undefined) {
        localVarQueryParameter["withBackup"] = withBackup;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a record status
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecordStatus: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("deleteRecordStatus", "metadataUuid", metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists("deleteRecordStatus", "statusId", statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteRecordStatus", "userId", userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists("deleteRecordStatus", "changeDate", changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}`
          .replace(
            `{${"metadataUuid"}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${"statusId"}}`, encodeURIComponent(String(statusId)))
          .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"changeDate"}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to delete it.
     * @summary Delete one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecords: async (
      uuids?: Array<string>,
      bucket?: string,
      withBackup?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (withBackup !== undefined) {
        localVarQueryParameter["withBackup"] = withBackup;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete tags to one or more records
     * @param {Array<number>} id Tag identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTagForRecords: async (
      id: Array<number>,
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteTagForRecords", "id", id);
      const localVarPath = `/records/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (id) {
        localVarQueryParameter["id"] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete tags of a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTags: async (
      metadataUuid: string,
      id?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("deleteTags", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/tags`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter["id"] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Download MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBackup: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/backups/latest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary (Experimental) Enable version control
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControl: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("enableVersionControl", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/versions`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary (Experimental) Enable version control for one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControlForRecords: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/versions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The CSV is a short summary of each records.
     * @summary Get a set of metadata records as CSV
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsCsv: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a set of metadata records as ZIP
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsMef: async (
      uuids?: Array<string>,
      bucket?: string,
      format?: "simple" | "partial" | "full",
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/zip`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (withRelated !== undefined) {
        localVarQueryParameter["withRelated"] = withRelated;
      }

      if (withXLinksResolved !== undefined) {
        localVarQueryParameter["withXLinksResolved"] = withXLinksResolved;
      }

      if (withXLinkAttribute !== undefined) {
        localVarQueryParameter["withXLinkAttribute"] = withXLinkAttribute;
      }

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter["addSchemaLocation"] = addSchemaLocation;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
     * @summary Get a set of metadata records as PDF
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsPdf: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/pdf`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the list of users \"active\" during a time period.
     * @param {string} dateFrom From date of users login date
     * @param {string} dateTo To date of users login date
     * @param {Array<number>} [groups] Group(s) for the users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveUsers: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("getActiveUsers", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("getActiveUsers", "dateTo", dateTo);
      const localVarPath = `/reports/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter["dateFrom"] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter["dateTo"] = dateTo;
      }

      if (groups) {
        localVarQueryParameter["groups"] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get record extents as image
     * @param {string} metadataUuid Record UUID.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsImage: async (
      metadataUuid: string,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        "getAllRecordExtentAsImage",
        "metadataUuid",
        metadataUuid
      );
      const localVarPath = `/records/{metadataUuid}/extents.png`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mapsrs !== undefined) {
        localVarQueryParameter["mapsrs"] = mapsrs;
      }

      if (width !== undefined) {
        localVarQueryParameter["width"] = width;
      }

      if (height !== undefined) {
        localVarQueryParameter["height"] = height;
      }

      if (background !== undefined) {
        localVarQueryParameter["background"] = background;
      }

      if (fillColor !== undefined) {
        localVarQueryParameter["fillColor"] = fillColor;
      }

      if (strokeColor !== undefined) {
        localVarQueryParameter["strokeColor"] = strokeColor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get list of record extents
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsJson: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        "getAllRecordExtentAsJson",
        "metadataUuid",
        metadataUuid
      );
      const localVarPath = `/records/{metadataUuid}/extents.json`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
     * @summary List all metadata attachments
     * @param {string} metadataUuid The metadata UUID
     * @param {'type' | 'name'} [sort] Sort by
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllResources: async (
      metadataUuid: string,
      sort?: "type" | "name",
      approved?: boolean,
      filter?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getAllResources", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * .
     * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
     * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
     * @param {number} [hitsPerPage] Indicates the number of hits per page.
     * @param {string} [any] Search key
     * @param {string} [title] A search key for the title.
     * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
     * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
     * @param {string} [sortOrder] Sort order. Possible values: reverse.
     * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsRdf: async (
      from?: number,
      hitsPerPage?: number,
      any?: string,
      title?: string,
      facetQ?: string,
      sortBy?: string,
      sortOrder?: string,
      similarity?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter["from"] = from;
      }

      if (hitsPerPage !== undefined) {
        localVarQueryParameter["hitsPerPage"] = hitsPerPage;
      }

      if (any !== undefined) {
        localVarQueryParameter["any"] = any;
      }

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      if (facetQ !== undefined) {
        localVarQueryParameter["facet.q"] = facetQ;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sortOrder"] = sortOrder;
      }

      if (similarity !== undefined) {
        localVarQueryParameter["similarity"] = similarity;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources
     * @param {string} metadataUuid Record UUID.
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     * @param {number} [rows] Number of rows returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociatedResources: async (
      metadataUuid: string,
      type?: Array<
        | "children"
        | "parent"
        | "brothersAndSisters"
        | "siblings"
        | "associated"
        | "services"
        | "datasets"
        | "fcats"
        | "hasfeaturecats"
        | "sources"
        | "hassources"
        | "related"
        | "onlines"
        | "thumbnails"
      >,
      start?: number,
      rows?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getAssociatedResources", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/related`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter["type"] = type;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = start;
      }

      if (rows !== undefined) {
        localVarQueryParameter["rows"] = rows;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeatureCatalog: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getFeatureCatalog", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/featureCatalog`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get one record extent as image
     * @param {string} metadataUuid Record UUID.
     * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneRecordExtentAsImage: async (
      metadataUuid: string,
      geometryIndex: number,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        "getOneRecordExtentAsImage",
        "metadataUuid",
        metadataUuid
      );
      // verify required parameter 'geometryIndex' is not null or undefined
      assertParamExists(
        "getOneRecordExtentAsImage",
        "geometryIndex",
        geometryIndex
      );
      const localVarPath = `/records/{metadataUuid}/extents/{geometryIndex}.png`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(
          `{${"geometryIndex"}}`,
          encodeURIComponent(String(geometryIndex))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mapsrs !== undefined) {
        localVarQueryParameter["mapsrs"] = mapsrs;
      }

      if (width !== undefined) {
        localVarQueryParameter["width"] = width;
      }

      if (height !== undefined) {
        localVarQueryParameter["height"] = height;
      }

      if (background !== undefined) {
        localVarQueryParameter["background"] = background;
      }

      if (fillColor !== undefined) {
        localVarQueryParameter["fillColor"] = fillColor;
      }

      if (strokeColor !== undefined) {
        localVarQueryParameter["strokeColor"] = strokeColor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
     * @summary Increase record popularity
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecord", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/popularity`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
     * @summary Get a metadata record
     * @param {string} metadataUuid Record UUID.
     * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord1: async (
      metadataUuid: string,
      accept: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecord1", "metadataUuid", metadataUuid);
      // verify required parameter 'accept' is not null or undefined
      assertParamExists("getRecord1", "accept", accept);
      const localVarPath = `/records/{metadataUuid}`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs: async (
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecordAs", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/xml`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter["addSchemaLocation"] = addSchemaLocation;
      }

      if (increasePopularity !== undefined) {
        localVarQueryParameter["increasePopularity"] = increasePopularity;
      }

      if (withInfo !== undefined) {
        localVarQueryParameter["withInfo"] = withInfo;
      }

      if (attachment !== undefined) {
        localVarQueryParameter["attachment"] = attachment;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs1: async (
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecordAs1", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/json`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter["addSchemaLocation"] = addSchemaLocation;
      }

      if (increasePopularity !== undefined) {
        localVarQueryParameter["increasePopularity"] = increasePopularity;
      }

      if (withInfo !== undefined) {
        localVarQueryParameter["withInfo"] = withInfo;
      }

      if (attachment !== undefined) {
        localVarQueryParameter["attachment"] = attachment;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a metadata record as ZIP
     * @param {string} metadataUuid Record UUID.
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAsZip: async (
      metadataUuid: string,
      format?: "simple" | "partial" | "full",
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecordAsZip", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/zip`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (format !== undefined) {
        localVarQueryParameter["format"] = format;
      }

      if (withRelated !== undefined) {
        localVarQueryParameter["withRelated"] = withRelated;
      }

      if (withXLinksResolved !== undefined) {
        localVarQueryParameter["withXLinksResolved"] = withXLinksResolved;
      }

      if (withXLinkAttribute !== undefined) {
        localVarQueryParameter["withXLinkAttribute"] = withXLinkAttribute;
      }

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter["addSchemaLocation"] = addSchemaLocation;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a formatted metadata record
     * @param {string} formatterId
     * @param {string} metadataUuid Record UUID.
     * @param {string} [accept] Formatter type to use.
     * @param {'_25' | '_50' | '_75' | '_100'} [width]
     * @param {string} [mdpath]
     * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
     * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
     * @param {boolean} [approved] Download the approved version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordFormattedBy: async (
      formatterId: string,
      metadataUuid: string,
      accept?: string,
      width?: "_25" | "_50" | "_75" | "_100",
      mdpath?: string,
      language?: string,
      output?: "txt" | "html" | "xml" | "json" | "jsonld" | "pdf" | "testpdf",
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatterId' is not null or undefined
      assertParamExists("getRecordFormattedBy", "formatterId", formatterId);
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecordFormattedBy", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/{formatterId}`
        .replace(`{${"formatterId"}}`, encodeURIComponent(String(formatterId)))
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (width !== undefined) {
        localVarQueryParameter["width"] = width;
      }

      if (mdpath !== undefined) {
        localVarQueryParameter["mdpath"] = mdpath;
      }

      if (language !== undefined) {
        localVarQueryParameter["language"] = language;
      }

      if (output !== undefined) {
        localVarQueryParameter["output"] = output;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter["Accept"] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return current sharing options for a record.
     * @summary Get record sharing settings
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordSharingSettings: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        "getRecordSharingSettings",
        "metadataUuid",
        metadataUuid
      );
      const localVarPath = `/records/{metadataUuid}/sharing`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record status history
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistory: async (
      metadataUuid: string,
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecordStatusHistory", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/status`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (details !== undefined) {
        localVarQueryParameter["details"] = details;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sortOrder"] = sortOrder;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record status history by type
     * @param {string} metadataUuid Record UUID.
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistoryByType: async (
      metadataUuid: string,
      type: "workflow" | "task" | "event",
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        "getRecordStatusHistoryByType",
        "metadataUuid",
        metadataUuid
      );
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getRecordStatusHistoryByType", "type", type);
      const localVarPath = `/records/{metadataUuid}/status/{type}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"type"}}`, encodeURIComponent(String(type)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (details !== undefined) {
        localVarQueryParameter["details"] = details;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sortOrder"] = sortOrder;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
     * @summary Get record tags
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordTags: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getRecordTags", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/tags`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of metadata file downloads
     * @param {string} dateFrom From date of the metadata downloads
     * @param {string} dateTo To date of the metadata downloads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataDownloads: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("getReportDataDownloads", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("getReportDataDownloads", "dateTo", dateTo);
      const localVarPath = `/reports/datadownloads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter["dateFrom"] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter["dateTo"] = dateTo;
      }

      if (groups) {
        localVarQueryParameter["groups"] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get uploaded files to metadata records during a period.
     * @param {string} dateFrom From date of the metadata uploads
     * @param {string} dateTo To date of the metadata uploads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataUploads: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("getReportDataUploads", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("getReportDataUploads", "dateTo", dateTo);
      const localVarPath = `/reports/datauploads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter["dateFrom"] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter["dateTo"] = dateTo;
      }

      if (groups) {
        localVarQueryParameter["groups"] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the metadata not published during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportInternalMetadata: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("getReportInternalMetadata", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("getReportInternalMetadata", "dateTo", dateTo);
      const localVarPath = `/reports/metadatainternal`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter["dateFrom"] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter["dateTo"] = dateTo;
      }

      if (groups) {
        localVarQueryParameter["groups"] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the updated metadata during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportUpdatedMetadata: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("getReportUpdatedMetadata", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("getReportUpdatedMetadata", "dateTo", dateTo);
      const localVarPath = `/reports/metadataupdated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter["dateFrom"] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter["dateTo"] = dateTo;
      }

      if (groups) {
        localVarQueryParameter["groups"] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {number} [size] Size (only applies to images). From 1px to 2048px.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource: async (
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getResource", "metadataUuid", metadataUuid);
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists("getResource", "resourceId", resourceId);
      const localVarPath = `/records/{metadataUuid}/attachments/{resourceId}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List saved queries for this metadata
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSavedQueries: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getSavedQueries", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/query`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record sharing settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharingSettings: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/sharing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get last workflow status for a record
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getStatus", "metadataUuid", metadataUuid);
      const localVarPath =
        `/records/{metadataUuid}/status/workflow/last`.replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
     * @summary Get suggestions
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSuggestions: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getSuggestions", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/processes`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * TG13, TG2, ...
     * @summary Get test suites available.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuites: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("getTestSuites", "metadataUuid", metadataUuid);
      const localVarPath =
        `/records/{metadataUuid}/validate/inspire/testsuites`.replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search status
     * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
     * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
     * @param {'ASC' | 'DESC'} [sortOrder] Sort Order (ie. DESC or ASC). Default is none.
     * @param {Array<number>} [author] One or more event author. Default is all.
     * @param {Array<number>} [owner] One or more event owners. Default is all.
     * @param {Array<number>} [id] One or more record identifier. Default is all.
     * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
     * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
     * @param {Array<string>} [statusIds] One or more status id. Default is all.
     * @param {string} [dateFrom] Start date
     * @param {string} [dateTo] End date
     * @param {number} [from] From page
     * @param {number} [size] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflowStatusByType: async (
      type?: Array<"workflow" | "task" | "event">,
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      author?: Array<number>,
      owner?: Array<number>,
      id?: Array<number>,
      record?: Array<number>,
      uuid?: Array<string>,
      statusIds?: Array<string>,
      dateFrom?: string,
      dateTo?: string,
      from?: number,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/status/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter["type"] = type;
      }

      if (details !== undefined) {
        localVarQueryParameter["details"] = details;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter["sortOrder"] = sortOrder;
      }

      if (author) {
        localVarQueryParameter["author"] = author;
      }

      if (owner) {
        localVarQueryParameter["owner"] = owner;
      }

      if (id) {
        localVarQueryParameter["id"] = id;
      }

      if (record) {
        localVarQueryParameter["record"] = record;
      }

      if (uuid) {
        localVarQueryParameter["uuid"] = uuid;
      }

      if (statusIds) {
        localVarQueryParameter["statusIds"] = statusIds;
      }

      if (dateFrom !== undefined) {
        localVarQueryParameter["dateFrom"] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter["dateTo"] = dateTo;
      }

      if (from !== undefined) {
        localVarQueryParameter["from"] = from;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Index a set of records provided either by a bucket or a list of uuids
     * @summary Index a set of records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/index`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
     * @summary Add a record
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<string>} [url] URL of a file to download and insert.
     * @param {string} [serverFolder] Server folder where to look for files.
     * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insert: async (
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      url?: Array<string>,
      serverFolder?: string,
      recursiveSearch?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      body?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadataType !== undefined) {
        localVarQueryParameter["metadataType"] = metadataType;
      }

      if (url) {
        localVarQueryParameter["url"] = url;
      }

      if (serverFolder !== undefined) {
        localVarQueryParameter["serverFolder"] = serverFolder;
      }

      if (recursiveSearch !== undefined) {
        localVarQueryParameter["recursiveSearch"] = recursiveSearch;
      }

      if (publishToAll !== undefined) {
        localVarQueryParameter["publishToAll"] = publishToAll;
      }

      if (assignToCatalog !== undefined) {
        localVarQueryParameter["assignToCatalog"] = assignToCatalog;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter["uuidProcessing"] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (category) {
        localVarQueryParameter["category"] = category;
      }

      if (rejectIfInvalid !== undefined) {
        localVarQueryParameter["rejectIfInvalid"] = rejectIfInvalid;
      }

      if (transformWith !== undefined) {
        localVarQueryParameter["transformWith"] = transformWith;
      }

      if (schema !== undefined) {
        localVarQueryParameter["schema"] = schema;
      }

      if (extra !== undefined) {
        localVarQueryParameter["extra"] = extra;
      }

      localVarHeaderParameter["Content-Type"] = "application/xml";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add record in the catalog by uploading files.
     * @summary Add a record from XML or MEF/ZIP file
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<any>} [file] XML or MEF file to upload
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertFile: async (
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      file?: Array<any>,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadataType !== undefined) {
        localVarQueryParameter["metadataType"] = metadataType;
      }

      if (file) {
        localVarQueryParameter["file"] = file;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter["uuidProcessing"] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (category) {
        localVarQueryParameter["category"] = category;
      }

      if (rejectIfInvalid !== undefined) {
        localVarQueryParameter["rejectIfInvalid"] = rejectIfInvalid;
      }

      if (publishToAll !== undefined) {
        localVarQueryParameter["publishToAll"] = publishToAll;
      }

      if (assignToCatalog !== undefined) {
        localVarQueryParameter["assignToCatalog"] = assignToCatalog;
      }

      if (transformWith !== undefined) {
        localVarQueryParameter["transformWith"] = transformWith;
      }

      if (schema !== undefined) {
        localVarQueryParameter["schema"] = schema;
      }

      if (extra !== undefined) {
        localVarQueryParameter["extra"] = extra;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add record in the catalog by uploading a map context.
     * @summary Add a map metadata record from OGC OWS context
     * @param {string} title A map title
     * @param {string} [recordAbstract] A map abstract
     * @param {string} [xml] OGC OWS context as string
     * @param {string} [filename] OGC OWS context file name
     * @param {string} [url] OGC OWS context URL
     * @param {string} [viewerUrl] A map viewer URL to visualize the map
     * @param {string} [overview] Map overview as PNG (base64 encoded)
     * @param {string} [overviewFilename] Map overview filename
     * @param {string} [topic] Topic category
     * @param {boolean} [publishToAll] Publish record.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertOgcMapContextFile: async (
      title: string,
      recordAbstract?: string,
      xml?: string,
      filename?: string,
      url?: string,
      viewerUrl?: string,
      overview?: string,
      overviewFilename?: string,
      topic?: string,
      publishToAll?: boolean,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'title' is not null or undefined
      assertParamExists("insertOgcMapContextFile", "title", title);
      const localVarPath = `/records/importfrommap`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      if (recordAbstract !== undefined) {
        localVarQueryParameter["recordAbstract"] = recordAbstract;
      }

      if (xml !== undefined) {
        localVarQueryParameter["xml"] = xml;
      }

      if (filename !== undefined) {
        localVarQueryParameter["filename"] = filename;
      }

      if (url !== undefined) {
        localVarQueryParameter["url"] = url;
      }

      if (viewerUrl !== undefined) {
        localVarQueryParameter["viewerUrl"] = viewerUrl;
      }

      if (overview !== undefined) {
        localVarQueryParameter["overview"] = overview;
      }

      if (overviewFilename !== undefined) {
        localVarQueryParameter["overviewFilename"] = overviewFilename;
      }

      if (topic !== undefined) {
        localVarQueryParameter["topic"] = topic;
      }

      if (publishToAll !== undefined) {
        localVarQueryParameter["publishToAll"] = publishToAll;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter["uuidProcessing"] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the metadata resource visibility
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {'public' | 'private'} visibility The visibility
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResource: async (
      metadataUuid: string,
      resourceId: string,
      visibility: "public" | "private",
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("patchResource", "metadataUuid", metadataUuid);
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists("patchResource", "resourceId", resourceId);
      // verify required parameter 'visibility' is not null or undefined
      assertParamExists("patchResource", "visibility", visibility);
      const localVarPath = `/records/{metadataUuid}/attachments/{resourceId}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (visibility !== undefined) {
        localVarQueryParameter["visibility"] = visibility;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Preview edits made by XPath expressions.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewBatchEdit: async (
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      diffType?: "patch" | "diff" | "diffhtml",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'batchEditParameter' is not null or undefined
      assertParamExists(
        "previewBatchEdit",
        "batchEditParameter",
        batchEditParameter
      );
      const localVarPath = `/records/batchediting/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (diffType !== undefined) {
        localVarQueryParameter["diffType"] = diffType;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchEditParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecord: async (
      metadataUuid: string,
      process: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("processRecord", "metadataUuid", metadataUuid);
      // verify required parameter 'process' is not null or undefined
      assertParamExists("processRecord", "process", process);
      const localVarPath = `/records/{metadataUuid}/processes/{process}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"process"}}`, encodeURIComponent(String(process)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Preview process result
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecordPreview: async (
      metadataUuid: string,
      process: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("processRecordPreview", "metadataUuid", metadataUuid);
      // verify required parameter 'process' is not null or undefined
      assertParamExists("processRecordPreview", "process", process);
      const localVarPath = `/records/{metadataUuid}/processes/{process}`
        .replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${"process"}}`, encodeURIComponent(String(process)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("publish", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/publish`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * See record sharing for more details.
     * @summary Publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish1: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/publish`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new resource for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResource: async (
      metadataUuid: string,
      visibility?: "public" | "private",
      approved?: boolean,
      inlineObject2?: InlineObject2,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("putResource", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (visibility !== undefined) {
        localVarQueryParameter["visibility"] = visibility;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject2,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new resource from a URL for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} url The URL to load in the store
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResourceFromURL: async (
      metadataUuid: string,
      url: string,
      visibility?: "public" | "private",
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("putResourceFromURL", "metadataUuid", metadataUuid);
      // verify required parameter 'url' is not null or undefined
      assertParamExists("putResourceFromURL", "url", url);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (visibility !== undefined) {
        localVarQueryParameter["visibility"] = visibility;
      }

      if (url !== undefined) {
        localVarQueryParameter["url"] = url;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
     * @summary Rate a record
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rateRecord: async (
      metadataUuid: string,
      body: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("rateRecord", "metadataUuid", metadataUuid);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("rateRecord", "body", body);
      const localVarPath = `/records/{metadataUuid}/rate`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Restore saved content from a status record
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreAtStatusSave: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("restoreAtStatusSave", "metadataUuid", metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists("restoreAtStatusSave", "statusId", statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("restoreAtStatusSave", "userId", userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists("restoreAtStatusSave", "changeDate", changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/restore`
          .replace(
            `{${"metadataUuid"}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${"statusId"}}`, encodeURIComponent(String(statusId)))
          .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"changeDate"}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Save the HTML form content.
     * @summary Save edits
     * @param {string} metadataUuid Record UUID.
     * @param {string} [tab] Tab
     * @param {boolean} [withAttributes]
     * @param {boolean} [withValidationErrors]
     * @param {boolean} [minor]
     * @param {string} [status] Submit for review directly after save.
     * @param {boolean} [commit] Save current edits.
     * @param {boolean} [terminate] Save and terminate session.
     * @param {string} [data] Record as XML. TODO: rename xml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEdits: async (
      metadataUuid: string,
      tab?: string,
      withAttributes?: boolean,
      withValidationErrors?: boolean,
      minor?: boolean,
      status?: string,
      commit?: boolean,
      terminate?: boolean,
      data?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("saveEdits", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/editor`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tab !== undefined) {
        localVarQueryParameter["tab"] = tab;
      }

      if (withAttributes !== undefined) {
        localVarQueryParameter["withAttributes"] = withAttributes;
      }

      if (withValidationErrors !== undefined) {
        localVarQueryParameter["withValidationErrors"] = withValidationErrors;
      }

      if (minor !== undefined) {
        localVarQueryParameter["minor"] = minor;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (commit !== undefined) {
        localVarQueryParameter["commit"] = commit;
      }

      if (terminate !== undefined) {
        localVarQueryParameter["terminate"] = terminate;
      }

      if (data !== undefined) {
        localVarQueryParameter["data"] = data;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
     * @summary Create an overview using the map print module
     * @param {string} metadataUuid Record UUID.
     * @param {string} jsonConfig The mapprint module JSON configuration
     * @param {number} [rotationAngle] The rotation angle of the map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveThumbnail: async (
      metadataUuid: string,
      jsonConfig: string,
      rotationAngle?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("saveThumbnail", "metadataUuid", metadataUuid);
      // verify required parameter 'jsonConfig' is not null or undefined
      assertParamExists("saveThumbnail", "jsonConfig", jsonConfig);
      const localVarPath =
        `/records/{metadataUuid}/attachments/print-thumbnail`.replace(
          `{${"metadataUuid"}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (jsonConfig !== undefined) {
        localVarQueryParameter["jsonConfig"] = jsonConfig;
      }

      if (rotationAngle !== undefined) {
        localVarQueryParameter["rotationAngle"] = rotationAngle;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set group and owner for one or more records
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGroupAndOwner: async (
      groupIdentifier: number,
      userIdentifier: number,
      uuids?: Array<string>,
      bucket?: string,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists("setGroupAndOwner", "groupIdentifier", groupIdentifier);
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("setGroupAndOwner", "userIdentifier", userIdentifier);
      const localVarPath = `/records/ownership`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (groupIdentifier !== undefined) {
        localVarQueryParameter["groupIdentifier"] = groupIdentifier;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (userIdentifier !== undefined) {
        localVarQueryParameter["userIdentifier"] = userIdentifier;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A record is related to one group.
     * @summary Set record group
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordGroup: async (
      metadataUuid: string,
      body: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("setRecordGroup", "metadataUuid", metadataUuid);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("setRecordGroup", "body", body);
      const localVarPath = `/records/{metadataUuid}/group`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set record group and owner
     * @param {string} metadataUuid Record UUID.
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordOwnership: async (
      metadataUuid: string,
      groupIdentifier: number,
      userIdentifier: number,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("setRecordOwnership", "metadataUuid", metadataUuid);
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists(
        "setRecordOwnership",
        "groupIdentifier",
        groupIdentifier
      );
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists("setRecordOwnership", "userIdentifier", userIdentifier);
      const localVarPath = `/records/{metadataUuid}/ownership`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (groupIdentifier !== undefined) {
        localVarQueryParameter["groupIdentifier"] = groupIdentifier;
      }

      if (userIdentifier !== undefined) {
        localVarQueryParameter["userIdentifier"] = userIdentifier;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the record status
     * @param {string} metadataUuid Record UUID.
     * @param {MetadataStatusParameter} metadataStatusParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setStatus: async (
      metadataUuid: string,
      metadataStatusParameter: MetadataStatusParameter,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("setStatus", "metadataUuid", metadataUuid);
      // verify required parameter 'metadataStatusParameter' is not null or undefined
      assertParamExists(
        "setStatus",
        "metadataStatusParameter",
        metadataStatusParameter
      );
      const localVarPath = `/records/{metadataUuid}/status`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        metadataStatusParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * See record sharing for more details.
     * @summary Set sharing settings for one or more records
     * @param {SharingParameter} sharingParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share: async (
      sharingParameter: SharingParameter,
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sharingParameter' is not null or undefined
      assertParamExists("share", "sharingParameter", sharingParameter);
      const localVarPath = `/records/sharing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sharingParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
     * @summary Set record sharing
     * @param {string} metadataUuid Record UUID.
     * @param {SharingParameter} sharingParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share1: async (
      metadataUuid: string,
      sharingParameter: SharingParameter,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("share1", "metadataUuid", metadataUuid);
      // verify required parameter 'sharingParameter' is not null or undefined
      assertParamExists("share1", "sharingParameter", sharingParameter);
      const localVarPath = `/records/{metadataUuid}/sharing`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sharingParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get saved content from the status record after changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusAfter: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("showStatusAfter", "metadataUuid", metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists("showStatusAfter", "statusId", statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("showStatusAfter", "userId", userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists("showStatusAfter", "changeDate", changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/after`
          .replace(
            `{${"metadataUuid"}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${"statusId"}}`, encodeURIComponent(String(statusId)))
          .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"changeDate"}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get saved content from the status record before changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusBefore: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("showStatusBefore", "metadataUuid", metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists("showStatusBefore", "statusId", statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("showStatusBefore", "userId", userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists("showStatusBefore", "changeDate", changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/before`
          .replace(
            `{${"metadataUuid"}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${"statusId"}}`, encodeURIComponent(String(statusId)))
          .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
          .replace(`{${"changeDate"}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return HTML form for editing.
     * @summary Edit a record
     * @param {string} metadataUuid Record UUID.
     * @param {string} [currTab] Tab
     * @param {boolean} [withAttributes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startEditing: async (
      metadataUuid: string,
      currTab?: string,
      withAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("startEditing", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/editor`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (currTab !== undefined) {
        localVarQueryParameter["currTab"] = currTab;
      }

      if (withAttributes !== undefined) {
        localVarQueryParameter["withAttributes"] = withAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add tags to a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} id Tag identifier
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecord: async (
      metadataUuid: string,
      id: Array<number>,
      clear?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("tagRecord", "metadataUuid", metadataUuid);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("tagRecord", "id", id);
      const localVarPath = `/records/{metadataUuid}/tags`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter["id"] = id;
      }

      if (clear !== undefined) {
        localVarQueryParameter["clear"] = clear;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add or remove tags to one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {Array<number>} [id] Tag identifier
     * @param {Array<number>} [removeId] Tag identifier to remove.
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecords: async (
      uuids?: Array<string>,
      bucket?: string,
      id?: Array<number>,
      removeId?: Array<number>,
      clear?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (id) {
        localVarQueryParameter["id"] = id;
      }

      if (removeId) {
        localVarQueryParameter["removeId"] = removeId;
      }

      if (clear !== undefined) {
        localVarQueryParameter["clear"] = clear;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Trigger MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trigger: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/records/backups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * See record sharing for more details.
     * @summary Un-publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/unpublish`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unsets privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish1: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("unpublish1", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/unpublish`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unregisterDoi: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("unregisterDoi", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/doi`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
     * @summary Validate a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecord: async (
      metadataUuid: string,
      isvalid?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists("validateRecord", "metadataUuid", metadataUuid);
      const localVarPath = `/records/{metadataUuid}/validate/internal`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (isvalid !== undefined) {
        localVarQueryParameter["isvalid"] = isvalid;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
     * @summary Submit a record to the INSPIRE service for validation.
     * @param {string} metadataUuid Record UUID.
     * @param {string} testsuite Test suite to run
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordForInspire: async (
      metadataUuid: string,
      testsuite: string,
      mode?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        "validateRecordForInspire",
        "metadataUuid",
        metadataUuid
      );
      // verify required parameter 'testsuite' is not null or undefined
      assertParamExists("validateRecordForInspire", "testsuite", testsuite);
      const localVarPath = `/records/{metadataUuid}/validate/inspire`.replace(
        `{${"metadataUuid"}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (testsuite !== undefined) {
        localVarQueryParameter["testsuite"] = testsuite;
      }

      if (mode !== undefined) {
        localVarQueryParameter["mode"] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecords: async (
      uuids?: Array<string>,
      approved?: boolean,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records in INSPIRE validator
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordsInspire: async (
      uuids?: Array<string>,
      bucket?: string,
      mode?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/validate/inspire`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter["uuids"] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter["bucket"] = bucket;
      }

      if (mode !== undefined) {
        localVarQueryParameter["mode"] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecordsApi - functional programming interface
 * @export
 */
export const RecordsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RecordsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Reorder element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the element to move.
     * @param {'up' | 'down'} direction Direction
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addElement(
      metadataUuid: string,
      ref: string,
      direction: "up" | "down",
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addElement(
        metadataUuid,
        ref,
        direction,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the insertion point.
     * @param {string} name Name of the element to add (with prefix)
     * @param {string} [child] Use geonet:attribute for attributes or child name.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addElement1(
      metadataUuid: string,
      ref: string,
      name: string,
      child?: string,
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addElement1(
        metadataUuid,
        ref,
        name,
        child,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
     * @summary Add samples
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addSamples(
      schema: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addSamples(
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
     * @summary Add templates
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTemplates(
      schema: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplates(
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
     * @summary Apply a saved query for this metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} savedQuery The saved query to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async applyQuery(
      metadataUuid: string,
      savedQuery: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.applyQuery(
        metadataUuid,
        savedQuery,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async batchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<IProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.batchEdit(
        batchEditParameter,
        uuids,
        bucket,
        updateDateStamp,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Cancel current editing session.
     * @summary Cancel edits
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelEdits(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEdits(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkDoiStatus(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: boolean }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkDoiStatus(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
     * @summary Check the status of validation with the INSPIRE service.
     * @param {string} testId Test identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkValidation(
      testId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkValidation(
        testId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Clear validation status of one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cleanValidationStatus(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cleanValidationStatus(
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Close a record task
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {string} closeDate Close date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async closeTask(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      closeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.closeTask(
        metadataUuid,
        statusId,
        userId,
        changeDate,
        closeDate,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
     * @summary Create a new record
     * @param {string} sourceUuid UUID of the source record to copy.
     * @param {string} group The group the record is attached to.
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
     * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [hasCategoryOfSource] Copy categories from source?
     * @param {boolean} [isChildOfSource] Is child of the record to copy?
     * @param {boolean} [hasAttachmentsOfSource] Copy attachments from source?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      sourceUuid: string,
      group: string,
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      targetUuid?: string,
      isVisibleByAllGroupMembers?: boolean,
      category?: Array<string>,
      hasCategoryOfSource?: boolean,
      isChildOfSource?: boolean,
      hasAttachmentsOfSource?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        sourceUuid,
        group,
        metadataType,
        targetUuid,
        isVisibleByAllGroupMembers,
        category,
        hasCategoryOfSource,
        isChildOfSource,
        hasAttachmentsOfSource,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Submit a record to the Datacite metadata store in order to create a DOI.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDoi(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDoi(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.delResource(
        metadataUuid,
        resourceId,
        approved,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete all uploaded metadata resources
     * @param {string} metadataUuid The metadata UUID
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delResources(
      metadataUuid: string,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.delResources(
        metadataUuid,
        approved,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete all record status
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAllRecordStatus(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAllRecordStatus(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete attribute
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the attribute to remove.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAttribute(
      metadataUuid: string,
      ref: string,
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttribute(
        metadataUuid,
        ref,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete element
     * @param {string} metadataUuid Record UUID.
     * @param {Array<string>} ref Reference of the element to remove.
     * @param {string} parent Name of the parent.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteElement(
      metadataUuid: string,
      ref: Array<string>,
      parent: string,
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteElement(
        metadataUuid,
        ref,
        parent,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
     * @summary Delete a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecord(
      metadataUuid: string,
      withBackup?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecord(
        metadataUuid,
        withBackup,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete a record status
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecordStatus(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteRecordStatus(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to delete it.
     * @summary Delete one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecords(
      uuids?: Array<string>,
      bucket?: string,
      withBackup?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecords(
        uuids,
        bucket,
        withBackup,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete tags to one or more records
     * @param {Array<number>} id Tag identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTagForRecords(
      id: Array<number>,
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteTagForRecords(
          id,
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete tags of a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTags(
      metadataUuid: string,
      id?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTags(
        metadataUuid,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Download MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadBackup(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBackup(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary (Experimental) Enable version control
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enableVersionControl(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.enableVersionControl(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary (Experimental) Enable version control for one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enableVersionControlForRecords(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.enableVersionControlForRecords(
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The CSV is a short summary of each records.
     * @summary Get a set of metadata records as CSV
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exportAsCsv(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.exportAsCsv(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a set of metadata records as ZIP
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exportAsMef(
      uuids?: Array<string>,
      bucket?: string,
      format?: "simple" | "partial" | "full",
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.exportAsMef(
        uuids,
        bucket,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
     * @summary Get a set of metadata records as PDF
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exportAsPdf(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.exportAsPdf(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the list of users \"active\" during a time period.
     * @param {string} dateFrom From date of users login date
     * @param {string} dateTo To date of users login date
     * @param {Array<number>} [groups] Group(s) for the users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveUsers(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveUsers(
        dateFrom,
        dateTo,
        groups,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get record extents as image
     * @param {string} metadataUuid Record UUID.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllRecordExtentAsImage(
      metadataUuid: string,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllRecordExtentAsImage(
          metadataUuid,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get list of record extents
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllRecordExtentAsJson(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ExtentDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllRecordExtentAsJson(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
     * @summary List all metadata attachments
     * @param {string} metadataUuid The metadata UUID
     * @param {'type' | 'name'} [sort] Sort by
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllResources(
      metadataUuid: string,
      sort?: "type" | "name",
      approved?: boolean,
      filter?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MetadataResource>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllResources(
        metadataUuid,
        sort,
        approved,
        filter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * .
     * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
     * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
     * @param {number} [hitsPerPage] Indicates the number of hits per page.
     * @param {string} [any] Search key
     * @param {string} [title] A search key for the title.
     * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
     * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
     * @param {string} [sortOrder] Sort order. Possible values: reverse.
     * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAsRdf(
      from?: number,
      hitsPerPage?: number,
      any?: string,
      title?: string,
      facetQ?: string,
      sortBy?: string,
      sortOrder?: string,
      similarity?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAsRdf(
        from,
        hitsPerPage,
        any,
        title,
        facetQ,
        sortBy,
        sortOrder,
        similarity,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources
     * @param {string} metadataUuid Record UUID.
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     * @param {number} [rows] Number of rows returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssociatedResources(
      metadataUuid: string,
      type?: Array<
        | "children"
        | "parent"
        | "brothersAndSisters"
        | "siblings"
        | "associated"
        | "services"
        | "datasets"
        | "fcats"
        | "hasfeaturecats"
        | "sources"
        | "hassources"
        | "related"
        | "onlines"
        | "thumbnails"
      >,
      start?: number,
      rows?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RelatedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAssociatedResources(
          metadataUuid,
          type,
          start,
          rows,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeatureCatalog(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FeatureResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFeatureCatalog(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get one record extent as image
     * @param {string} metadataUuid Record UUID.
     * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOneRecordExtentAsImage(
      metadataUuid: string,
      geometryIndex: number,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOneRecordExtentAsImage(
          metadataUuid,
          geometryIndex,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
     * @summary Increase record popularity
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecord(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
     * @summary Get a metadata record
     * @param {string} metadataUuid Record UUID.
     * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecord1(
      metadataUuid: string,
      accept: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord1(
        metadataUuid,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordAs(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordAs(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordAs1(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordAs1(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a metadata record as ZIP
     * @param {string} metadataUuid Record UUID.
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordAsZip(
      metadataUuid: string,
      format?: "simple" | "partial" | "full",
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordAsZip(
        metadataUuid,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a formatted metadata record
     * @param {string} formatterId
     * @param {string} metadataUuid Record UUID.
     * @param {string} [accept] Formatter type to use.
     * @param {'_25' | '_50' | '_75' | '_100'} [width]
     * @param {string} [mdpath]
     * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
     * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
     * @param {boolean} [approved] Download the approved version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordFormattedBy(
      formatterId: string,
      metadataUuid: string,
      accept?: string,
      width?: "_25" | "_50" | "_75" | "_100",
      mdpath?: string,
      language?: string,
      output?: "txt" | "html" | "xml" | "json" | "jsonld" | "pdf" | "testpdf",
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordFormattedBy(
          formatterId,
          metadataUuid,
          accept,
          width,
          mdpath,
          language,
          output,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return current sharing options for a record.
     * @summary Get record sharing settings
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordSharingSettings(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SharingResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordSharingSettings(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record status history
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordStatusHistory(
      metadataUuid: string,
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordStatusHistory(
          metadataUuid,
          details,
          sortOrder,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record status history by type
     * @param {string} metadataUuid Record UUID.
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordStatusHistoryByType(
      metadataUuid: string,
      type: "workflow" | "task" | "event",
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordStatusHistoryByType(
          metadataUuid,
          type,
          details,
          sortOrder,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
     * @summary Get record tags
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordTags(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<MetadataCategory>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordTags(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of metadata file downloads
     * @param {string} dateFrom From date of the metadata downloads
     * @param {string} dateTo To date of the metadata downloads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportDataDownloads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportDataDownloads(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get uploaded files to metadata records during a period.
     * @param {string} dateFrom From date of the metadata uploads
     * @param {string} dateTo To date of the metadata uploads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportDataUploads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportDataUploads(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the metadata not published during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportInternalMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportInternalMetadata(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the updated metadata during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportUpdatedMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportUpdatedMetadata(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {number} [size] Size (only applies to images). From 1px to 2048px.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(
        metadataUuid,
        resourceId,
        approved,
        size,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List saved queries for this metadata
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSavedQueries(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SavedQuery>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedQueries(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record sharing settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSharingSettings(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SharingResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSharingSettings(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get last workflow status for a record
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
     * @summary Get suggestions
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSuggestions(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SuggestionType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestions(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * TG13, TG2, ...
     * @summary Get test suites available.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTestSuites(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: Array<string> }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTestSuites(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Search status
     * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
     * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
     * @param {'ASC' | 'DESC'} [sortOrder] Sort Order (ie. DESC or ASC). Default is none.
     * @param {Array<number>} [author] One or more event author. Default is all.
     * @param {Array<number>} [owner] One or more event owners. Default is all.
     * @param {Array<number>} [id] One or more record identifier. Default is all.
     * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
     * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
     * @param {Array<string>} [statusIds] One or more status id. Default is all.
     * @param {string} [dateFrom] Start date
     * @param {string} [dateTo] End date
     * @param {number} [from] From page
     * @param {number} [size] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWorkflowStatusByType(
      type?: Array<"workflow" | "task" | "event">,
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      author?: Array<number>,
      owner?: Array<number>,
      id?: Array<number>,
      record?: Array<number>,
      uuid?: Array<string>,
      statusIds?: Array<string>,
      dateFrom?: string,
      dateTo?: string,
      from?: number,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWorkflowStatusByType(
          type,
          details,
          sortOrder,
          author,
          owner,
          id,
          record,
          uuid,
          statusIds,
          dateFrom,
          dateTo,
          from,
          size,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Index a set of records provided either by a bucket or a list of uuids
     * @summary Index a set of records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async index(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.index(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
     * @summary Add a record
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<string>} [url] URL of a file to download and insert.
     * @param {string} [serverFolder] Server folder where to look for files.
     * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async insert(
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      url?: Array<string>,
      serverFolder?: string,
      recursiveSearch?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      body?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.insert(
        metadataType,
        url,
        serverFolder,
        recursiveSearch,
        publishToAll,
        assignToCatalog,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        transformWith,
        schema,
        extra,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add record in the catalog by uploading files.
     * @summary Add a record from XML or MEF/ZIP file
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<any>} [file] XML or MEF file to upload
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async insertFile(
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      file?: Array<any>,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.insertFile(
        metadataType,
        file,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        publishToAll,
        assignToCatalog,
        transformWith,
        schema,
        extra,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add record in the catalog by uploading a map context.
     * @summary Add a map metadata record from OGC OWS context
     * @param {string} title A map title
     * @param {string} [recordAbstract] A map abstract
     * @param {string} [xml] OGC OWS context as string
     * @param {string} [filename] OGC OWS context file name
     * @param {string} [url] OGC OWS context URL
     * @param {string} [viewerUrl] A map viewer URL to visualize the map
     * @param {string} [overview] Map overview as PNG (base64 encoded)
     * @param {string} [overviewFilename] Map overview filename
     * @param {string} [topic] Topic category
     * @param {boolean} [publishToAll] Publish record.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async insertOgcMapContextFile(
      title: string,
      recordAbstract?: string,
      xml?: string,
      filename?: string,
      url?: string,
      viewerUrl?: string,
      overview?: string,
      overviewFilename?: string,
      topic?: string,
      publishToAll?: boolean,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.insertOgcMapContextFile(
          title,
          recordAbstract,
          xml,
          filename,
          url,
          viewerUrl,
          overview,
          overviewFilename,
          topic,
          publishToAll,
          uuidProcessing,
          group,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update the metadata resource visibility
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {'public' | 'private'} visibility The visibility
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchResource(
      metadataUuid: string,
      resourceId: string,
      visibility: "public" | "private",
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchResource(
        metadataUuid,
        resourceId,
        visibility,
        approved,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Preview edits made by XPath expressions.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewBatchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      diffType?: "patch" | "diff" | "diffhtml",
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewBatchEdit(
          batchEditParameter,
          uuids,
          bucket,
          diffType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processRecord(
      metadataUuid: string,
      process: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.processRecord(
        metadataUuid,
        process,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Preview process result
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processRecordPreview(
      metadataUuid: string,
      process: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.processRecordPreview(
          metadataUuid,
          process,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publish(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publish(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * See record sharing for more details.
     * @summary Publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publish1(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publish1(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a new resource for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putResource(
      metadataUuid: string,
      visibility?: "public" | "private",
      approved?: boolean,
      inlineObject2?: InlineObject2,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putResource(
        metadataUuid,
        visibility,
        approved,
        inlineObject2,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a new resource from a URL for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} url The URL to load in the store
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putResourceFromURL(
      metadataUuid: string,
      url: string,
      visibility?: "public" | "private",
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putResourceFromURL(
          metadataUuid,
          url,
          visibility,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
     * @summary Rate a record
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rateRecord(
      metadataUuid: string,
      body: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rateRecord(
        metadataUuid,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Restore saved content from a status record
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restoreAtStatusSave(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.restoreAtStatusSave(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Save the HTML form content.
     * @summary Save edits
     * @param {string} metadataUuid Record UUID.
     * @param {string} [tab] Tab
     * @param {boolean} [withAttributes]
     * @param {boolean} [withValidationErrors]
     * @param {boolean} [minor]
     * @param {string} [status] Submit for review directly after save.
     * @param {boolean} [commit] Save current edits.
     * @param {boolean} [terminate] Save and terminate session.
     * @param {string} [data] Record as XML. TODO: rename xml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveEdits(
      metadataUuid: string,
      tab?: string,
      withAttributes?: boolean,
      withValidationErrors?: boolean,
      minor?: boolean,
      status?: string,
      commit?: boolean,
      terminate?: boolean,
      data?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveEdits(
        metadataUuid,
        tab,
        withAttributes,
        withValidationErrors,
        minor,
        status,
        commit,
        terminate,
        data,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
     * @summary Create an overview using the map print module
     * @param {string} metadataUuid Record UUID.
     * @param {string} jsonConfig The mapprint module JSON configuration
     * @param {number} [rotationAngle] The rotation angle of the map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveThumbnail(
      metadataUuid: string,
      jsonConfig: string,
      rotationAngle?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveThumbnail(
        metadataUuid,
        jsonConfig,
        rotationAngle,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set group and owner for one or more records
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setGroupAndOwner(
      groupIdentifier: number,
      userIdentifier: number,
      uuids?: Array<string>,
      bucket?: string,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setGroupAndOwner(
          groupIdentifier,
          userIdentifier,
          uuids,
          bucket,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A record is related to one group.
     * @summary Set record group
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setRecordGroup(
      metadataUuid: string,
      body: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setRecordGroup(
        metadataUuid,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set record group and owner
     * @param {string} metadataUuid Record UUID.
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setRecordOwnership(
      metadataUuid: string,
      groupIdentifier: number,
      userIdentifier: number,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setRecordOwnership(
          metadataUuid,
          groupIdentifier,
          userIdentifier,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set the record status
     * @param {string} metadataUuid Record UUID.
     * @param {MetadataStatusParameter} metadataStatusParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setStatus(
      metadataUuid: string,
      metadataStatusParameter: MetadataStatusParameter,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setStatus(
        metadataUuid,
        metadataStatusParameter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * See record sharing for more details.
     * @summary Set sharing settings for one or more records
     * @param {SharingParameter} sharingParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async share(
      sharingParameter: SharingParameter,
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.share(
        sharingParameter,
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
     * @summary Set record sharing
     * @param {string} metadataUuid Record UUID.
     * @param {SharingParameter} sharingParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async share1(
      metadataUuid: string,
      sharingParameter: SharingParameter,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.share1(
        metadataUuid,
        sharingParameter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get saved content from the status record after changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showStatusAfter(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showStatusAfter(
        metadataUuid,
        statusId,
        userId,
        changeDate,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get saved content from the status record before changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showStatusBefore(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showStatusBefore(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return HTML form for editing.
     * @summary Edit a record
     * @param {string} metadataUuid Record UUID.
     * @param {string} [currTab] Tab
     * @param {boolean} [withAttributes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startEditing(
      metadataUuid: string,
      currTab?: string,
      withAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startEditing(
        metadataUuid,
        currTab,
        withAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add tags to a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} id Tag identifier
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagRecord(
      metadataUuid: string,
      id: Array<number>,
      clear?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tagRecord(
        metadataUuid,
        id,
        clear,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add or remove tags to one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {Array<number>} [id] Tag identifier
     * @param {Array<number>} [removeId] Tag identifier to remove.
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagRecords(
      uuids?: Array<string>,
      bucket?: string,
      id?: Array<number>,
      removeId?: Array<number>,
      clear?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tagRecords(
        uuids,
        bucket,
        id,
        removeId,
        clear,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Trigger MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trigger(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.trigger(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * See record sharing for more details.
     * @summary Un-publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unpublish(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Unsets privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unpublish1(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish1(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unregisterDoi(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterDoi(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
     * @summary Validate a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecord(
      metadataUuid: string,
      isvalid?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reports>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateRecord(
        metadataUuid,
        isvalid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
     * @summary Submit a record to the INSPIRE service for validation.
     * @param {string} metadataUuid Record UUID.
     * @param {string} testsuite Test suite to run
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecordForInspire(
      metadataUuid: string,
      testsuite: string,
      mode?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateRecordForInspire(
          metadataUuid,
          testsuite,
          mode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecords(
      uuids?: Array<string>,
      approved?: boolean,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateRecords(
        uuids,
        approved,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records in INSPIRE validator
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecordsInspire(
      uuids?: Array<string>,
      bucket?: string,
      mode?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateRecordsInspire(
          uuids,
          bucket,
          mode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RecordsApi - factory interface
 * @export
 */
export const RecordsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RecordsApiFp(configuration);
  return {
    /**
     *
     * @summary Reorder element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the element to move.
     * @param {'up' | 'down'} direction Direction
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement(
      metadataUuid: string,
      ref: string,
      direction: "up" | "down",
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addElement(metadataUuid, ref, direction, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the insertion point.
     * @param {string} name Name of the element to add (with prefix)
     * @param {string} [child] Use geonet:attribute for attributes or child name.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement1(
      metadataUuid: string,
      ref: string,
      name: string,
      child?: string,
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addElement1(metadataUuid, ref, name, child, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
     * @summary Add samples
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSamples(
      schema: Array<string>,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .addSamples(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
     * @summary Add templates
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTemplates(
      schema: Array<string>,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .addTemplates(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
     * @summary Apply a saved query for this metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} savedQuery The saved query to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applyQuery(
      metadataUuid: string,
      savedQuery: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .applyQuery(metadataUuid, savedQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      options?: any
    ): AxiosPromise<IProcessingReport> {
      return localVarFp
        .batchEdit(batchEditParameter, uuids, bucket, updateDateStamp, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Cancel current editing session.
     * @summary Cancel edits
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelEdits(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .cancelEdits(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkDoiStatus(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<{ [key: string]: boolean }> {
      return localVarFp
        .checkDoiStatus(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
     * @summary Check the status of validation with the INSPIRE service.
     * @param {string} testId Test identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkValidation(
      testId: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .checkValidation(testId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Clear validation status of one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanValidationStatus(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .cleanValidationStatus(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Close a record task
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {string} closeDate Close date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTask(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      closeDate: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .closeTask(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          closeDate,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
     * @summary Create a new record
     * @param {string} sourceUuid UUID of the source record to copy.
     * @param {string} group The group the record is attached to.
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
     * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [hasCategoryOfSource] Copy categories from source?
     * @param {boolean} [isChildOfSource] Is child of the record to copy?
     * @param {boolean} [hasAttachmentsOfSource] Copy attachments from source?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      sourceUuid: string,
      group: string,
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      targetUuid?: string,
      isVisibleByAllGroupMembers?: boolean,
      category?: Array<string>,
      hasCategoryOfSource?: boolean,
      isChildOfSource?: boolean,
      hasAttachmentsOfSource?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .create(
          sourceUuid,
          group,
          metadataType,
          targetUuid,
          isVisibleByAllGroupMembers,
          category,
          hasCategoryOfSource,
          isChildOfSource,
          hasAttachmentsOfSource,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Submit a record to the Datacite metadata store in order to create a DOI.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDoi(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .createDoi(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .delResource(metadataUuid, resourceId, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete all uploaded metadata resources
     * @param {string} metadataUuid The metadata UUID
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResources(
      metadataUuid: string,
      approved?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .delResources(metadataUuid, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete all record status
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllRecordStatus(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAllRecordStatus(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete attribute
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the attribute to remove.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttribute(
      metadataUuid: string,
      ref: string,
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAttribute(metadataUuid, ref, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete element
     * @param {string} metadataUuid Record UUID.
     * @param {Array<string>} ref Reference of the element to remove.
     * @param {string} parent Name of the parent.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteElement(
      metadataUuid: string,
      ref: Array<string>,
      parent: string,
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteElement(metadataUuid, ref, parent, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
     * @summary Delete a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecord(
      metadataUuid: string,
      withBackup?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteRecord(metadataUuid, withBackup, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a record status
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecordStatus(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteRecordStatus(metadataUuid, statusId, userId, changeDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to delete it.
     * @summary Delete one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecords(
      uuids?: Array<string>,
      bucket?: string,
      withBackup?: boolean,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .deleteRecords(uuids, bucket, withBackup, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete tags to one or more records
     * @param {Array<number>} id Tag identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTagForRecords(
      id: Array<number>,
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .deleteTagForRecords(id, uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete tags of a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTags(
      metadataUuid: string,
      id?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteTags(metadataUuid, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Download MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBackup(options?: any): AxiosPromise<void> {
      return localVarFp
        .downloadBackup(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary (Experimental) Enable version control
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControl(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .enableVersionControl(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary (Experimental) Enable version control for one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControlForRecords(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .enableVersionControlForRecords(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The CSV is a short summary of each records.
     * @summary Get a set of metadata records as CSV
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsCsv(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .exportAsCsv(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a set of metadata records as ZIP
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsMef(
      uuids?: Array<string>,
      bucket?: string,
      format?: "simple" | "partial" | "full",
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .exportAsMef(
          uuids,
          bucket,
          format,
          withRelated,
          withXLinksResolved,
          withXLinkAttribute,
          addSchemaLocation,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
     * @summary Get a set of metadata records as PDF
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsPdf(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .exportAsPdf(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the list of users \"active\" during a time period.
     * @param {string} dateFrom From date of users login date
     * @param {string} dateTo To date of users login date
     * @param {Array<number>} [groups] Group(s) for the users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveUsers(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getActiveUsers(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get record extents as image
     * @param {string} metadataUuid Record UUID.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsImage(
      metadataUuid: string,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getAllRecordExtentAsImage(
          metadataUuid,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get list of record extents
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsJson(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Array<ExtentDto>> {
      return localVarFp
        .getAllRecordExtentAsJson(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
     * @summary List all metadata attachments
     * @param {string} metadataUuid The metadata UUID
     * @param {'type' | 'name'} [sort] Sort by
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllResources(
      metadataUuid: string,
      sort?: "type" | "name",
      approved?: boolean,
      filter?: string,
      options?: any
    ): AxiosPromise<Array<MetadataResource>> {
      return localVarFp
        .getAllResources(metadataUuid, sort, approved, filter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * .
     * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
     * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
     * @param {number} [hitsPerPage] Indicates the number of hits per page.
     * @param {string} [any] Search key
     * @param {string} [title] A search key for the title.
     * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
     * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
     * @param {string} [sortOrder] Sort order. Possible values: reverse.
     * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsRdf(
      from?: number,
      hitsPerPage?: number,
      any?: string,
      title?: string,
      facetQ?: string,
      sortBy?: string,
      sortOrder?: string,
      similarity?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getAsRdf(
          from,
          hitsPerPage,
          any,
          title,
          facetQ,
          sortBy,
          sortOrder,
          similarity,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources
     * @param {string} metadataUuid Record UUID.
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     * @param {number} [rows] Number of rows returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociatedResources(
      metadataUuid: string,
      type?: Array<
        | "children"
        | "parent"
        | "brothersAndSisters"
        | "siblings"
        | "associated"
        | "services"
        | "datasets"
        | "fcats"
        | "hasfeaturecats"
        | "sources"
        | "hassources"
        | "related"
        | "onlines"
        | "thumbnails"
      >,
      start?: number,
      rows?: number,
      options?: any
    ): AxiosPromise<RelatedResponse> {
      return localVarFp
        .getAssociatedResources(metadataUuid, type, start, rows, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeatureCatalog(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<FeatureResponse> {
      return localVarFp
        .getFeatureCatalog(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get one record extent as image
     * @param {string} metadataUuid Record UUID.
     * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneRecordExtentAsImage(
      metadataUuid: string,
      geometryIndex: number,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getOneRecordExtentAsImage(
          metadataUuid,
          geometryIndex,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
     * @summary Increase record popularity
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getRecord(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
     * @summary Get a metadata record
     * @param {string} metadataUuid Record UUID.
     * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord1(
      metadataUuid: string,
      accept: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getRecord1(metadataUuid, accept, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getRecordAs(
          metadataUuid,
          addSchemaLocation,
          increasePopularity,
          withInfo,
          attachment,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs1(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getRecordAs1(
          metadataUuid,
          addSchemaLocation,
          increasePopularity,
          withInfo,
          attachment,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a metadata record as ZIP
     * @param {string} metadataUuid Record UUID.
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAsZip(
      metadataUuid: string,
      format?: "simple" | "partial" | "full",
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordAsZip(
          metadataUuid,
          format,
          withRelated,
          withXLinksResolved,
          withXLinkAttribute,
          addSchemaLocation,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a formatted metadata record
     * @param {string} formatterId
     * @param {string} metadataUuid Record UUID.
     * @param {string} [accept] Formatter type to use.
     * @param {'_25' | '_50' | '_75' | '_100'} [width]
     * @param {string} [mdpath]
     * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
     * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
     * @param {boolean} [approved] Download the approved version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordFormattedBy(
      formatterId: string,
      metadataUuid: string,
      accept?: string,
      width?: "_25" | "_50" | "_75" | "_100",
      mdpath?: string,
      language?: string,
      output?: "txt" | "html" | "xml" | "json" | "jsonld" | "pdf" | "testpdf",
      approved?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordFormattedBy(
          formatterId,
          metadataUuid,
          accept,
          width,
          mdpath,
          language,
          output,
          approved,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return current sharing options for a record.
     * @summary Get record sharing settings
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordSharingSettings(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<SharingResponse> {
      return localVarFp
        .getRecordSharingSettings(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record status history
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistory(
      metadataUuid: string,
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordStatusHistory(metadataUuid, details, sortOrder, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record status history by type
     * @param {string} metadataUuid Record UUID.
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistoryByType(
      metadataUuid: string,
      type: "workflow" | "task" | "event",
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordStatusHistoryByType(
          metadataUuid,
          type,
          details,
          sortOrder,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
     * @summary Get record tags
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordTags(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Set<MetadataCategory>> {
      return localVarFp
        .getRecordTags(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of metadata file downloads
     * @param {string} dateFrom From date of the metadata downloads
     * @param {string} dateTo To date of the metadata downloads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataDownloads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportDataDownloads(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get uploaded files to metadata records during a period.
     * @param {string} dateFrom From date of the metadata uploads
     * @param {string} dateTo To date of the metadata uploads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataUploads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportDataUploads(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the metadata not published during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportInternalMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportInternalMetadata(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the updated metadata during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportUpdatedMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportUpdatedMetadata(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {number} [size] Size (only applies to images). From 1px to 2048px.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      size?: number,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getResource(metadataUuid, resourceId, approved, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List saved queries for this metadata
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSavedQueries(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Array<SavedQuery>> {
      return localVarFp
        .getSavedQueries(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record sharing settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharingSettings(options?: any): AxiosPromise<SharingResponse> {
      return localVarFp
        .getSharingSettings(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get last workflow status for a record
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getStatus(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
     * @summary Get suggestions
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSuggestions(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Array<SuggestionType>> {
      return localVarFp
        .getSuggestions(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * TG13, TG2, ...
     * @summary Get test suites available.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuites(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp
        .getTestSuites(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search status
     * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
     * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
     * @param {'ASC' | 'DESC'} [sortOrder] Sort Order (ie. DESC or ASC). Default is none.
     * @param {Array<number>} [author] One or more event author. Default is all.
     * @param {Array<number>} [owner] One or more event owners. Default is all.
     * @param {Array<number>} [id] One or more record identifier. Default is all.
     * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
     * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
     * @param {Array<string>} [statusIds] One or more status id. Default is all.
     * @param {string} [dateFrom] Start date
     * @param {string} [dateTo] End date
     * @param {number} [from] From page
     * @param {number} [size] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflowStatusByType(
      type?: Array<"workflow" | "task" | "event">,
      details?: boolean,
      sortOrder?: "ASC" | "DESC",
      author?: Array<number>,
      owner?: Array<number>,
      id?: Array<number>,
      record?: Array<number>,
      uuid?: Array<string>,
      statusIds?: Array<string>,
      dateFrom?: string,
      dateTo?: string,
      from?: number,
      size?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getWorkflowStatusByType(
          type,
          details,
          sortOrder,
          author,
          owner,
          id,
          record,
          uuid,
          statusIds,
          dateFrom,
          dateTo,
          from,
          size,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Index a set of records provided either by a bucket or a list of uuids
     * @summary Index a set of records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<{ [key: string]: object }> {
      return localVarFp
        .index(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
     * @summary Add a record
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<string>} [url] URL of a file to download and insert.
     * @param {string} [serverFolder] Server folder where to look for files.
     * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insert(
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      url?: Array<string>,
      serverFolder?: string,
      recursiveSearch?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      body?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .insert(
          metadataType,
          url,
          serverFolder,
          recursiveSearch,
          publishToAll,
          assignToCatalog,
          uuidProcessing,
          group,
          category,
          rejectIfInvalid,
          transformWith,
          schema,
          extra,
          body,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Add record in the catalog by uploading files.
     * @summary Add a record from XML or MEF/ZIP file
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<any>} [file] XML or MEF file to upload
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertFile(
      metadataType?:
        | "METADATA"
        | "TEMPLATE"
        | "SUB_TEMPLATE"
        | "TEMPLATE_OF_SUB_TEMPLATE",
      file?: Array<any>,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .insertFile(
          metadataType,
          file,
          uuidProcessing,
          group,
          category,
          rejectIfInvalid,
          publishToAll,
          assignToCatalog,
          transformWith,
          schema,
          extra,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Add record in the catalog by uploading a map context.
     * @summary Add a map metadata record from OGC OWS context
     * @param {string} title A map title
     * @param {string} [recordAbstract] A map abstract
     * @param {string} [xml] OGC OWS context as string
     * @param {string} [filename] OGC OWS context file name
     * @param {string} [url] OGC OWS context URL
     * @param {string} [viewerUrl] A map viewer URL to visualize the map
     * @param {string} [overview] Map overview as PNG (base64 encoded)
     * @param {string} [overviewFilename] Map overview filename
     * @param {string} [topic] Topic category
     * @param {boolean} [publishToAll] Publish record.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertOgcMapContextFile(
      title: string,
      recordAbstract?: string,
      xml?: string,
      filename?: string,
      url?: string,
      viewerUrl?: string,
      overview?: string,
      overviewFilename?: string,
      topic?: string,
      publishToAll?: boolean,
      uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
      group?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .insertOgcMapContextFile(
          title,
          recordAbstract,
          xml,
          filename,
          url,
          viewerUrl,
          overview,
          overviewFilename,
          topic,
          publishToAll,
          uuidProcessing,
          group,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the metadata resource visibility
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {'public' | 'private'} visibility The visibility
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResource(
      metadataUuid: string,
      resourceId: string,
      visibility: "public" | "private",
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .patchResource(metadataUuid, resourceId, visibility, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Preview edits made by XPath expressions.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewBatchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      diffType?: "patch" | "diff" | "diffhtml",
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewBatchEdit(batchEditParameter, uuids, bucket, diffType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecord(
      metadataUuid: string,
      process: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .processRecord(metadataUuid, process, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Preview process result
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecordPreview(
      metadataUuid: string,
      process: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .processRecordPreview(metadataUuid, process, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .publish(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * See record sharing for more details.
     * @summary Publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish1(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .publish1(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new resource for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResource(
      metadataUuid: string,
      visibility?: "public" | "private",
      approved?: boolean,
      inlineObject2?: InlineObject2,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .putResource(metadataUuid, visibility, approved, inlineObject2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new resource from a URL for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} url The URL to load in the store
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResourceFromURL(
      metadataUuid: string,
      url: string,
      visibility?: "public" | "private",
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .putResourceFromURL(metadataUuid, url, visibility, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
     * @summary Rate a record
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rateRecord(
      metadataUuid: string,
      body: number,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .rateRecord(metadataUuid, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Restore saved content from a status record
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreAtStatusSave(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .restoreAtStatusSave(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Save the HTML form content.
     * @summary Save edits
     * @param {string} metadataUuid Record UUID.
     * @param {string} [tab] Tab
     * @param {boolean} [withAttributes]
     * @param {boolean} [withValidationErrors]
     * @param {boolean} [minor]
     * @param {string} [status] Submit for review directly after save.
     * @param {boolean} [commit] Save current edits.
     * @param {boolean} [terminate] Save and terminate session.
     * @param {string} [data] Record as XML. TODO: rename xml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEdits(
      metadataUuid: string,
      tab?: string,
      withAttributes?: boolean,
      withValidationErrors?: boolean,
      minor?: boolean,
      status?: string,
      commit?: boolean,
      terminate?: boolean,
      data?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .saveEdits(
          metadataUuid,
          tab,
          withAttributes,
          withValidationErrors,
          minor,
          status,
          commit,
          terminate,
          data,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
     * @summary Create an overview using the map print module
     * @param {string} metadataUuid Record UUID.
     * @param {string} jsonConfig The mapprint module JSON configuration
     * @param {number} [rotationAngle] The rotation angle of the map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveThumbnail(
      metadataUuid: string,
      jsonConfig: string,
      rotationAngle?: number,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .saveThumbnail(metadataUuid, jsonConfig, rotationAngle, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set group and owner for one or more records
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGroupAndOwner(
      groupIdentifier: number,
      userIdentifier: number,
      uuids?: Array<string>,
      bucket?: string,
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .setGroupAndOwner(
          groupIdentifier,
          userIdentifier,
          uuids,
          bucket,
          approved,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A record is related to one group.
     * @summary Set record group
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordGroup(
      metadataUuid: string,
      body: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .setRecordGroup(metadataUuid, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set record group and owner
     * @param {string} metadataUuid Record UUID.
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordOwnership(
      metadataUuid: string,
      groupIdentifier: number,
      userIdentifier: number,
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .setRecordOwnership(
          metadataUuid,
          groupIdentifier,
          userIdentifier,
          approved,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set the record status
     * @param {string} metadataUuid Record UUID.
     * @param {MetadataStatusParameter} metadataStatusParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setStatus(
      metadataUuid: string,
      metadataStatusParameter: MetadataStatusParameter,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .setStatus(metadataUuid, metadataStatusParameter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * See record sharing for more details.
     * @summary Set sharing settings for one or more records
     * @param {SharingParameter} sharingParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share(
      sharingParameter: SharingParameter,
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .share(sharingParameter, uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
     * @summary Set record sharing
     * @param {string} metadataUuid Record UUID.
     * @param {SharingParameter} sharingParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share1(
      metadataUuid: string,
      sharingParameter: SharingParameter,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .share1(metadataUuid, sharingParameter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get saved content from the status record after changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusAfter(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .showStatusAfter(metadataUuid, statusId, userId, changeDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get saved content from the status record before changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusBefore(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .showStatusBefore(metadataUuid, statusId, userId, changeDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return HTML form for editing.
     * @summary Edit a record
     * @param {string} metadataUuid Record UUID.
     * @param {string} [currTab] Tab
     * @param {boolean} [withAttributes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startEditing(
      metadataUuid: string,
      currTab?: string,
      withAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .startEditing(metadataUuid, currTab, withAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add tags to a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} id Tag identifier
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecord(
      metadataUuid: string,
      id: Array<number>,
      clear?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .tagRecord(metadataUuid, id, clear, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add or remove tags to one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {Array<number>} [id] Tag identifier
     * @param {Array<number>} [removeId] Tag identifier to remove.
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecords(
      uuids?: Array<string>,
      bucket?: string,
      id?: Array<number>,
      removeId?: Array<number>,
      clear?: boolean,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .tagRecords(uuids, bucket, id, removeId, clear, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Trigger MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trigger(options?: any): AxiosPromise<string> {
      return localVarFp
        .trigger(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * See record sharing for more details.
     * @summary Un-publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .unpublish(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unsets privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish1(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .unpublish1(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unregisterDoi(metadataUuid: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .unregisterDoi(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
     * @summary Validate a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecord(
      metadataUuid: string,
      isvalid?: boolean,
      options?: any
    ): AxiosPromise<Reports> {
      return localVarFp
        .validateRecord(metadataUuid, isvalid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
     * @summary Submit a record to the INSPIRE service for validation.
     * @param {string} metadataUuid Record UUID.
     * @param {string} testsuite Test suite to run
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordForInspire(
      metadataUuid: string,
      testsuite: string,
      mode?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .validateRecordForInspire(metadataUuid, testsuite, mode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecords(
      uuids?: Array<string>,
      approved?: boolean,
      bucket?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .validateRecords(uuids, approved, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records in INSPIRE validator
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordsInspire(
      uuids?: Array<string>,
      bucket?: string,
      mode?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .validateRecordsInspire(uuids, bucket, mode, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RecordsApi - object-oriented interface
 * @export
 * @class RecordsApi
 * @extends {BaseAPI}
 */
export class RecordsApi extends BaseAPI {
  /**
   *
   * @summary Reorder element
   * @param {string} metadataUuid Record UUID.
   * @param {string} ref Reference of the element to move.
   * @param {'up' | 'down'} direction Direction
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addElement(
    metadataUuid: string,
    ref: string,
    direction: "up" | "down",
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .addElement(metadataUuid, ref, direction, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add element
   * @param {string} metadataUuid Record UUID.
   * @param {string} ref Reference of the insertion point.
   * @param {string} name Name of the element to add (with prefix)
   * @param {string} [child] Use geonet:attribute for attributes or child name.
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addElement1(
    metadataUuid: string,
    ref: string,
    name: string,
    child?: string,
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .addElement1(metadataUuid, ref, name, child, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
   * @summary Add samples
   * @param {Array<string>} schema Schema identifiers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addSamples(schema: Array<string>, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .addSamples(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
   * @summary Add templates
   * @param {Array<string>} schema Schema identifiers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addTemplates(schema: Array<string>, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .addTemplates(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
   * @summary Apply a saved query for this metadata
   * @param {string} metadataUuid The metadata UUID
   * @param {string} savedQuery The saved query to apply
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .applyQuery(metadataUuid, savedQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
   * @param {Array<BatchEditParameter>} batchEditParameter
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public batchEdit(
    batchEditParameter: Array<BatchEditParameter>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .batchEdit(batchEditParameter, uuids, bucket, updateDateStamp, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel current editing session.
   * @summary Cancel edits
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public cancelEdits(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .cancelEdits(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public checkDoiStatus(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .checkDoiStatus(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
   * @summary Check the status of validation with the INSPIRE service.
   * @param {string} testId Test identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public checkValidation(testId: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .checkValidation(testId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Clear validation status of one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .cleanValidationStatus(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Close a record task
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {string} closeDate Close date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public closeTask(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    closeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .closeTask(metadataUuid, statusId, userId, changeDate, closeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
   * @summary Create a new record
   * @param {string} sourceUuid UUID of the source record to copy.
   * @param {string} group The group the record is attached to.
   * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
   * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
   * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
   * @param {Array<string>} [category] Tags to assign to the record.
   * @param {boolean} [hasCategoryOfSource] Copy categories from source?
   * @param {boolean} [isChildOfSource] Is child of the record to copy?
   * @param {boolean} [hasAttachmentsOfSource] Copy attachments from source?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | "METADATA"
      | "TEMPLATE"
      | "SUB_TEMPLATE"
      | "TEMPLATE_OF_SUB_TEMPLATE",
    targetUuid?: string,
    isVisibleByAllGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    hasAttachmentsOfSource?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .create(
        sourceUuid,
        group,
        metadataType,
        targetUuid,
        isVisibleByAllGroupMembers,
        category,
        hasCategoryOfSource,
        isChildOfSource,
        hasAttachmentsOfSource,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Submit a record to the Datacite metadata store in order to create a DOI.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public createDoi(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .createDoi(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a metadata resource
   * @param {string} metadataUuid The metadata UUID
   * @param {string} resourceId The resource identifier (ie. filename)
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public delResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .delResource(metadataUuid, resourceId, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete all uploaded metadata resources
   * @param {string} metadataUuid The metadata UUID
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public delResources(
    metadataUuid: string,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .delResources(metadataUuid, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete all record status
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteAllRecordStatus(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteAllRecordStatus(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete attribute
   * @param {string} metadataUuid Record UUID.
   * @param {string} ref Reference of the attribute to remove.
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteAttribute(metadataUuid, ref, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete element
   * @param {string} metadataUuid Record UUID.
   * @param {Array<string>} ref Reference of the element to remove.
   * @param {string} parent Name of the parent.
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteElement(metadataUuid, ref, parent, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
   * @summary Delete a record
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteRecord(
    metadataUuid: string,
    withBackup?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteRecord(metadataUuid, withBackup, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a record status
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteRecordStatus(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteRecordStatus(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to delete it.
   * @summary Delete one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteRecords(uuids, bucket, withBackup, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete tags to one or more records
   * @param {Array<number>} id Tag identifier
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteTagForRecords(id, uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete tags of a record
   * @param {string} metadataUuid Record UUID.
   * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteTags(metadataUuid, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * @summary Download MEF backup archive
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public downloadBackup(options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .downloadBackup(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary (Experimental) Enable version control
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public enableVersionControl(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .enableVersionControl(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary (Experimental) Enable version control for one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .enableVersionControlForRecords(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The CSV is a short summary of each records.
   * @summary Get a set of metadata records as CSV
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .exportAsCsv(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @summary Get a set of metadata records as ZIP
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
   * @param {boolean} [withRelated] With related records (parent and service).
   * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
   * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
   * @param {boolean} [addSchemaLocation]
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: "simple" | "partial" | "full",
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .exportAsMef(
        uuids,
        bucket,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
   * @summary Get a set of metadata records as PDF
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .exportAsPdf(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the list of users \"active\" during a time period.
   * @param {string} dateFrom From date of users login date
   * @param {string} dateTo To date of users login date
   * @param {Array<number>} [groups] Group(s) for the users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getActiveUsers(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @summary Get record extents as image
   * @param {string} metadataUuid Record UUID.
   * @param {string} [mapsrs]
   * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
   * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
   * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAllRecordExtentAsImage(
    metadataUuid: string,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAllRecordExtentAsImage(
        metadataUuid,
        mapsrs,
        width,
        height,
        background,
        fillColor,
        strokeColor,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @summary Get list of record extents
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAllRecordExtentAsJson(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
   * @summary List all metadata attachments
   * @param {string} metadataUuid The metadata UUID
   * @param {'type' | 'name'} [sort] Sort by
   * @param {boolean} [approved] Use approved version or not
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAllResources(
    metadataUuid: string,
    sort?: "type" | "name",
    approved?: boolean,
    filter?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAllResources(metadataUuid, sort, approved, filter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * .
   * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
   * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
   * @param {number} [hitsPerPage] Indicates the number of hits per page.
   * @param {string} [any] Search key
   * @param {string} [title] A search key for the title.
   * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
   * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
   * @param {string} [sortOrder] Sort order. Possible values: reverse.
   * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAsRdf(
    from?: number,
    hitsPerPage?: number,
    any?: string,
    title?: string,
    facetQ?: string,
    sortBy?: string,
    sortOrder?: string,
    similarity?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAsRdf(
        from,
        hitsPerPage,
        any,
        title,
        facetQ,
        sortBy,
        sortOrder,
        similarity,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
   * @summary Get record related resources
   * @param {string} metadataUuid Record UUID.
   * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
   * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
   * @param {number} [rows] Number of rows returned. Default 100.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | "children"
      | "parent"
      | "brothersAndSisters"
      | "siblings"
      | "associated"
      | "services"
      | "datasets"
      | "fcats"
      | "hasfeaturecats"
      | "sources"
      | "hassources"
      | "related"
      | "onlines"
      | "thumbnails"
    >,
    start?: number,
    rows?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAssociatedResources(metadataUuid, type, start, rows, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
   * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getFeatureCatalog(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getFeatureCatalog(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @summary Get one record extent as image
   * @param {string} metadataUuid Record UUID.
   * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
   * @param {string} [mapsrs]
   * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
   * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
   * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getOneRecordExtentAsImage(
    metadataUuid: string,
    geometryIndex: number,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getOneRecordExtentAsImage(
        metadataUuid,
        geometryIndex,
        mapsrs,
        width,
        height,
        background,
        fillColor,
        strokeColor,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
   * @summary Increase record popularity
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecord(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getRecord(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
   * @summary Get a metadata record
   * @param {string} metadataUuid Record UUID.
   * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecord1(
    metadataUuid: string,
    accept: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecord1(metadataUuid, accept, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a metadata record as XML or JSON
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param {boolean} [increasePopularity] Increase record popularity
   * @param {boolean} [withInfo] Add geonet:info details
   * @param {boolean} [attachment] Download as a file
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordAs(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a metadata record as XML or JSON
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param {boolean} [increasePopularity] Increase record popularity
   * @param {boolean} [withInfo] Add geonet:info details
   * @param {boolean} [attachment] Download as a file
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordAs1(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @summary Get a metadata record as ZIP
   * @param {string} metadataUuid Record UUID.
   * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
   * @param {boolean} [withRelated] With related records (parent and service).
   * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
   * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
   * @param {boolean} [addSchemaLocation]
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordAsZip(
    metadataUuid: string,
    format?: "simple" | "partial" | "full",
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordAsZip(
        metadataUuid,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a formatted metadata record
   * @param {string} formatterId
   * @param {string} metadataUuid Record UUID.
   * @param {string} [accept] Formatter type to use.
   * @param {'_25' | '_50' | '_75' | '_100'} [width]
   * @param {string} [mdpath]
   * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
   * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
   * @param {boolean} [approved] Download the approved version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: "_25" | "_50" | "_75" | "_100",
    mdpath?: string,
    language?: string,
    output?: "txt" | "html" | "xml" | "json" | "jsonld" | "pdf" | "testpdf",
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordFormattedBy(
        formatterId,
        metadataUuid,
        accept,
        width,
        mdpath,
        language,
        output,
        approved,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return current sharing options for a record.
   * @summary Get record sharing settings
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordSharingSettings(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordSharingSettings(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record status history
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [details]
   * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: "ASC" | "DESC",
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordStatusHistory(metadataUuid, details, sortOrder, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record status history by type
   * @param {string} metadataUuid Record UUID.
   * @param {'workflow' | 'task' | 'event'} type Type
   * @param {boolean} [details]
   * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: "workflow" | "task" | "event",
    details?: boolean,
    sortOrder?: "ASC" | "DESC",
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordStatusHistoryByType(
        metadataUuid,
        type,
        details,
        sortOrder,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
   * @summary Get record tags
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordTags(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getRecordTags(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of metadata file downloads
   * @param {string} dateFrom From date of the metadata downloads
   * @param {string} dateTo To date of the metadata downloads
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportDataDownloads(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get uploaded files to metadata records during a period.
   * @param {string} dateFrom From date of the metadata uploads
   * @param {string} dateTo To date of the metadata uploads
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportDataUploads(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the metadata not published during a period.
   * @param {string} dateFrom From date of metadata change date
   * @param {string} dateTo To date of metadata change date
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportInternalMetadata(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the updated metadata during a period.
   * @param {string} dateFrom From date of metadata change date
   * @param {string} dateTo To date of metadata change date
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportUpdatedMetadata(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a metadata resource
   * @param {string} metadataUuid The metadata UUID
   * @param {string} resourceId The resource identifier (ie. filename)
   * @param {boolean} [approved] Use approved version or not
   * @param {number} [size] Size (only applies to images). From 1px to 2048px.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getResource(metadataUuid, resourceId, approved, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List saved queries for this metadata
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getSavedQueries(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getSavedQueries(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record sharing settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getSharingSettings(options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getSharingSettings(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get last workflow status for a record
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getStatus(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getStatus(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
   * @summary Get suggestions
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getSuggestions(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getSuggestions(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * TG13, TG2, ...
   * @summary Get test suites available.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getTestSuites(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getTestSuites(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search status
   * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
   * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
   * @param {'ASC' | 'DESC'} [sortOrder] Sort Order (ie. DESC or ASC). Default is none.
   * @param {Array<number>} [author] One or more event author. Default is all.
   * @param {Array<number>} [owner] One or more event owners. Default is all.
   * @param {Array<number>} [id] One or more record identifier. Default is all.
   * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
   * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
   * @param {Array<string>} [statusIds] One or more status id. Default is all.
   * @param {string} [dateFrom] Start date
   * @param {string} [dateTo] End date
   * @param {number} [from] From page
   * @param {number} [size] Number of records to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getWorkflowStatusByType(
    type?: Array<"workflow" | "task" | "event">,
    details?: boolean,
    sortOrder?: "ASC" | "DESC",
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    record?: Array<number>,
    uuid?: Array<string>,
    statusIds?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getWorkflowStatusByType(
        type,
        details,
        sortOrder,
        author,
        owner,
        id,
        record,
        uuid,
        statusIds,
        dateFrom,
        dateTo,
        from,
        size,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Index a set of records provided either by a bucket or a list of uuids
   * @summary Index a set of records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public index(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .index(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
   * @summary Add a record
   * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
   * @param {Array<string>} [url] URL of a file to download and insert.
   * @param {string} [serverFolder] Server folder where to look for files.
   * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
   * @param {boolean} [publishToAll] (XML file only) Publish record.
   * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {string} [group] The group the record is attached to.
   * @param {Array<string>} [category] Tags to assign to the record.
   * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
   * @param {string} [transformWith] XSL transformation to apply to the record.
   * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param {string} [extra] (experimental) Add extra information to the record.
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public insert(
    metadataType?:
      | "METADATA"
      | "TEMPLATE"
      | "SUB_TEMPLATE"
      | "TEMPLATE_OF_SUB_TEMPLATE",
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    body?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .insert(
        metadataType,
        url,
        serverFolder,
        recursiveSearch,
        publishToAll,
        assignToCatalog,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        transformWith,
        schema,
        extra,
        body,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add record in the catalog by uploading files.
   * @summary Add a record from XML or MEF/ZIP file
   * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
   * @param {Array<any>} [file] XML or MEF file to upload
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {string} [group] The group the record is attached to.
   * @param {Array<string>} [category] Tags to assign to the record.
   * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
   * @param {boolean} [publishToAll] (XML file only) Publish record.
   * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
   * @param {string} [transformWith] XSL transformation to apply to the record.
   * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param {string} [extra] (experimental) Add extra information to the record.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public insertFile(
    metadataType?:
      | "METADATA"
      | "TEMPLATE"
      | "SUB_TEMPLATE"
      | "TEMPLATE_OF_SUB_TEMPLATE",
    file?: Array<any>,
    uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .insertFile(
        metadataType,
        file,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        publishToAll,
        assignToCatalog,
        transformWith,
        schema,
        extra,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add record in the catalog by uploading a map context.
   * @summary Add a map metadata record from OGC OWS context
   * @param {string} title A map title
   * @param {string} [recordAbstract] A map abstract
   * @param {string} [xml] OGC OWS context as string
   * @param {string} [filename] OGC OWS context file name
   * @param {string} [url] OGC OWS context URL
   * @param {string} [viewerUrl] A map viewer URL to visualize the map
   * @param {string} [overview] Map overview as PNG (base64 encoded)
   * @param {string} [overviewFilename] Map overview filename
   * @param {string} [topic] Topic category
   * @param {boolean} [publishToAll] Publish record.
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {string} [group] The group the record is attached to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?: "GENERATEUUID" | "NOTHING" | "OVERWRITE",
    group?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .insertOgcMapContextFile(
        title,
        recordAbstract,
        xml,
        filename,
        url,
        viewerUrl,
        overview,
        overviewFilename,
        topic,
        publishToAll,
        uuidProcessing,
        group,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the metadata resource visibility
   * @param {string} metadataUuid The metadata UUID
   * @param {string} resourceId The resource identifier (ie. filename)
   * @param {'public' | 'private'} visibility The visibility
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: "public" | "private",
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .patchResource(metadataUuid, resourceId, visibility, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Preview edits made by XPath expressions.
   * @param {Array<BatchEditParameter>} batchEditParameter
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public previewBatchEdit(
    batchEditParameter: Array<BatchEditParameter>,
    uuids?: Array<string>,
    bucket?: string,
    diffType?: "patch" | "diff" | "diffhtml",
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .previewBatchEdit(batchEditParameter, uuids, bucket, diffType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Apply a process
   * @param {string} metadataUuid Record UUID.
   * @param {string} process Process identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public processRecord(
    metadataUuid: string,
    process: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .processRecord(metadataUuid, process, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Preview process result
   * @param {string} metadataUuid Record UUID.
   * @param {string} process Process identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .processRecordPreview(metadataUuid, process, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set privileges for ALL group to publish the metadata for all users.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public publish(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .publish(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * See record sharing for more details.
   * @summary Publish one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public publish1(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .publish1(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new resource for a given metadata
   * @param {string} metadataUuid The metadata UUID
   * @param {'public' | 'private'} [visibility] The sharing policy
   * @param {boolean} [approved] Use approved version or not
   * @param {InlineObject2} [inlineObject2]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public putResource(
    metadataUuid: string,
    visibility?: "public" | "private",
    approved?: boolean,
    inlineObject2?: InlineObject2,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .putResource(metadataUuid, visibility, approved, inlineObject2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new resource from a URL for a given metadata
   * @param {string} metadataUuid The metadata UUID
   * @param {string} url The URL to load in the store
   * @param {'public' | 'private'} [visibility] The sharing policy
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: "public" | "private",
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .putResourceFromURL(metadataUuid, url, visibility, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
   * @summary Rate a record
   * @param {string} metadataUuid Record UUID.
   * @param {number} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public rateRecord(
    metadataUuid: string,
    body: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .rateRecord(metadataUuid, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Restore saved content from a status record
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .restoreAtStatusSave(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Save the HTML form content.
   * @summary Save edits
   * @param {string} metadataUuid Record UUID.
   * @param {string} [tab] Tab
   * @param {boolean} [withAttributes]
   * @param {boolean} [withValidationErrors]
   * @param {boolean} [minor]
   * @param {string} [status] Submit for review directly after save.
   * @param {boolean} [commit] Save current edits.
   * @param {boolean} [terminate] Save and terminate session.
   * @param {string} [data] Record as XML. TODO: rename xml
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .saveEdits(
        metadataUuid,
        tab,
        withAttributes,
        withValidationErrors,
        minor,
        status,
        commit,
        terminate,
        data,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
   * @summary Create an overview using the map print module
   * @param {string} metadataUuid Record UUID.
   * @param {string} jsonConfig The mapprint module JSON configuration
   * @param {number} [rotationAngle] The rotation angle of the map
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .saveThumbnail(metadataUuid, jsonConfig, rotationAngle, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set group and owner for one or more records
   * @param {number} groupIdentifier Group identifier
   * @param {number} userIdentifier User identifier
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setGroupAndOwner(
        groupIdentifier,
        userIdentifier,
        uuids,
        bucket,
        approved,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A record is related to one group.
   * @summary Set record group
   * @param {string} metadataUuid Record UUID.
   * @param {number} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setRecordGroup(metadataUuid, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set record group and owner
   * @param {string} metadataUuid Record UUID.
   * @param {number} groupIdentifier Group identifier
   * @param {number} userIdentifier User identifier
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setRecordOwnership(
        metadataUuid,
        groupIdentifier,
        userIdentifier,
        approved,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set the record status
   * @param {string} metadataUuid Record UUID.
   * @param {MetadataStatusParameter} metadataStatusParameter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setStatus(
    metadataUuid: string,
    metadataStatusParameter: MetadataStatusParameter,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setStatus(metadataUuid, metadataStatusParameter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * See record sharing for more details.
   * @summary Set sharing settings for one or more records
   * @param {SharingParameter} sharingParameter
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public share(
    sharingParameter: SharingParameter,
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .share(sharingParameter, uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
   * @summary Set record sharing
   * @param {string} metadataUuid Record UUID.
   * @param {SharingParameter} sharingParameter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public share1(
    metadataUuid: string,
    sharingParameter: SharingParameter,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .share1(metadataUuid, sharingParameter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get saved content from the status record after changes
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .showStatusAfter(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get saved content from the status record before changes
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .showStatusBefore(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return HTML form for editing.
   * @summary Edit a record
   * @param {string} metadataUuid Record UUID.
   * @param {string} [currTab] Tab
   * @param {boolean} [withAttributes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public startEditing(
    metadataUuid: string,
    currTab?: string,
    withAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .startEditing(metadataUuid, currTab, withAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add tags to a record
   * @param {string} metadataUuid Record UUID.
   * @param {Array<number>} id Tag identifier
   * @param {boolean} [clear] Clear all before adding new ones
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .tagRecord(metadataUuid, id, clear, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add or remove tags to one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {Array<number>} [id] Tag identifier
   * @param {Array<number>} [removeId] Tag identifier to remove.
   * @param {boolean} [clear] Clear all before adding new ones
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .tagRecords(uuids, bucket, id, removeId, clear, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * @summary Trigger MEF backup archive
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public trigger(options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .trigger(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * See record sharing for more details.
   * @summary Un-publish one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .unpublish(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unsets privileges for ALL group to publish the metadata for all users.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public unpublish1(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .unpublish1(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public unregisterDoi(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .unregisterDoi(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
   * @summary Validate a record
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecord(metadataUuid, isvalid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
   * @summary Submit a record to the INSPIRE service for validation.
   * @param {string} metadataUuid Record UUID.
   * @param {string} testsuite Test suite to run
   * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecordForInspire(metadataUuid, testsuite, mode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update validation status for all records.
   * @summary Validate one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {boolean} [approved] Use approved version or not
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecords(uuids, approved, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update validation status for all records.
   * @summary Validate one or more records in INSPIRE validator
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecordsInspire(uuids, bucket, mode, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
