/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../../../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../../../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../../../base";
// @ts-ignore
import { BatchEditing } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { Codelist } from "../../..//geonetwork-openapi/model";
// @ts-ignore
import { Element } from "../../..//geonetwork-openapi/model";
/**
 * StandardsApi - axios parameter creator
 * @export
 */
export const StandardsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
     * @summary Get multiple codelist translations
     * @param {string} schema Schema identifier
     * @param {Array<string>} codelist Codelist element name or alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCodelistsTranslations: async (
      schema: string,
      codelist: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("getCodelistsTranslations", "schema", schema);
      // verify required parameter 'codelist' is not null or undefined
      assertParamExists("getCodelistsTranslations", "codelist", codelist);
      const localVarPath = `/standards/{schema}/codelists`.replace(
        `{${"schema"}}`,
        encodeURIComponent(String(schema))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (codelist) {
        localVarQueryParameter["codelist"] = codelist;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get batch editor configuration for a standard
     * @param {string} schema Schema identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration: async (
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("getConfiguration", "schema", schema);
      const localVarPath = `/standards/{schema}/batchconfiguration`.replace(
        `{${"schema"}}`,
        encodeURIComponent(String(schema))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get batch editor configuration for standards
     * @param {Array<string>} [schema] Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigurations: async (
      schema?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/standards/batchconfiguration`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (schema) {
        localVarQueryParameter["schema"] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get editor associated resources panel configuration
     * @param {string} schema Schema identifier
     * @param {string} name Configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEditorAssociatedPanelConfiguration: async (
      schema: string,
      name: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists(
        "getEditorAssociatedPanelConfiguration",
        "schema",
        schema
      );
      // verify required parameter 'name' is not null or undefined
      assertParamExists("getEditorAssociatedPanelConfiguration", "name", name);
      const localVarPath =
        `/standards/{schema}/editor/associatedpanel/config/{name}.json`
          .replace(`{${"schema"}}`, encodeURIComponent(String(schema)))
          .replace(`{${"name"}}`, encodeURIComponent(String(name)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get descriptor details
     * @param {string} schema Schema identifier
     * @param {string} element Descriptor name
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementDetails: async (
      schema: string,
      element: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("getElementDetails", "schema", schema);
      // verify required parameter 'element' is not null or undefined
      assertParamExists("getElementDetails", "element", element);
      const localVarPath = `/standards/{schema}/descriptors/{element}/details`
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)))
        .replace(`{${"element"}}`, encodeURIComponent(String(element)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent;
      }

      if (displayIf !== undefined) {
        localVarQueryParameter["displayIf"] = displayIf;
      }

      if (xpath !== undefined) {
        localVarQueryParameter["xpath"] = xpath;
      }

      if (isoType !== undefined) {
        localVarQueryParameter["isoType"] = isoType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get codelist details
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
     * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
     * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
     * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaCodelistsWithDetails: async (
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("getSchemaCodelistsWithDetails", "schema", schema);
      // verify required parameter 'codelist' is not null or undefined
      assertParamExists("getSchemaCodelistsWithDetails", "codelist", codelist);
      const localVarPath = `/standards/{schema}/codelists/{codelist}/details`
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)))
        .replace(`{${"codelist"}}`, encodeURIComponent(String(codelist)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent;
      }

      if (displayIf !== undefined) {
        localVarQueryParameter["displayIf"] = displayIf;
      }

      if (xpath !== undefined) {
        localVarQueryParameter["xpath"] = xpath;
      }

      if (isoType !== undefined) {
        localVarQueryParameter["isoType"] = isoType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get codelist translations
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaTranslations: async (
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists("getSchemaTranslations", "schema", schema);
      // verify required parameter 'codelist' is not null or undefined
      assertParamExists("getSchemaTranslations", "codelist", codelist);
      const localVarPath = `/standards/{schema}/codelists/{codelist}`
        .replace(`{${"schema"}}`, encodeURIComponent(String(schema)))
        .replace(`{${"codelist"}}`, encodeURIComponent(String(codelist)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent;
      }

      if (displayIf !== undefined) {
        localVarQueryParameter["displayIf"] = displayIf;
      }

      if (xpath !== undefined) {
        localVarQueryParameter["xpath"] = xpath;
      }

      if (isoType !== undefined) {
        localVarQueryParameter["isoType"] = isoType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStandardConfigurations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/standards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reload standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reloadSchema: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/standards/reload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StandardsApi - functional programming interface
 * @export
 */
export const StandardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StandardsApiAxiosParamCreator(configuration);
  return {
    /**
     * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
     * @summary Get multiple codelist translations
     * @param {string} schema Schema identifier
     * @param {Array<string>} codelist Codelist element name or alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCodelistsTranslations(
      schema: string,
      codelist: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCodelistsTranslations(
          schema,
          codelist,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get batch editor configuration for a standard
     * @param {string} schema Schema identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfiguration(
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: BatchEditing }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConfiguration(schema, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get batch editor configuration for standards
     * @param {Array<string>} [schema] Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfigurations(
      schema?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: BatchEditing }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConfigurations(schema, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get editor associated resources panel configuration
     * @param {string} schema Schema identifier
     * @param {string} name Configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEditorAssociatedPanelConfiguration(
      schema: string,
      name: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEditorAssociatedPanelConfiguration(
          schema,
          name,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get descriptor details
     * @param {string} schema Schema identifier
     * @param {string} element Descriptor name
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getElementDetails(
      schema: string,
      element: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Element>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getElementDetails(
          schema,
          element,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get codelist details
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
     * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
     * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
     * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSchemaCodelistsWithDetails(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Codelist>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSchemaCodelistsWithDetails(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get codelist translations
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSchemaTranslations(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSchemaTranslations(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStandardConfigurations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStandardConfigurations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Reload standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reloadSchema(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reloadSchema(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * StandardsApi - factory interface
 * @export
 */
export const StandardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StandardsApiFp(configuration);
  return {
    /**
     * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
     * @summary Get multiple codelist translations
     * @param {string} schema Schema identifier
     * @param {Array<string>} codelist Codelist element name or alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCodelistsTranslations(
      schema: string,
      codelist: Array<string>,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getCodelistsTranslations(schema, codelist, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get batch editor configuration for a standard
     * @param {string} schema Schema identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(
      schema: string,
      options?: any
    ): AxiosPromise<{ [key: string]: BatchEditing }> {
      return localVarFp
        .getConfiguration(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get batch editor configuration for standards
     * @param {Array<string>} [schema] Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigurations(
      schema?: Array<string>,
      options?: any
    ): AxiosPromise<{ [key: string]: BatchEditing }> {
      return localVarFp
        .getConfigurations(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get editor associated resources panel configuration
     * @param {string} schema Schema identifier
     * @param {string} name Configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEditorAssociatedPanelConfiguration(
      schema: string,
      name: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getEditorAssociatedPanelConfiguration(schema, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get descriptor details
     * @param {string} schema Schema identifier
     * @param {string} element Descriptor name
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementDetails(
      schema: string,
      element: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: any
    ): AxiosPromise<Element> {
      return localVarFp
        .getElementDetails(
          schema,
          element,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get codelist details
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
     * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
     * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
     * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaCodelistsWithDetails(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: any
    ): AxiosPromise<Codelist> {
      return localVarFp
        .getSchemaCodelistsWithDetails(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get codelist translations
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaTranslations(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getSchemaTranslations(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStandardConfigurations(options?: any): AxiosPromise<void> {
      return localVarFp
        .getStandardConfigurations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Reload standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reloadSchema(options?: any): AxiosPromise<void> {
      return localVarFp
        .reloadSchema(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StandardsApi - object-oriented interface
 * @export
 * @class StandardsApi
 * @extends {BaseAPI}
 */
export class StandardsApi extends BaseAPI {
  /**
   * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
   * @summary Get multiple codelist translations
   * @param {string} schema Schema identifier
   * @param {Array<string>} codelist Codelist element name or alias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getCodelistsTranslations(
    schema: string,
    codelist: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getCodelistsTranslations(schema, codelist, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get batch editor configuration for a standard
   * @param {string} schema Schema identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getConfiguration(schema: string, options?: AxiosRequestConfig) {
    return StandardsApiFp(this.configuration)
      .getConfiguration(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get batch editor configuration for standards
   * @param {Array<string>} [schema] Schema identifiers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getConfigurations(
    schema?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getConfigurations(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get editor associated resources panel configuration
   * @param {string} schema Schema identifier
   * @param {string} name Configuration identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getEditorAssociatedPanelConfiguration(
    schema: string,
    name: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getEditorAssociatedPanelConfiguration(schema, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get descriptor details
   * @param {string} schema Schema identifier
   * @param {string} element Descriptor name
   * @param {string} [parent]
   * @param {string} [displayIf]
   * @param {string} [xpath]
   * @param {string} [isoType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getElementDetails(
    schema: string,
    element: string,
    parent?: string,
    displayIf?: string,
    xpath?: string,
    isoType?: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getElementDetails(
        schema,
        element,
        parent,
        displayIf,
        xpath,
        isoType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get codelist details
   * @param {string} schema Schema identifier
   * @param {string} codelist Codelist element name or alias
   * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
   * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
   * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
   * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getSchemaCodelistsWithDetails(
    schema: string,
    codelist: string,
    parent?: string,
    displayIf?: string,
    xpath?: string,
    isoType?: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getSchemaCodelistsWithDetails(
        schema,
        codelist,
        parent,
        displayIf,
        xpath,
        isoType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get codelist translations
   * @param {string} schema Schema identifier
   * @param {string} codelist Codelist element name or alias
   * @param {string} [parent]
   * @param {string} [displayIf]
   * @param {string} [xpath]
   * @param {string} [isoType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getSchemaTranslations(
    schema: string,
    codelist: string,
    parent?: string,
    displayIf?: string,
    xpath?: string,
    isoType?: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getSchemaTranslations(
        schema,
        codelist,
        parent,
        displayIf,
        xpath,
        isoType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get standards
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getStandardConfigurations(options?: AxiosRequestConfig) {
    return StandardsApiFp(this.configuration)
      .getStandardConfigurations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Reload standards
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public reloadSchema(options?: AxiosRequestConfig) {
    return StandardsApiFp(this.configuration)
      .reloadSchema(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
