/* tslint:disable */
/* eslint-disable */
/**
 * GeoNetwork 4.0.6 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.6
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, {
  AxiosInstance,
  AxiosPromise,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  RequestArgs,
  RequiredError,
} from './base';

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   *
   * @type {string}
   * @memberof Address
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  zip?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  state?: string;
  /**
   *
   * @type {number}
   * @memberof Address
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  address?: string;
}

/**
 *
 * @export
 * @interface AnonymousMapserver
 */
export interface AnonymousMapserver {
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  configurl?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  wmsurl?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  wfsurl?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  wcsurl?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  stylerurl?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  namespacePrefix?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  pushStyleInWorkspace_JpaWorkaround?: string;
  /**
   *
   * @type {MapServer}
   * @memberof AnonymousMapserver
   */
  pushStyleInWorkspace?: MapServer;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  namespace?: string;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof AnonymousMapserver
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof AnonymousMapserver
   */
  name?: string;
}

/**
 *
 * @export
 * @interface Associated
 */
export interface Associated {
  /**
   *
   * @type {Array<AssociatedSiblingMetadataItem>}
   * @memberof Associated
   */
  item?: Array<AssociatedSiblingMetadataItem>;
}

/**
 *
 * @export
 * @interface AssociatedSiblingMetadataItem
 */
export interface AssociatedSiblingMetadataItem {
  /**
   *
   * @type {string}
   * @memberof AssociatedSiblingMetadataItem
   */
  id?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof AssociatedSiblingMetadataItem
   */
  url?: MultilingualValue;
  /**
   *
   * @type {string}
   * @memberof AssociatedSiblingMetadataItem
   */
  type?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof AssociatedSiblingMetadataItem
   */
  title: MultilingualValue;
  /**
   *
   * @type {Description}
   * @memberof AssociatedSiblingMetadataItem
   */
  description: Description;
  /**
   *
   * @type {Array<string>}
   * @memberof AssociatedSiblingMetadataItem
   */
  mdType: Array<string>;
  /**
   *
   * @type {string}
   * @memberof AssociatedSiblingMetadataItem
   */
  origin?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof AssociatedSiblingMetadataItem
   */
  agg_isTemporalStatOf?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof AssociatedSiblingMetadataItem
   */
  agg_largerWorkCitation?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof AssociatedSiblingMetadataItem
   */
  agg_isDescriptionOf?: Array<string>;
}

/**
 *
 * @export
 * @interface AttributeTable
 */
export interface AttributeTable {
  /**
   *
   * @type {Array<Element>}
   * @memberof AttributeTable
   */
  element?: Array<Element>;
}

/**
 *
 * @export
 * @interface BatchEditParameter
 */
export interface BatchEditParameter {
  /**
   *
   * @type {string}
   * @memberof BatchEditParameter
   */
  xpath: string;
  /**
   *
   * @type {string}
   * @memberof BatchEditParameter
   */
  value: string;
  /**
   *
   * @type {string}
   * @memberof BatchEditParameter
   */
  condition?: string;
}

/**
 *
 * @export
 * @interface BatchEditing
 */
export interface BatchEditing {
  /**
   *
   * @type {Array<Section>}
   * @memberof BatchEditing
   */
  section: Array<Section>;
}

/**
 *
 * @export
 * @interface Category
 */
export interface Category {
  /**
   *
   * @type {string}
   * @memberof Category
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  label?: string;
}

/**
 *
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CategoryResponse
   */
  label?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface Children
 */
export interface Children {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Children
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface Codelist
 */
export interface Codelist {
  /**
   *
   * @type {Array<Entry>}
   * @memberof Codelist
   */
  entry?: Array<Entry>;
  /**
   *
   * @type {string}
   * @memberof Codelist
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Codelist
   */
  alias?: string;
}

/**
 *
 * @export
 * @interface Crs
 */
export interface Crs {
  /**
   *
   * @type {string}
   * @memberof Crs
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof Crs
   */
  authority?: string;
  /**
   *
   * @type {string}
   * @memberof Crs
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof Crs
   */
  codeSpace?: string;
  /**
   *
   * @type {string}
   * @memberof Crs
   */
  description?: string;
}

/**
 *
 * @export
 * @interface Dataset
 */
export interface Dataset {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Dataset
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface Description
 */
export interface Description {
  /**
   *
   * @type {Array<LocalizedString>}
   * @memberof Description
   */
  value?: Array<LocalizedString>;
}

/**
 *
 * @export
 * @interface Element
 */
export interface Element {
  /**
   *
   * @type {string}
   * @memberof Element
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Element
   */
  definition?: string;
  /**
   *
   * @type {string}
   * @memberof Element
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof Element
   */
  link?: string;
  /**
   *
   * @type {string}
   * @memberof Element
   */
  type?: string;
  /**
   *
   * @type {Array<Values>}
   * @memberof Element
   */
  values?: Array<Values>;
}

/**
 *
 * @export
 * @interface Entry
 */
export interface Entry {
  /**
   *
   * @type {string}
   * @memberof Entry
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Entry
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof Entry
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Entry
   */
  hideInEditMode?: string;
}

/**
 *
 * @export
 * @interface ExtentDto
 */
export interface ExtentDto {
  /**
   *
   * @type {string}
   * @memberof ExtentDto
   */
  href?: string;
  /**
   *
   * @type {string}
   * @memberof ExtentDto
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ExtentDto
   */
  xpath?: string;
  /**
   *
   * @type {string}
   * @memberof ExtentDto
   */
  description?: string;
}

/**
 *
 * @export
 * @interface FCRelatedMetadataItem
 */
export interface FCRelatedMetadataItem {
  /**
   *
   * @type {string}
   * @memberof FCRelatedMetadataItem
   */
  id?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof FCRelatedMetadataItem
   */
  url?: MultilingualValue;
  /**
   *
   * @type {string}
   * @memberof FCRelatedMetadataItem
   */
  type?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof FCRelatedMetadataItem
   */
  title: MultilingualValue;
  /**
   *
   * @type {Description}
   * @memberof FCRelatedMetadataItem
   */
  description: Description;
  /**
   *
   * @type {Array<string>}
   * @memberof FCRelatedMetadataItem
   */
  mdType: Array<string>;
  /**
   *
   * @type {string}
   * @memberof FCRelatedMetadataItem
   */
  origin?: string;
  /**
   *
   * @type {FeatureType}
   * @memberof FCRelatedMetadataItem
   */
  featureType: FeatureType;
}

/**
 *
 * @export
 * @interface Fcat
 */
export interface Fcat {
  /**
   *
   * @type {Array<FCRelatedMetadataItem>}
   * @memberof Fcat
   */
  item?: Array<FCRelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface FeatureResponse
 */
export interface FeatureResponse {
  /**
   *
   * @type {{ [key: string]: Array<string>; }}
   * @memberof FeatureResponse
   */
  decodeMap?: { [key: string]: Array<string> };
}

/**
 *
 * @export
 * @interface FeatureType
 */
export interface FeatureType {
  /**
   *
   * @type {AttributeTable}
   * @memberof FeatureType
   */
  attributeTable?: AttributeTable;
}

/**
 *
 * @export
 * @interface Field
 */
export interface Field {
  /**
   *
   * @type {string}
   * @memberof Field
   */
  template?: string;
  /**
   *
   * @type {string}
   * @memberof Field
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Field
   */
  xpath?: string;
  /**
   *
   * @type {string}
   * @memberof Field
   */
  indexField?: string;
  /**
   *
   * @type {string}
   * @memberof Field
   */
  use?: string;
  /**
   *
   * @type {boolean}
   * @memberof Field
   */
  removable?: boolean;
  /**
   *
   * @type {string}
   * @memberof Field
   */
  insertMode?: string;
  /**
   *
   * @type {string}
   * @memberof Field
   */
  codelist?: string;
}

/**
 *
 * @export
 * @interface FormatterData
 */
export interface FormatterData {
  /**
   *
   * @type {string}
   * @memberof FormatterData
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof FormatterData
   */
  id?: string;
}

/**
 *
 * @export
 * @interface FormatterDataResponse
 */
export interface FormatterDataResponse {
  /**
   *
   * @type {Array<FormatterData>}
   * @memberof FormatterDataResponse
   */
  formatters?: Array<FormatterData>;
}

/**
 *
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
  /**
   *
   * @type {string}
   * @memberof GrantedAuthority
   */
  authority?: string;
}

/**
 * Group details
 * @export
 * @interface Group
 */
export interface Group {
  /**
   *
   * @type {string}
   * @memberof Group
   */
  logo?: string;
  /**
   *
   * @type {string}
   * @memberof Group
   */
  website?: string;
  /**
   *
   * @type {MetadataCategory}
   * @memberof Group
   */
  defaultCategory?: MetadataCategory;
  /**
   *
   * @type {Array<MetadataCategory>}
   * @memberof Group
   */
  allowedCategories?: Array<MetadataCategory>;
  /**
   *
   * @type {boolean}
   * @memberof Group
   */
  enableAllowedCategories?: boolean;
  /**
   *
   * @type {number}
   * @memberof Group
   */
  referrer?: number;
  /**
   *
   * @type {boolean}
   * @memberof Group
   */
  reserved?: boolean;
  /**
   *
   * @type {string}
   * @memberof Group
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof Group
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Group
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Group
   */
  name?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Group
   */
  label?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface GroupOperations
 */
export interface GroupOperations {
  /**
   *
   * @type {{ [key: string]: boolean; }}
   * @memberof GroupOperations
   */
  operations?: { [key: string]: boolean };
  /**
   *
   * @type {number}
   * @memberof GroupOperations
   */
  group?: number;
}

/**
 *
 * @export
 * @interface GroupPrivilege
 */
export interface GroupPrivilege {
  /**
   *
   * @type {{ [key: string]: boolean; }}
   * @memberof GroupPrivilege
   */
  operations?: { [key: string]: boolean };
  /**
   *
   * @type {number}
   * @memberof GroupPrivilege
   */
  group?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof GroupPrivilege
   */
  userProfiles?: Array<GroupPrivilegeUserProfilesEnum>;
  /**
   *
   * @type {boolean}
   * @memberof GroupPrivilege
   */
  userGroup?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof GroupPrivilege
   */
  reserved?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof GroupPrivilege
   */
  userProfile?: Array<GroupPrivilegeUserProfileEnum>;
}

/**
 * @export
 * @enum {string}
 */
export enum GroupPrivilegeUserProfilesEnum {
  Administrator = 'Administrator',
  UserAdmin = 'UserAdmin',
  Reviewer = 'Reviewer',
  Editor = 'Editor',
  RegisteredUser = 'RegisteredUser',
  Guest = 'Guest',
  Monitor = 'Monitor',
}

/**
 * @export
 * @enum {string}
 */
export enum GroupPrivilegeUserProfileEnum {
  Administrator = 'Administrator',
  UserAdmin = 'UserAdmin',
  Reviewer = 'Reviewer',
  Editor = 'Editor',
  RegisteredUser = 'RegisteredUser',
  Guest = 'Guest',
  Monitor = 'Monitor',
}

/**
 *
 * @export
 * @interface Hasfeaturecats
 */
export interface Hasfeaturecats {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Hasfeaturecats
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface Hassource
 */
export interface Hassource {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Hassource
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface IProcessingReport
 */
export interface IProcessingReport {
  /**
   *
   * @type {string}
   * @memberof IProcessingReport
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof IProcessingReport
   */
  startIsoDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof IProcessingReport
   */
  endIsoDateTime?: string;
  /**
   *
   * @type {number}
   * @memberof IProcessingReport
   */
  ellapsedTimeInSeconds?: number;
  /**
   *
   * @type {number}
   * @memberof IProcessingReport
   */
  totalTimeInSeconds?: number;
  /**
   *
   * @type {boolean}
   * @memberof IProcessingReport
   */
  running?: boolean;
  /**
   *
   * @type {string}
   * @memberof IProcessingReport
   */
  type?: string;
}

/**
 *
 * @export
 * @interface ISODate
 */
export interface ISODate {
  /**
   *
   * @type {string}
   * @memberof ISODate
   */
  internalDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof ISODate
   */
  dateAndTime?: string;
  /**
   *
   * @type {string}
   * @memberof ISODate
   */
  dateAsString?: string;
  /**
   *
   * @type {number}
   * @memberof ISODate
   */
  timeInSeconds?: number;
  /**
   *
   * @type {boolean}
   * @memberof ISODate
   */
  dateOnly?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ISODate
   */
  dateYearOnly?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ISODate
   */
  dateYearMonthOnly?: boolean;
  /**
   *
   * @type {string}
   * @memberof ISODate
   */
  timeAsString?: string;
  /**
   *
   * @type {number}
   * @memberof ISODate
   */
  months?: number;
  /**
   *
   * @type {number}
   * @memberof ISODate
   */
  hours?: number;
  /**
   *
   * @type {number}
   * @memberof ISODate
   */
  minutes?: number;
  /**
   *
   * @type {number}
   * @memberof ISODate
   */
  seconds?: number;
  /**
   *
   * @type {number}
   * @memberof ISODate
   */
  days?: number;
  /**
   *
   * @type {number}
   * @memberof ISODate
   */
  years?: number;
  /**
   *
   * @type {string}
   * @memberof ISODate
   */
  dateAndTimeUtc?: string;
}

/**
 *
 * @export
 * @interface InfoReport
 */
export interface InfoReport {
  /**
   *
   * @type {string}
   * @memberof InfoReport
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof InfoReport
   */
  uuid?: string;
  /**
   *
   * @type {boolean}
   * @memberof InfoReport
   */
  draft?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof InfoReport
   */
  approved?: boolean;
  /**
   *
   * @type {string}
   * @memberof InfoReport
   */
  date?: string;
}

/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {any}
   * @memberof InlineObject
   */
  data?: any;
}

/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {any}
   * @memberof InlineObject1
   */
  data?: any;
}

/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   * The file to upload
   * @type {any}
   * @memberof InlineObject2
   */
  file: any;
}

/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   * If set, do a file upload.
   * @type {any}
   * @memberof InlineObject4
   */
  file?: any;
}

/**
 *
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
  /**
   * If set, do a file upload.
   * @type {any}
   * @memberof InlineObject5
   */
  file?: any;
}

/**
 *
 * @export
 * @interface IsoLanguage
 */
export interface IsoLanguage {
  /**
   *
   * @type {number}
   * @memberof IsoLanguage
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof IsoLanguage
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof IsoLanguage
   */
  shortCode?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof IsoLanguage
   */
  label?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface Language
 */
export interface Language {
  /**
   *
   * @type {boolean}
   * @memberof Language
   */
  inspire?: boolean;
  /**
   *
   * @type {string}
   * @memberof Language
   */
  inspire_JPAWorkaround?: string;
  /**
   *
   * @type {string}
   * @memberof Language
   */
  defaultLanguage_JPAWorkaround?: string;
  /**
   *
   * @type {boolean}
   * @memberof Language
   */
  defaultLanguage?: boolean;
  /**
   *
   * @type {string}
   * @memberof Language
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Language
   */
  name?: string;
}

/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {Set<MetadataLink>}
   * @memberof Link
   */
  records?: Set<MetadataLink>;
  /**
   *
   * @type {Set<LinkStatus>}
   * @memberof Link
   */
  linkStatus?: Set<LinkStatus>;
  /**
   *
   * @type {number}
   * @memberof Link
   */
  lastState?: number;
  /**
   *
   * @type {ISODate}
   * @memberof Link
   */
  lastCheck?: ISODate;
  /**
   *
   * @type {string}
   * @memberof Link
   */
  linkType?: LinkLinkTypeEnum;
  /**
   *
   * @type {number}
   * @memberof Link
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Link
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof Link
   */
  protocol?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum LinkLinkTypeEnum {
  Http = 'HTTP',
  Metadata = 'METADATA',
}

/**
 *
 * @export
 * @interface LinkStatus
 */
export interface LinkStatus {
  /**
   *
   * @type {number}
   * @memberof LinkStatus
   */
  id?: number;
  /**
   *
   * @type {ISODate}
   * @memberof LinkStatus
   */
  checkDate?: ISODate;
  /**
   *
   * @type {string}
   * @memberof LinkStatus
   */
  statusValue?: string;
  /**
   *
   * @type {string}
   * @memberof LinkStatus
   */
  statusInfo?: string;
  /**
   *
   * @type {string}
   * @memberof LinkStatus
   */
  batchKey?: string;
  /**
   *
   * @type {boolean}
   * @memberof LinkStatus
   */
  failing?: boolean;
}

/**
 *
 * @export
 * @interface ListRegionsResponse
 */
export interface ListRegionsResponse {
  /**
   *
   * @type {Array<RegionResponse>}
   * @memberof ListRegionsResponse
   */
  region?: Array<RegionResponse>;
  /**
   *
   * @type {{ [key: string]: CategoryResponse; }}
   * @memberof ListRegionsResponse
   */
  categories?: { [key: string]: CategoryResponse };
  /**
   *
   * @type {Array<RegionResponse>}
   * @memberof ListRegionsResponse
   */
  regions?: Array<RegionResponse>;
  /**
   *
   * @type {number}
   * @memberof ListRegionsResponse
   */
  count?: number;
}

/**
 *
 * @export
 * @interface LocalizedString
 */
export interface LocalizedString {
  /**
   *
   * @type {string}
   * @memberof LocalizedString
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof LocalizedString
   */
  lang?: string;
  /**
   *
   * @type {string}
   * @memberof LocalizedString
   */
  href?: string;
}

/**
 *
 * @export
 * @interface LogFileResponse
 */
export interface LogFileResponse {
  /**
   *
   * @type {string}
   * @memberof LogFileResponse
   */
  file?: string;
  /**
   *
   * @type {string}
   * @memberof LogFileResponse
   */
  name?: string;
}

/**
 * Mapserver details
 * @export
 * @interface MapServer
 */
export interface MapServer {
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  configurl?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  wmsurl?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  wfsurl?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  wcsurl?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  stylerurl?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  namespacePrefix?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  pushStyleInWorkspace_JpaWorkaround?: string;
  /**
   *
   * @type {MapServer}
   * @memberof MapServer
   */
  pushStyleInWorkspace?: MapServer;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  namespace?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof MapServer
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof MapServer
   */
  name?: string;
}

/**
 *
 * @export
 * @interface MeResponse
 */
export interface MeResponse {
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  profile?: string;
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  surname?: string;
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  hash?: string;
  /**
   *
   * @type {string}
   * @memberof MeResponse
   */
  organisation?: string;
  /**
   *
   * @type {boolean}
   * @memberof MeResponse
   */
  admin?: boolean;
  /**
   *
   * @type {Array<number>}
   * @memberof MeResponse
   */
  groupsWithRegisteredUser?: Array<number>;
  /**
   *
   * @type {Array<number>}
   * @memberof MeResponse
   */
  groupsWithEditor?: Array<number>;
  /**
   *
   * @type {Array<number>}
   * @memberof MeResponse
   */
  groupsWithReviewer?: Array<number>;
  /**
   *
   * @type {Array<number>}
   * @memberof MeResponse
   */
  groupsWithUserAdmin?: Array<number>;
}

/**
 *
 * @export
 * @interface MetadataCategory
 */
export interface MetadataCategory {
  /**
   *
   * @type {number}
   * @memberof MetadataCategory
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof MetadataCategory
   */
  name?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof MetadataCategory
   */
  label?: { [key: string]: string };
}

/**
 * Identifier template details
 * @export
 * @interface MetadataIdentifierTemplate
 */
export interface MetadataIdentifierTemplate {
  /**
   *
   * @type {string}
   * @memberof MetadataIdentifierTemplate
   */
  systemProvided_JPAWorkaround?: string;
  /**
   *
   * @type {boolean}
   * @memberof MetadataIdentifierTemplate
   */
  systemDefault?: boolean;
  /**
   *
   * @type {string}
   * @memberof MetadataIdentifierTemplate
   */
  template?: string;
  /**
   *
   * @type {boolean}
   * @memberof MetadataIdentifierTemplate
   */
  systemProvided?: boolean;
  /**
   *
   * @type {number}
   * @memberof MetadataIdentifierTemplate
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof MetadataIdentifierTemplate
   */
  name?: string;
}

/**
 *
 * @export
 * @interface MetadataLink
 */
export interface MetadataLink {
  /**
   *
   * @type {number}
   * @memberof MetadataLink
   */
  metadataId?: number;
  /**
   *
   * @type {string}
   * @memberof MetadataLink
   */
  metadataUuid?: string;
}

/**
 *
 * @export
 * @interface MetadataProcessingReport
 */
export interface MetadataProcessingReport {
  /**
   *
   * @type {Array<Report>}
   * @memberof MetadataProcessingReport
   */
  errors?: Array<Report>;
  /**
   *
   * @type {Array<InfoReport>}
   * @memberof MetadataProcessingReport
   */
  infos?: Array<InfoReport>;
  /**
   *
   * @type {string}
   * @memberof MetadataProcessingReport
   */
  uuid?: string;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  totalRecords?: number;
  /**
   *
   * @type {Set<number>}
   * @memberof MetadataProcessingReport
   */
  metadata?: Set<number>;
  /**
   *
   * @type {{ [key: string]: Array<Report>; }}
   * @memberof MetadataProcessingReport
   */
  metadataErrors?: { [key: string]: Array<Report> };
  /**
   *
   * @type {{ [key: string]: Array<InfoReport>; }}
   * @memberof MetadataProcessingReport
   */
  metadataInfos?: { [key: string]: Array<InfoReport> };
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  numberOfNullRecords?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  numberOfRecordsProcessed?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  numberOfRecordsWithErrors?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  numberOfRecords?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  numberOfRecordNotFound?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  numberOfRecordsNotEditable?: number;
  /**
   *
   * @type {string}
   * @memberof MetadataProcessingReport
   */
  startIsoDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataProcessingReport
   */
  endIsoDateTime?: string;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  ellapsedTimeInSeconds?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataProcessingReport
   */
  totalTimeInSeconds?: number;
  /**
   *
   * @type {boolean}
   * @memberof MetadataProcessingReport
   */
  running?: boolean;
  /**
   *
   * @type {string}
   * @memberof MetadataProcessingReport
   */
  type?: string;
}

/**
 *
 * @export
 * @interface MetadataReplacementProcessingReport
 */
export interface MetadataReplacementProcessingReport {
  /**
   *
   * @type {Array<Report>}
   * @memberof MetadataReplacementProcessingReport
   */
  errors?: Array<Report>;
  /**
   *
   * @type {Array<InfoReport>}
   * @memberof MetadataReplacementProcessingReport
   */
  infos?: Array<InfoReport>;
  /**
   *
   * @type {string}
   * @memberof MetadataReplacementProcessingReport
   */
  uuid?: string;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  totalRecords?: number;
  /**
   *
   * @type {Set<number>}
   * @memberof MetadataReplacementProcessingReport
   */
  metadata?: Set<number>;
  /**
   *
   * @type {{ [key: string]: Array<Report>; }}
   * @memberof MetadataReplacementProcessingReport
   */
  metadataErrors?: { [key: string]: Array<Report> };
  /**
   *
   * @type {{ [key: string]: Array<InfoReport>; }}
   * @memberof MetadataReplacementProcessingReport
   */
  metadataInfos?: { [key: string]: Array<InfoReport> };
  /**
   *
   * @type {string}
   * @memberof MetadataReplacementProcessingReport
   */
  processId?: string;
  /**
   *
   * @type {{ [key: string]: ReplaceReport; }}
   * @memberof MetadataReplacementProcessingReport
   */
  metadataChanges?: { [key: string]: ReplaceReport };
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfRecordsChanged?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfRecordsNotChanged?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  noProcessFoundCount?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfNullRecords?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfRecordsProcessed?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfRecordsWithErrors?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfRecords?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfRecordNotFound?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  numberOfRecordsNotEditable?: number;
  /**
   *
   * @type {string}
   * @memberof MetadataReplacementProcessingReport
   */
  startIsoDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataReplacementProcessingReport
   */
  endIsoDateTime?: string;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  ellapsedTimeInSeconds?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataReplacementProcessingReport
   */
  totalTimeInSeconds?: number;
  /**
   *
   * @type {boolean}
   * @memberof MetadataReplacementProcessingReport
   */
  running?: boolean;
  /**
   *
   * @type {string}
   * @memberof MetadataReplacementProcessingReport
   */
  type?: string;
}

/**
 *
 * @export
 * @interface MetadataResource
 */
export interface MetadataResource {
  /**
   *
   * @type {number}
   * @memberof MetadataResource
   */
  metadataId?: number;
  /**
   *
   * @type {string}
   * @memberof MetadataResource
   */
  metadataUuid?: string;
  /**
   *
   * @type {boolean}
   * @memberof MetadataResource
   */
  approved?: boolean;
  /**
   *
   * @type {string}
   * @memberof MetadataResource
   */
  visibility?: MetadataResourceVisibilityEnum;
  /**
   *
   * @type {string}
   * @memberof MetadataResource
   */
  lastModification?: string;
  /**
   *
   * @type {MetadataResourceExternalManagementProperties}
   * @memberof MetadataResource
   */
  metadataResourceExternalManagementProperties?: MetadataResourceExternalManagementProperties;
  /**
   *
   * @type {string}
   * @memberof MetadataResource
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataResource
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataResource
   */
  filename?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataResource
   */
  id?: string;
  /**
   *
   * @type {number}
   * @memberof MetadataResource
   */
  size?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum MetadataResourceVisibilityEnum {
  Public = 'public',
  Private = 'private',
}

/**
 *
 * @export
 * @interface MetadataResourceExternalManagementProperties
 */
export interface MetadataResourceExternalManagementProperties {
  /**
   *
   * @type {string}
   * @memberof MetadataResourceExternalManagementProperties
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataResourceExternalManagementProperties
   */
  url?: string;
}

/**
 * Metadata status
 * @export
 * @interface MetadataStatusParameter
 */
export interface MetadataStatusParameter {
  /**
   *
   * @type {string}
   * @memberof MetadataStatusParameter
   */
  type?: MetadataStatusParameterTypeEnum;
  /**
   *
   * @type {number}
   * @memberof MetadataStatusParameter
   */
  status?: number;
  /**
   *
   * @type {string}
   * @memberof MetadataStatusParameter
   */
  changeMessage?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataStatusParameter
   */
  dueDate?: string;
  /**
   *
   * @type {string}
   * @memberof MetadataStatusParameter
   */
  closeDate?: string;
  /**
   *
   * @type {number}
   * @memberof MetadataStatusParameter
   */
  owner?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum MetadataStatusParameterTypeEnum {
  Workflow = 'workflow',
  Task = 'task',
  Event = 'event',
}

/**
 *
 * @export
 * @interface MultilingualValue
 */
export interface MultilingualValue {
  /**
   *
   * @type {Array<LocalizedString>}
   * @memberof MultilingualValue
   */
  value?: Array<LocalizedString>;
}

/**
 *
 * @export
 * @interface Online
 */
export interface Online {
  /**
   *
   * @type {Array<RelatedLinkItem>}
   * @memberof Online
   */
  item?: Array<RelatedLinkItem>;
}

/**
 *
 * @export
 * @interface Operation
 */
export interface Operation {
  /**
   *
   * @type {boolean}
   * @memberof Operation
   */
  reserved?: boolean;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  reservedOperation?: OperationReservedOperationEnum;
  /**
   *
   * @type {number}
   * @memberof Operation
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  name?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Operation
   */
  label?: { [key: string]: string };
}

/**
 * @export
 * @enum {string}
 */
export enum OperationReservedOperationEnum {
  View = 'view',
  Download = 'download',
  Editing = 'editing',
  Notify = 'notify',
  Dynamic = 'dynamic',
  Featured = 'featured',
}

/**
 *
 * @export
 * @interface OwnerResponse
 */
export interface OwnerResponse {
  /**
   *
   * @type {number}
   * @memberof OwnerResponse
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof OwnerResponse
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof OwnerResponse
   */
  records?: number;
}

/**
 *
 * @export
 * @interface PageJSONWrapper
 */
export interface PageJSONWrapper {
  /**
   *
   * @type {string}
   * @memberof PageJSONWrapper
   */
  format?: PageJSONWrapperFormatEnum;
  /**
   *
   * @type {string}
   * @memberof PageJSONWrapper
   */
  status?: PageJSONWrapperStatusEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof PageJSONWrapper
   */
  sections?: Array<PageJSONWrapperSectionsEnum>;
  /**
   *
   * @type {string}
   * @memberof PageJSONWrapper
   */
  linkText?: string;
  /**
   *
   * @type {string}
   * @memberof PageJSONWrapper
   */
  link?: string;
  /**
   *
   * @type {string}
   * @memberof PageJSONWrapper
   */
  language?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum PageJSONWrapperFormatEnum {
  Link = 'LINK',
  Html = 'HTML',
  Text = 'TEXT',
  Markdown = 'MARKDOWN',
  Wiki = 'WIKI',
}

/**
 * @export
 * @enum {string}
 */
export enum PageJSONWrapperStatusEnum {
  Public = 'PUBLIC',
  PublicOnly = 'PUBLIC_ONLY',
  Private = 'PRIVATE',
  Hidden = 'HIDDEN',
}

/**
 * @export
 * @enum {string}
 */
export enum PageJSONWrapperSectionsEnum {
  All = 'ALL',
  Top = 'TOP',
  Footer = 'FOOTER',
  Menu = 'MENU',
  Submenu = 'SUBMENU',
  CustomMenu1 = 'CUSTOM_MENU1',
  CustomMenu2 = 'CUSTOM_MENU2',
  CustomMenu3 = 'CUSTOM_MENU3',
  Draft = 'DRAFT',
}

/**
 *
 * @export
 * @interface PageLink
 */
export interface PageLink {
  /**
   *
   * @type {number}
   * @memberof PageLink
   */
  totalPages?: number;
  /**
   *
   * @type {number}
   * @memberof PageLink
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageLink
   */
  numberOfElements?: number;
  /**
   *
   * @type {Pageable}
   * @memberof PageLink
   */
  pageable?: Pageable;
  /**
   *
   * @type {Sort}
   * @memberof PageLink
   */
  sort?: Sort;
  /**
   *
   * @type {boolean}
   * @memberof PageLink
   */
  first?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PageLink
   */
  last?: boolean;
  /**
   *
   * @type {number}
   * @memberof PageLink
   */
  size?: number;
  /**
   *
   * @type {Array<Link>}
   * @memberof PageLink
   */
  content?: Array<Link>;
  /**
   *
   * @type {number}
   * @memberof PageLink
   */
  number?: number;
  /**
   *
   * @type {boolean}
   * @memberof PageLink
   */
  empty?: boolean;
}

/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
  /**
   *
   * @type {boolean}
   * @memberof Pageable
   */
  unpaged?: boolean;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  pageNumber?: number;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  pageSize?: number;
  /**
   *
   * @type {boolean}
   * @memberof Pageable
   */
  paged?: boolean;
  /**
   *
   * @type {Sort}
   * @memberof Pageable
   */
  sort?: Sort;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  offset?: number;
}

/**
 *
 * @export
 * @interface PaginatedUserSearchResponse
 */
export interface PaginatedUserSearchResponse {
  /**
   *
   * @type {number}
   * @memberof PaginatedUserSearchResponse
   */
  total?: number;
  /**
   *
   * @type {Array<UserSearchDto>}
   * @memberof PaginatedUserSearchResponse
   */
  rows?: Array<UserSearchDto>;
}

/**
 *
 * @export
 * @interface Parent
 */
export interface Parent {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Parent
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface PasswordResetDto
 */
export interface PasswordResetDto {
  /**
   *
   * @type {string}
   * @memberof PasswordResetDto
   */
  passwordOld?: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetDto
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetDto
   */
  password2?: string;
}

/**
 * The new password and a valid change key
 * @export
 * @interface PasswordUpdateParameter
 */
export interface PasswordUpdateParameter {
  /**
   *
   * @type {string}
   * @memberof PasswordUpdateParameter
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof PasswordUpdateParameter
   */
  changeKey?: string;
}

/**
 *
 * @export
 * @interface ProcessingReport
 */
export interface ProcessingReport {
  /**
   *
   * @type {Array<Report>}
   * @memberof ProcessingReport
   */
  errors?: Array<Report>;
  /**
   *
   * @type {Array<InfoReport>}
   * @memberof ProcessingReport
   */
  infos?: Array<InfoReport>;
  /**
   *
   * @type {string}
   * @memberof ProcessingReport
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof ProcessingReport
   */
  startIsoDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof ProcessingReport
   */
  endIsoDateTime?: string;
  /**
   *
   * @type {number}
   * @memberof ProcessingReport
   */
  ellapsedTimeInSeconds?: number;
  /**
   *
   * @type {number}
   * @memberof ProcessingReport
   */
  totalTimeInSeconds?: number;
  /**
   *
   * @type {boolean}
   * @memberof ProcessingReport
   */
  running?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProcessingReport
   */
  type?: string;
}

/**
 *
 * @export
 * @interface RatingAverage
 */
export interface RatingAverage {
  /**
   *
   * @type {number}
   * @memberof RatingAverage
   */
  ratingCount?: number;
  /**
   *
   * @type {{ [key: string]: number; }}
   * @memberof RatingAverage
   */
  ratingAverages?: { [key: string]: number };
  /**
   *
   * @type {number}
   * @memberof RatingAverage
   */
  userfeedbackCount?: number;
  /**
   *
   * @type {string}
   * @memberof RatingAverage
   */
  lastComment?: string;
}

/**
 *
 * @export
 * @interface RatingCriteria
 */
export interface RatingCriteria {
  /**
   *
   * @type {number}
   * @memberof RatingCriteria
   */
  id?: number;
  /**
   *
   * @type {boolean}
   * @memberof RatingCriteria
   */
  internal?: boolean;
  /**
   *
   * @type {string}
   * @memberof RatingCriteria
   */
  name?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof RatingCriteria
   */
  label?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface RegionResponse
 */
export interface RegionResponse {
  /**
   *
   * @type {number}
   * @memberof RegionResponse
   */
  north?: number;
  /**
   *
   * @type {number}
   * @memberof RegionResponse
   */
  east?: number;
  /**
   *
   * @type {number}
   * @memberof RegionResponse
   */
  south?: number;
  /**
   *
   * @type {number}
   * @memberof RegionResponse
   */
  west?: number;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof RegionResponse
   */
  label?: { [key: string]: string };
  /**
   *
   * @type {boolean}
   * @memberof RegionResponse
   */
  hasGeom?: boolean;
  /**
   *
   * @type {string}
   * @memberof RegionResponse
   */
  categoryId?: string;
  /**
   *
   * @type {string}
   * @memberof RegionResponse
   */
  id?: string;
}

/**
 *
 * @export
 * @interface Related
 */
export interface Related {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Related
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface RelatedLinkItem
 */
export interface RelatedLinkItem {
  /**
   *
   * @type {string}
   * @memberof RelatedLinkItem
   */
  id?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedLinkItem
   */
  url?: MultilingualValue;
  /**
   *
   * @type {string}
   * @memberof RelatedLinkItem
   */
  type?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedLinkItem
   */
  title: MultilingualValue;
  /**
   *
   * @type {string}
   * @memberof RelatedLinkItem
   */
  protocol?: string;
  /**
   *
   * @type {Description}
   * @memberof RelatedLinkItem
   */
  description: Description;
  /**
   *
   * @type {string}
   * @memberof RelatedLinkItem
   */
  function?: string;
  /**
   *
   * @type {string}
   * @memberof RelatedLinkItem
   */
  applicationProfile?: string;
}

/**
 *
 * @export
 * @interface RelatedMetadataItem
 */
export interface RelatedMetadataItem {
  /**
   *
   * @type {string}
   * @memberof RelatedMetadataItem
   */
  id?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedMetadataItem
   */
  url?: MultilingualValue;
  /**
   *
   * @type {string}
   * @memberof RelatedMetadataItem
   */
  type?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedMetadataItem
   */
  title: MultilingualValue;
  /**
   *
   * @type {Description}
   * @memberof RelatedMetadataItem
   */
  description: Description;
  /**
   *
   * @type {Array<string>}
   * @memberof RelatedMetadataItem
   */
  mdType: Array<string>;
  /**
   *
   * @type {string}
   * @memberof RelatedMetadataItem
   */
  origin?: string;
}

/**
 *
 * @export
 * @interface RelatedResponse
 */
export interface RelatedResponse {
  /**
   *
   * @type {Children}
   * @memberof RelatedResponse
   */
  children?: Children;
  /**
   *
   * @type {Parent}
   * @memberof RelatedResponse
   */
  parent?: Parent;
  /**
   *
   * @type {Siblings}
   * @memberof RelatedResponse
   */
  siblings?: Siblings;
  /**
   *
   * @type {Associated}
   * @memberof RelatedResponse
   */
  associated?: Associated;
  /**
   *
   * @type {Service}
   * @memberof RelatedResponse
   */
  services?: Service;
  /**
   *
   * @type {Dataset}
   * @memberof RelatedResponse
   */
  datasets?: Dataset;
  /**
   *
   * @type {Fcat}
   * @memberof RelatedResponse
   */
  fcats?: Fcat;
  /**
   *
   * @type {Hasfeaturecats}
   * @memberof RelatedResponse
   */
  hasfeaturecats?: Hasfeaturecats;
  /**
   *
   * @type {Source}
   * @memberof RelatedResponse
   */
  sources?: Source;
  /**
   *
   * @type {Hassource}
   * @memberof RelatedResponse
   */
  hassources?: Hassource;
  /**
   *
   * @type {Related}
   * @memberof RelatedResponse
   */
  related?: Related;
  /**
   *
   * @type {Online}
   * @memberof RelatedResponse
   */
  onlines?: Online;
  /**
   *
   * @type {Thumbnail}
   * @memberof RelatedResponse
   */
  thumbnails?: Thumbnail;
}

/**
 *
 * @export
 * @interface RelatedSiblingMetadataItem
 */
export interface RelatedSiblingMetadataItem {
  /**
   *
   * @type {string}
   * @memberof RelatedSiblingMetadataItem
   */
  id?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedSiblingMetadataItem
   */
  url?: MultilingualValue;
  /**
   *
   * @type {string}
   * @memberof RelatedSiblingMetadataItem
   */
  type?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedSiblingMetadataItem
   */
  title: MultilingualValue;
  /**
   *
   * @type {Description}
   * @memberof RelatedSiblingMetadataItem
   */
  description: Description;
  /**
   *
   * @type {Array<string>}
   * @memberof RelatedSiblingMetadataItem
   */
  mdType: Array<string>;
  /**
   *
   * @type {string}
   * @memberof RelatedSiblingMetadataItem
   */
  origin?: string;
  /**
   *
   * @type {string}
   * @memberof RelatedSiblingMetadataItem
   */
  associationType: string;
  /**
   *
   * @type {string}
   * @memberof RelatedSiblingMetadataItem
   */
  initiativeType: string;
}

/**
 *
 * @export
 * @interface RelatedThumbnailItem
 */
export interface RelatedThumbnailItem {
  /**
   *
   * @type {string}
   * @memberof RelatedThumbnailItem
   */
  id?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedThumbnailItem
   */
  url?: MultilingualValue;
  /**
   *
   * @type {string}
   * @memberof RelatedThumbnailItem
   */
  type?: string;
  /**
   *
   * @type {MultilingualValue}
   * @memberof RelatedThumbnailItem
   */
  title: MultilingualValue;
}

/**
 *
 * @export
 * @interface ReplaceEntryChange
 */
export interface ReplaceEntryChange {
  /**
   *
   * @type {string}
   * @memberof ReplaceEntryChange
   */
  originalVal?: string;
  /**
   *
   * @type {string}
   * @memberof ReplaceEntryChange
   */
  changedVal?: string;
  /**
   *
   * @type {string}
   * @memberof ReplaceEntryChange
   */
  fieldId?: string;
}

/**
 *
 * @export
 * @interface ReplaceReport
 */
export interface ReplaceReport {
  /**
   *
   * @type {string}
   * @memberof ReplaceReport
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof ReplaceReport
   */
  uuid?: string;
  /**
   *
   * @type {boolean}
   * @memberof ReplaceReport
   */
  draft?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ReplaceReport
   */
  approved?: boolean;
  /**
   *
   * @type {string}
   * @memberof ReplaceReport
   */
  date?: string;
  /**
   *
   * @type {Array<ReplaceEntryChange>}
   * @memberof ReplaceReport
   */
  elementChanges?: Array<ReplaceEntryChange>;
}

/**
 *
 * @export
 * @interface Report
 */
export interface Report {
  /**
   *
   * @type {string}
   * @memberof Report
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof Report
   */
  uuid?: string;
  /**
   *
   * @type {boolean}
   * @memberof Report
   */
  draft?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Report
   */
  approved?: boolean;
  /**
   *
   * @type {string}
   * @memberof Report
   */
  date?: string;
}

/**
 *
 * @export
 * @interface Reports
 */
export interface Reports {
  /**
   *
   * @type {Array<Report>}
   * @memberof Reports
   */
  report?: Array<Report>;
}

/**
 *
 * @export
 * @interface SavedQuery
 */
export interface SavedQuery {
  /**
   *
   * @type {string}
   * @memberof SavedQuery
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof SavedQuery
   */
  xpath?: string;
  /**
   *
   * @type {string}
   * @memberof SavedQuery
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof SavedQuery
   */
  cleanValues?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof SavedQuery
   */
  parameters?: Array<string>;
}

/**
 *
 * @export
 * @interface Section
 */
export interface Section {
  /**
   *
   * @type {Array<Field>}
   * @memberof Section
   */
  field: Array<Field>;
  /**
   *
   * @type {string}
   * @memberof Section
   */
  name?: string;
}

/**
 *
 * @export
 * @interface Selection
 */
export interface Selection {
  /**
   *
   * @type {number}
   * @memberof Selection
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Selection
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof Selection
   */
  watchable?: boolean;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Selection
   */
  label?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface Service
 */
export interface Service {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Service
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  storedValue?: string;
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  dataType?: SettingDataTypeEnum;
  /**
   *
   * @type {number}
   * @memberof Setting
   */
  position?: number;
  /**
   *
   * @type {boolean}
   * @memberof Setting
   */
  internal?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Setting
   */
  encrypted?: boolean;
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  internal_JpaWorkaround?: string;
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  encrypted_JpaWorkaround?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum SettingDataTypeEnum {
  String = 'STRING',
  Int = 'INT',
  Boolean = 'BOOLEAN',
  Json = 'JSON',
}

/**
 *
 * @export
 * @interface SettingsListResponse
 */
export interface SettingsListResponse {
  /**
   *
   * @type {Array<Setting>}
   * @memberof SettingsListResponse
   */
  settings?: Array<Setting>;
}

/**
 * Privileges
 * @export
 * @interface SharingParameter
 */
export interface SharingParameter {
  /**
   *
   * @type {Array<GroupOperations>}
   * @memberof SharingParameter
   */
  privileges?: Array<GroupOperations>;
  /**
   *
   * @type {boolean}
   * @memberof SharingParameter
   */
  clear?: boolean;
}

/**
 *
 * @export
 * @interface SharingResponse
 */
export interface SharingResponse {
  /**
   *
   * @type {Array<GroupPrivilege>}
   * @memberof SharingResponse
   */
  privileges?: Array<GroupPrivilege>;
  /**
   *
   * @type {string}
   * @memberof SharingResponse
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof SharingResponse
   */
  groupOwner?: string;
}

/**
 *
 * @export
 * @interface Siblings
 */
export interface Siblings {
  /**
   *
   * @type {Array<RelatedSiblingMetadataItem>}
   * @memberof Siblings
   */
  item?: Array<RelatedSiblingMetadataItem>;
}

/**
 *
 * @export
 * @interface SimpleMetadataProcessingReport
 */
export interface SimpleMetadataProcessingReport {
  /**
   *
   * @type {Array<Report>}
   * @memberof SimpleMetadataProcessingReport
   */
  errors?: Array<Report>;
  /**
   *
   * @type {Array<InfoReport>}
   * @memberof SimpleMetadataProcessingReport
   */
  infos?: Array<InfoReport>;
  /**
   *
   * @type {string}
   * @memberof SimpleMetadataProcessingReport
   */
  uuid?: string;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  totalRecords?: number;
  /**
   *
   * @type {Set<number>}
   * @memberof SimpleMetadataProcessingReport
   */
  metadata?: Set<number>;
  /**
   *
   * @type {{ [key: string]: Array<Report>; }}
   * @memberof SimpleMetadataProcessingReport
   */
  metadataErrors?: { [key: string]: Array<Report> };
  /**
   *
   * @type {{ [key: string]: Array<InfoReport>; }}
   * @memberof SimpleMetadataProcessingReport
   */
  metadataInfos?: { [key: string]: Array<InfoReport> };
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  numberOfNullRecords?: number;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  numberOfRecordsProcessed?: number;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  numberOfRecordsWithErrors?: number;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  numberOfRecords?: number;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  numberOfRecordNotFound?: number;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  numberOfRecordsNotEditable?: number;
  /**
   *
   * @type {string}
   * @memberof SimpleMetadataProcessingReport
   */
  startIsoDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof SimpleMetadataProcessingReport
   */
  endIsoDateTime?: string;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  ellapsedTimeInSeconds?: number;
  /**
   *
   * @type {number}
   * @memberof SimpleMetadataProcessingReport
   */
  totalTimeInSeconds?: number;
  /**
   *
   * @type {boolean}
   * @memberof SimpleMetadataProcessingReport
   */
  running?: boolean;
  /**
   *
   * @type {string}
   * @memberof SimpleMetadataProcessingReport
   */
  type?: string;
}

/**
 *
 * @export
 * @interface SiteInformation
 */
export interface SiteInformation {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof SiteInformation
   */
  catalogue?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof SiteInformation
   */
  index?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof SiteInformation
   */
  main?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof SiteInformation
   */
  database?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof SiteInformation
   */
  version?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface Sort
 */
export interface Sort {
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  sorted?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  unsorted?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Sort
   */
  empty?: boolean;
}

/**
 *
 * @export
 * @interface Source
 */
export interface Source {
  /**
   *
   * @type {Array<RelatedMetadataItem>}
   * @memberof Source
   */
  item?: Array<RelatedMetadataItem>;
}

/**
 *
 * @export
 * @interface Status
 */
export interface Status {
  /**
   *
   * @type {string}
   * @memberof Status
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Status
   */
  state?: StatusStateEnum;
  /**
   *
   * @type {string}
   * @memberof Status
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof Status
   */
  message?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum StatusStateEnum {
  Red = 'RED',
  Uninitialized = 'UNINITIALIZED',
  Yellow = 'YELLOW',
  Green = 'GREEN',
  Disabled = 'DISABLED',
}

/**
 *
 * @export
 * @interface StatusValue
 */
export interface StatusValue {
  /**
   *
   * @type {string}
   * @memberof StatusValue
   */
  type?: StatusValueTypeEnum;
  /**
   *
   * @type {string}
   * @memberof StatusValue
   */
  notificationLevel?: StatusValueNotificationLevelEnum;
  /**
   *
   * @type {number}
   * @memberof StatusValue
   */
  displayOrder?: number;
  /**
   *
   * @type {boolean}
   * @memberof StatusValue
   */
  reserved?: boolean;
  /**
   *
   * @type {number}
   * @memberof StatusValue
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof StatusValue
   */
  reserved_JpaWorkaround?: string;
  /**
   *
   * @type {string}
   * @memberof StatusValue
   */
  name?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StatusValue
   */
  label?: { [key: string]: string };
}

/**
 * @export
 * @enum {string}
 */
export enum StatusValueTypeEnum {
  Workflow = 'workflow',
  Task = 'task',
  Event = 'event',
}

/**
 * @export
 * @enum {string}
 */
export enum StatusValueNotificationLevelEnum {
  StatusUserOwner = 'statusUserOwner',
  CatalogueAdministrator = 'catalogueAdministrator',
  CatalogueProfileAdministrator = 'catalogueProfileAdministrator',
  CatalogueProfileUserAdmin = 'catalogueProfileUserAdmin',
  CatalogueProfileReviewer = 'catalogueProfileReviewer',
  CatalogueProfileEditor = 'catalogueProfileEditor',
  CatalogueProfileRegisteredUser = 'catalogueProfileRegisteredUser',
  CatalogueProfileGuest = 'catalogueProfileGuest',
  RecordProfileReviewer = 'recordProfileReviewer',
  RecordUserAuthor = 'recordUserAuthor',
}

/**
 *
 * @export
 * @interface SuggestionType
 */
export interface SuggestionType {
  /**
   *
   * @type {string}
   * @memberof SuggestionType
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SuggestionType
   */
  operational: string;
  /**
   *
   * @type {string}
   * @memberof SuggestionType
   */
  params?: string;
  /**
   *
   * @type {string}
   * @memberof SuggestionType
   */
  process?: string;
  /**
   *
   * @type {string}
   * @memberof SuggestionType
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof SuggestionType
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof SuggestionType
   */
  target?: string;
}

/**
 *
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  stagingProfile?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  buildDate?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  subVersion?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  buildOsInfo?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  buildJavaVersion?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  buildJavaVendor?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  scmUrl?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  scmRevision?: string;
  /**
   *
   * @type {boolean}
   * @memberof SystemInfo
   */
  devMode?: boolean;
}

/**
 *
 * @export
 * @interface Thumbnail
 */
export interface Thumbnail {
  /**
   *
   * @type {Array<RelatedThumbnailItem>}
   * @memberof Thumbnail
   */
  item?: Array<RelatedThumbnailItem>;
}

/**
 *
 * @export
 * @interface TransferRequest
 */
export interface TransferRequest {
  /**
   *
   * @type {number}
   * @memberof TransferRequest
   */
  sourceUser?: number;
  /**
   *
   * @type {number}
   * @memberof TransferRequest
   */
  sourceGroup?: number;
  /**
   *
   * @type {number}
   * @memberof TransferRequest
   */
  targetUser?: number;
  /**
   *
   * @type {number}
   * @memberof TransferRequest
   */
  targetGroup?: number;
}

/**
 *
 * @export
 * @interface Translations
 */
export interface Translations {
  /**
   *
   * @type {string}
   * @memberof Translations
   */
  fieldName?: string;
  /**
   *
   * @type {number}
   * @memberof Translations
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Translations
   */
  langId?: string;
  /**
   *
   * @type {string}
   * @memberof Translations
   */
  value?: string;
}

/**
 *
 * @export
 * @interface UiSetting
 */
export interface UiSetting {
  /**
   *
   * @type {string}
   * @memberof UiSetting
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UiSetting
   */
  configuration?: string;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  surname?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  enabled?: boolean;
  /**
   *
   * @type {number}
   * @memberof User
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  kind?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  profile?: UserProfileEnum;
  /**
   *
   * @type {Set<string>}
   * @memberof User
   */
  emailAddresses?: Set<string>;
  /**
   *
   * @type {Set<Address>}
   * @memberof User
   */
  addresses?: Set<Address>;
  /**
   *
   * @type {Address}
   * @memberof User
   */
  primaryAddress?: Address;
  /**
   *
   * @type {string}
   * @memberof User
   */
  organisation?: string;
  /**
   *
   * @type {UserSecurity}
   * @memberof User
   */
  security?: UserSecurity;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastLoginDate?: string;
  /**
   *
   * @type {Array<GrantedAuthority>}
   * @memberof User
   */
  authorities?: Array<GrantedAuthority>;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  accountNonExpired?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  accountNonLocked?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  credentialsNonExpired?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  name?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum UserProfileEnum {
  Administrator = 'Administrator',
  UserAdmin = 'UserAdmin',
  Reviewer = 'Reviewer',
  Editor = 'Editor',
  RegisteredUser = 'RegisteredUser',
  Guest = 'Guest',
  Monitor = 'Monitor',
}

/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  profile?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  surname?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UserDto
   */
  emailAddresses?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  organisation?: string;
  /**
   *
   * @type {Array<Address>}
   * @memberof UserDto
   */
  addresses?: Array<Address>;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  kind?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  password?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UserDto
   */
  groupsRegisteredUser?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UserDto
   */
  groupsEditor?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UserDto
   */
  groupsReviewer?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UserDto
   */
  groupsUserAdmin?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof UserDto
   */
  enabled?: boolean;
  /**
   *
   * @type {UserDto}
   * @memberof UserDto
   */
  email?: UserDto;
}

/**
 *
 * @export
 * @interface UserFeedbackDTO
 */
export interface UserFeedbackDTO {
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  comment?: string;
  /**
   *
   * @type {{ [key: string]: number; }}
   * @memberof UserFeedbackDTO
   */
  rating?: { [key: string]: number };
  /**
   *
   * @type {number}
   * @memberof UserFeedbackDTO
   */
  ratingAVG?: number;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  metadataUUID?: string;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  metadataTitle?: string;
  /**
   *
   * @type {number}
   * @memberof UserFeedbackDTO
   */
  authorUserId?: number;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  authorName?: string;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  authorEmail?: string;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  authorOrganization?: string;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  approverName?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserFeedbackDTO
   */
  optionPrivacy?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserFeedbackDTO
   */
  published?: boolean;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  parentUuid?: string;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  captcha?: string;
  /**
   *
   * @type {string}
   * @memberof UserFeedbackDTO
   */
  date?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserFeedbackDTO
   */
  showApproveButton?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof UserFeedbackDTO
   */
  keywords?: Array<string>;
}

/**
 *
 * @export
 * @interface UserGroup
 */
export interface UserGroup {
  /**
   *
   * @type {Group}
   * @memberof UserGroup
   */
  group?: Group;
  /**
   *
   * @type {UserGroupId}
   * @memberof UserGroup
   */
  id?: UserGroupId;
  /**
   *
   * @type {User}
   * @memberof UserGroup
   */
  user?: User;
  /**
   *
   * @type {string}
   * @memberof UserGroup
   */
  profile?: UserGroupProfileEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum UserGroupProfileEnum {
  Administrator = 'Administrator',
  UserAdmin = 'UserAdmin',
  Reviewer = 'Reviewer',
  Editor = 'Editor',
  RegisteredUser = 'RegisteredUser',
  Guest = 'Guest',
  Monitor = 'Monitor',
}

/**
 *
 * @export
 * @interface UserGroupId
 */
export interface UserGroupId {
  /**
   *
   * @type {number}
   * @memberof UserGroupId
   */
  groupId?: number;
  /**
   *
   * @type {number}
   * @memberof UserGroupId
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof UserGroupId
   */
  profile?: UserGroupIdProfileEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum UserGroupIdProfileEnum {
  Administrator = 'Administrator',
  UserAdmin = 'UserAdmin',
  Reviewer = 'Reviewer',
  Editor = 'Editor',
  RegisteredUser = 'RegisteredUser',
  Guest = 'Guest',
  Monitor = 'Monitor',
}

/**
 *
 * @export
 * @interface UserGroupsResponse
 */
export interface UserGroupsResponse {
  /**
   *
   * @type {number}
   * @memberof UserGroupsResponse
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof UserGroupsResponse
   */
  userName?: string;
  /**
   *
   * @type {number}
   * @memberof UserGroupsResponse
   */
  groupId?: number;
  /**
   *
   * @type {string}
   * @memberof UserGroupsResponse
   */
  groupName?: string;
  /**
   *
   * @type {string}
   * @memberof UserGroupsResponse
   */
  userProfile?: string;
}

/**
 * User details
 * @export
 * @interface UserRegisterDto
 */
export interface UserRegisterDto {
  /**
   *
   * @type {string}
   * @memberof UserRegisterDto
   */
  profile?: string;
  /**
   *
   * @type {string}
   * @memberof UserRegisterDto
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof UserRegisterDto
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserRegisterDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserRegisterDto
   */
  surname?: string;
  /**
   *
   * @type {string}
   * @memberof UserRegisterDto
   */
  organisation?: string;
  /**
   *
   * @type {Address}
   * @memberof UserRegisterDto
   */
  address?: Address;
  /**
   *
   * @type {string}
   * @memberof UserRegisterDto
   */
  captcha?: string;
}

/**
 * User search details
 * @export
 * @interface UserSearchDto
 */
export interface UserSearchDto {
  /**
   *
   * @type {number}
   * @memberof UserSearchDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserSearchDto
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof UserSearchDto
   */
  featuredType?: string;
  /**
   *
   * @type {string}
   * @memberof UserSearchDto
   */
  creationDate?: string;
  /**
   *
   * @type {number}
   * @memberof UserSearchDto
   */
  creatorId?: number;
  /**
   *
   * @type {string}
   * @memberof UserSearchDto
   */
  creator?: string;
  /**
   *
   * @type {string}
   * @memberof UserSearchDto
   */
  logo?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof UserSearchDto
   */
  names?: { [key: string]: string };
  /**
   *
   * @type {Array<number>}
   * @memberof UserSearchDto
   */
  groups?: Array<number>;
}

/**
 *
 * @export
 * @interface UserSecurity
 */
export interface UserSecurity {
  /**
   *
   * @type {string}
   * @memberof UserSecurity
   */
  nodeId?: string;
  /**
   *
   * @type {Set<string>}
   * @memberof UserSecurity
   */
  securityNotifications?: Set<UserSecuritySecurityNotificationsEnum>;
  /**
   *
   * @type {string}
   * @memberof UserSecurity
   */
  authType?: string;
  /**
   *
   * @type {UserSecurity}
   * @memberof UserSecurity
   */
  securityNotificationsString?: UserSecurity;
}

/**
 * @export
 * @enum {string}
 */
export enum UserSecuritySecurityNotificationsEnum {
  UpdateHashRequired = 'UPDATE_HASH_REQUIRED',
  Unknown = 'UNKNOWN',
}

/**
 *
 * @export
 * @interface Values
 */
export interface Values {
  /**
   *
   * @type {string}
   * @memberof Values
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof Values
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof Values
   */
  definition?: string;
}

/**
 *
 * @export
 * @interface XsltMetadataProcessingReport
 */
export interface XsltMetadataProcessingReport {
  /**
   *
   * @type {Array<Report>}
   * @memberof XsltMetadataProcessingReport
   */
  errors?: Array<Report>;
  /**
   *
   * @type {Array<InfoReport>}
   * @memberof XsltMetadataProcessingReport
   */
  infos?: Array<InfoReport>;
  /**
   *
   * @type {string}
   * @memberof XsltMetadataProcessingReport
   */
  uuid?: string;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  totalRecords?: number;
  /**
   *
   * @type {Set<number>}
   * @memberof XsltMetadataProcessingReport
   */
  metadata?: Set<number>;
  /**
   *
   * @type {{ [key: string]: Array<Report>; }}
   * @memberof XsltMetadataProcessingReport
   */
  metadataErrors?: { [key: string]: Array<Report> };
  /**
   *
   * @type {{ [key: string]: Array<InfoReport>; }}
   * @memberof XsltMetadataProcessingReport
   */
  metadataInfos?: { [key: string]: Array<InfoReport> };
  /**
   *
   * @type {string}
   * @memberof XsltMetadataProcessingReport
   */
  processId?: string;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  noProcessFoundCount?: number;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  numberOfNullRecords?: number;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  numberOfRecordsProcessed?: number;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  numberOfRecordsWithErrors?: number;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  numberOfRecords?: number;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  numberOfRecordNotFound?: number;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  numberOfRecordsNotEditable?: number;
  /**
   *
   * @type {string}
   * @memberof XsltMetadataProcessingReport
   */
  startIsoDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof XsltMetadataProcessingReport
   */
  endIsoDateTime?: string;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  ellapsedTimeInSeconds?: number;
  /**
   *
   * @type {number}
   * @memberof XsltMetadataProcessingReport
   */
  totalTimeInSeconds?: number;
  /**
   *
   * @type {boolean}
   * @memberof XsltMetadataProcessingReport
   */
  running?: boolean;
  /**
   *
   * @type {string}
   * @memberof XsltMetadataProcessingReport
   */
  type?: string;
}

/**
 * CustomstyleApi - axios parameter creator
 * @export
 */
export const CustomstyleApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This returns a map with all Less variables.
     * @summary Get CssStyleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCssStyle: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/customstyle`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Saves custom style variables.
     * @summary Saves custom style variables.
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCssStyle: async (
      body: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('saveCssStyle', 'body', body);
      const localVarPath = `/customstyle`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomstyleApi - functional programming interface
 * @export
 */
export const CustomstyleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CustomstyleApiAxiosParamCreator(configuration);
  return {
    /**
     * This returns a map with all Less variables.
     * @summary Get CssStyleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCssStyle(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCssStyle(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Saves custom style variables.
     * @summary Saves custom style variables.
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveCssStyle(
      body: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveCssStyle(
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CustomstyleApi - factory interface
 * @export
 */
export const CustomstyleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CustomstyleApiFp(configuration);
  return {
    /**
     * This returns a map with all Less variables.
     * @summary Get CssStyleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCssStyle(options?: any): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getCssStyle(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Saves custom style variables.
     * @summary Saves custom style variables.
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCssStyle(body: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .saveCssStyle(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CustomstyleApi - object-oriented interface
 * @export
 * @class CustomstyleApi
 * @extends {BaseAPI}
 */
export class CustomstyleApi extends BaseAPI {
  /**
   * This returns a map with all Less variables.
   * @summary Get CssStyleSettings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomstyleApi
   */
  public getCssStyle(options?: AxiosRequestConfig) {
    return CustomstyleApiFp(this.configuration)
      .getCssStyle(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Saves custom style variables.
   * @summary Saves custom style variables.
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomstyleApi
   */
  public saveCssStyle(body: string, options?: AxiosRequestConfig) {
    return CustomstyleApiFp(this.configuration)
      .saveCssStyle(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FormattersApi - axios parameter creator
 * @export
 */
export const FormattersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
     * @param {Array<any>} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFormatter: async (
      file: Array<any>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('addFormatter', 'file', file);
      const localVarPath = `/formatters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (file) {
        localVarQueryParameter['file'] = file;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
     * @summary Clear formatter cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearFormatterCache: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/formatters/cache`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a formatter
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFormatter: async (
      formatter: string,
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists('deleteFormatter', 'formatter', formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('deleteFormatter', 'schema', schema);
      const localVarPath = `/formatters/{schema}/{formatter}`
        .replace(`{${'formatter'}}`, encodeURIComponent(String(formatter)))
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download a formatter as ZIP
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFormatter: async (
      formatter: string,
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists('downloadFormatter', 'formatter', formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('downloadFormatter', 'schema', schema);
      const localVarPath = `/formatters/{schema}/{formatter}`
        .replace(`{${'formatter'}}`, encodeURIComponent(String(formatter)))
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get formatter file content
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFileContent: async (
      formatter: string,
      schema: string,
      file: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists('getFormatterFileContent', 'formatter', formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('getFormatterFileContent', 'schema', schema);
      // verify required parameter 'file' is not null or undefined
      assertParamExists('getFormatterFileContent', 'file', file);
      const localVarPath = `/formatters/{schema}/{formatter}/files/{file}`
        .replace(`{${'formatter'}}`, encodeURIComponent(String(formatter)))
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)))
        .replace(`{${'file'}}`, encodeURIComponent(String(file)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get formatter files
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFiles: async (
      formatter: string,
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists('getFormatterFiles', 'formatter', formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('getFormatterFiles', 'schema', schema);
      const localVarPath = `/formatters/{schema}/{formatter}/files`
        .replace(`{${'formatter'}}`, encodeURIComponent(String(formatter)))
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get formatters
     * @param {string} [id]
     * @param {string} [uuid]
     * @param {string} [schema]
     * @param {boolean} [pluginOnly]
     * @param {boolean} [publishedOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFormatters: async (
      id?: string,
      uuid?: string,
      schema?: string,
      pluginOnly?: boolean,
      publishedOnly?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/formatters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (uuid !== undefined) {
        localVarQueryParameter['uuid'] = uuid;
      }

      if (schema !== undefined) {
        localVarQueryParameter['schema'] = schema;
      }

      if (pluginOnly !== undefined) {
        localVarQueryParameter['pluginOnly'] = pluginOnly;
      }

      if (publishedOnly !== undefined) {
        localVarQueryParameter['publishedOnly'] = publishedOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update formatter file
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {string} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFormatterFile: async (
      formatter: string,
      schema: string,
      file: string,
      data: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatter' is not null or undefined
      assertParamExists('updateFormatterFile', 'formatter', formatter);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('updateFormatterFile', 'schema', schema);
      // verify required parameter 'file' is not null or undefined
      assertParamExists('updateFormatterFile', 'file', file);
      // verify required parameter 'data' is not null or undefined
      assertParamExists('updateFormatterFile', 'data', data);
      const localVarPath = `/formatters/{schema}/{formatter}/files/{file}`
        .replace(`{${'formatter'}}`, encodeURIComponent(String(formatter)))
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)))
        .replace(`{${'file'}}`, encodeURIComponent(String(file)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (data !== undefined) {
        localVarQueryParameter['data'] = data;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FormattersApi - functional programming interface
 * @export
 */
export const FormattersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FormattersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
     * @param {Array<any>} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFormatter(
      file: Array<any>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addFormatter(
        file,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
     * @summary Clear formatter cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clearFormatterCache(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clearFormatterCache(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete a formatter
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFormatter(
      formatter: string,
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFormatter(
        formatter,
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Download a formatter as ZIP
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFormatter(
      formatter: string,
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.downloadFormatter(
          formatter,
          schema,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get formatter file content
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormatterFileContent(
      formatter: string,
      schema: string,
      file: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFormatterFileContent(
          formatter,
          schema,
          file,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get formatter files
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormatterFiles(
      formatter: string,
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFormatterFiles(
          formatter,
          schema,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get formatters
     * @param {string} [id]
     * @param {string} [uuid]
     * @param {string} [schema]
     * @param {boolean} [pluginOnly]
     * @param {boolean} [publishedOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFormatters(
      id?: string,
      uuid?: string,
      schema?: string,
      pluginOnly?: boolean,
      publishedOnly?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FormatterDataResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listFormatters(
        id,
        uuid,
        schema,
        pluginOnly,
        publishedOnly,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update formatter file
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {string} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFormatterFile(
      formatter: string,
      schema: string,
      file: string,
      data: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFormatterFile(
          formatter,
          schema,
          file,
          data,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FormattersApi - factory interface
 * @export
 */
export const FormattersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FormattersApiFp(configuration);
  return {
    /**
     *
     * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
     * @param {Array<any>} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFormatter(file: Array<any>, options?: any): AxiosPromise<void> {
      return localVarFp
        .addFormatter(file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
     * @summary Clear formatter cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearFormatterCache(options?: any): AxiosPromise<void> {
      return localVarFp
        .clearFormatterCache(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a formatter
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFormatter(
      formatter: string,
      schema: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFormatter(formatter, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download a formatter as ZIP
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFormatter(
      formatter: string,
      schema: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadFormatter(formatter, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get formatter file content
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFileContent(
      formatter: string,
      schema: string,
      file: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getFormatterFileContent(formatter, schema, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get formatter files
     * @param {string} formatter
     * @param {string} schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormatterFiles(
      formatter: string,
      schema: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getFormatterFiles(formatter, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get formatters
     * @param {string} [id]
     * @param {string} [uuid]
     * @param {string} [schema]
     * @param {boolean} [pluginOnly]
     * @param {boolean} [publishedOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFormatters(
      id?: string,
      uuid?: string,
      schema?: string,
      pluginOnly?: boolean,
      publishedOnly?: boolean,
      options?: any
    ): AxiosPromise<FormatterDataResponse> {
      return localVarFp
        .listFormatters(id, uuid, schema, pluginOnly, publishedOnly, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update formatter file
     * @param {string} formatter
     * @param {string} schema
     * @param {string} file
     * @param {string} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFormatterFile(
      formatter: string,
      schema: string,
      file: string,
      data: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateFormatterFile(formatter, schema, file, data, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FormattersApi - object-oriented interface
 * @export
 * @class FormattersApi
 * @extends {BaseAPI}
 */
export class FormattersApi extends BaseAPI {
  /**
   *
   * @summary Import a XSLT formatter (usually a zip named \'schema-formatter.zip\')
   * @param {Array<any>} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public addFormatter(file: Array<any>, options?: AxiosRequestConfig) {
    return FormattersApiFp(this.configuration)
      .addFormatter(file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Formatters are used to render records in various format (HTML, PDF, ...). When a record is rendered a cache is populated for better performance. By default the cache is an H2 database with files on the filesystems (See <dataDirectory>/resources/htmlcache/formatter-cache folder).
   * @summary Clear formatter cache
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public clearFormatterCache(options?: AxiosRequestConfig) {
    return FormattersApiFp(this.configuration)
      .clearFormatterCache(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a formatter
   * @param {string} formatter
   * @param {string} schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public deleteFormatter(
    formatter: string,
    schema: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .deleteFormatter(formatter, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download a formatter as ZIP
   * @param {string} formatter
   * @param {string} schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public downloadFormatter(
    formatter: string,
    schema: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .downloadFormatter(formatter, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get formatter file content
   * @param {string} formatter
   * @param {string} schema
   * @param {string} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public getFormatterFileContent(
    formatter: string,
    schema: string,
    file: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .getFormatterFileContent(formatter, schema, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get formatter files
   * @param {string} formatter
   * @param {string} schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public getFormatterFiles(
    formatter: string,
    schema: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .getFormatterFiles(formatter, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get formatters
   * @param {string} [id]
   * @param {string} [uuid]
   * @param {string} [schema]
   * @param {boolean} [pluginOnly]
   * @param {boolean} [publishedOnly]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public listFormatters(
    id?: string,
    uuid?: string,
    schema?: string,
    pluginOnly?: boolean,
    publishedOnly?: boolean,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .listFormatters(id, uuid, schema, pluginOnly, publishedOnly, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update formatter file
   * @param {string} formatter
   * @param {string} schema
   * @param {string} file
   * @param {string} data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormattersApi
   */
  public updateFormatterFile(
    formatter: string,
    schema: string,
    file: string,
    data: string,
    options?: AxiosRequestConfig
  ) {
    return FormattersApiFp(this.configuration)
      .updateFormatterFile(formatter, schema, file, data, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return the identifier of the group created.
     * @summary Add a group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroup: async (
      group: Group,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'group' is not null or undefined
      assertParamExists('addGroup', 'group', group);
      const localVarPath = `/groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        group,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a group by first removing sharing settings, link to users and finally reindex all affected records.
     * @summary Remove a group
     * @param {number} groupIdentifier Group identifier.
     * @param {boolean} [force] Force removal even if records are assigned to that group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup: async (
      groupIdentifier: number,
      force?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists('deleteGroup', 'groupIdentifier', groupIdentifier);
      const localVarPath = `/groups/{groupIdentifier}`.replace(
        `{${'groupIdentifier'}}`,
        encodeURIComponent(String(groupIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (force !== undefined) {
        localVarQueryParameter['force'] = force;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the requested group details.
     * @summary Get group
     * @param {number} groupIdentifier Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup: async (
      groupIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists('getGroup', 'groupIdentifier', groupIdentifier);
      const localVarPath = `/groups/{groupIdentifier}`.replace(
        `{${'groupIdentifier'}}`,
        encodeURIComponent(String(groupIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If last-modified header is present it is used to check if the logo has been modified since the header date. If it hasn\'t been modified returns an empty 304 Not Modified response. If modified returns the image. If the group has no logo then returns a transparent 1x1 px PNG image.
     * @summary Get the group logo image.
     * @param {number} groupId Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupLogo: async (
      groupId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('getGroupLogo', 'groupId', groupId);
      const localVarPath = `/groups/{groupId}/logo`.replace(
        `{${'groupId'}}`,
        encodeURIComponent(String(groupId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get group users
     * @param {number} groupIdentifier Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupUsers: async (
      groupIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists('getGroupUsers', 'groupIdentifier', groupIdentifier);
      const localVarPath = `/groups/{groupIdentifier}/users`.replace(
        `{${'groupIdentifier'}}`,
        encodeURIComponent(String(groupIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The catalog contains one or more groups. By default, there is 3 reserved groups (Internet, Intranet, Guest) and a sample group.<br/>This service returns all catalog groups when not authenticated or when current is user is an administrator. The list can contains or not reserved groups depending on the parameters.<br/>When authenticated, return user groups optionally filtered on a specific user profile.
     * @summary Get groups
     * @param {boolean} [withReservedGroup] Including Internet, Intranet, Guest groups or not
     * @param {string} [profile] For a specific profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups: async (
      withReservedGroup?: boolean,
      profile?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (withReservedGroup !== undefined) {
        localVarQueryParameter['withReservedGroup'] = withReservedGroup;
      }

      if (profile !== undefined) {
        localVarQueryParameter['profile'] = profile;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a group
     * @param {number} groupIdentifier Group identifier
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup: async (
      groupIdentifier: number,
      group: Group,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists('updateGroup', 'groupIdentifier', groupIdentifier);
      // verify required parameter 'group' is not null or undefined
      assertParamExists('updateGroup', 'group', group);
      const localVarPath = `/groups/{groupIdentifier}`.replace(
        `{${'groupIdentifier'}}`,
        encodeURIComponent(String(groupIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        group,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return the identifier of the group created.
     * @summary Add a group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroup(
      group: Group,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroup(
        group,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Remove a group by first removing sharing settings, link to users and finally reindex all affected records.
     * @summary Remove a group
     * @param {number} groupIdentifier Group identifier.
     * @param {boolean} [force] Force removal even if records are assigned to that group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGroup(
      groupIdentifier: number,
      force?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(
        groupIdentifier,
        force,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the requested group details.
     * @summary Get group
     * @param {number} groupIdentifier Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroup(
      groupIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(
        groupIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * If last-modified header is present it is used to check if the logo has been modified since the header date. If it hasn\'t been modified returns an empty 304 Not Modified response. If modified returns the image. If the group has no logo then returns a transparent 1x1 px PNG image.
     * @summary Get the group logo image.
     * @param {number} groupId Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroupLogo(
      groupId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupLogo(
        groupId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get group users
     * @param {number} groupIdentifier Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroupUsers(
      groupIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupUsers(
        groupIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The catalog contains one or more groups. By default, there is 3 reserved groups (Internet, Intranet, Guest) and a sample group.<br/>This service returns all catalog groups when not authenticated or when current is user is an administrator. The list can contains or not reserved groups depending on the parameters.<br/>When authenticated, return user groups optionally filtered on a specific user profile.
     * @summary Get groups
     * @param {boolean} [withReservedGroup] Including Internet, Intranet, Guest groups or not
     * @param {string} [profile] For a specific profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroups(
      withReservedGroup?: boolean,
      profile?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(
        withReservedGroup,
        profile,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a group
     * @param {number} groupIdentifier Group identifier
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGroup(
      groupIdentifier: number,
      group: Group,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(
        groupIdentifier,
        group,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GroupsApiFp(configuration);
  return {
    /**
     * Return the identifier of the group created.
     * @summary Add a group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroup(group: Group, options?: any): AxiosPromise<number> {
      return localVarFp
        .addGroup(group, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove a group by first removing sharing settings, link to users and finally reindex all affected records.
     * @summary Remove a group
     * @param {number} groupIdentifier Group identifier.
     * @param {boolean} [force] Force removal even if records are assigned to that group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(
      groupIdentifier: number,
      force?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteGroup(groupIdentifier, force, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the requested group details.
     * @summary Get group
     * @param {number} groupIdentifier Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupIdentifier: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .getGroup(groupIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * If last-modified header is present it is used to check if the logo has been modified since the header date. If it hasn\'t been modified returns an empty 304 Not Modified response. If modified returns the image. If the group has no logo then returns a transparent 1x1 px PNG image.
     * @summary Get the group logo image.
     * @param {number} groupId Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupLogo(groupId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .getGroupLogo(groupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get group users
     * @param {number} groupIdentifier Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupUsers(
      groupIdentifier: number,
      options?: any
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .getGroupUsers(groupIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The catalog contains one or more groups. By default, there is 3 reserved groups (Internet, Intranet, Guest) and a sample group.<br/>This service returns all catalog groups when not authenticated or when current is user is an administrator. The list can contains or not reserved groups depending on the parameters.<br/>When authenticated, return user groups optionally filtered on a specific user profile.
     * @summary Get groups
     * @param {boolean} [withReservedGroup] Including Internet, Intranet, Guest groups or not
     * @param {string} [profile] For a specific profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(
      withReservedGroup?: boolean,
      profile?: string,
      options?: any
    ): AxiosPromise<Array<Group>> {
      return localVarFp
        .getGroups(withReservedGroup, profile, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a group
     * @param {number} groupIdentifier Group identifier
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup(
      groupIdentifier: number,
      group: Group,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateGroup(groupIdentifier, group, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
  /**
   * Return the identifier of the group created.
   * @summary Add a group
   * @param {Group} group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public addGroup(group: Group, options?: AxiosRequestConfig) {
    return GroupsApiFp(this.configuration)
      .addGroup(group, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove a group by first removing sharing settings, link to users and finally reindex all affected records.
   * @summary Remove a group
   * @param {number} groupIdentifier Group identifier.
   * @param {boolean} [force] Force removal even if records are assigned to that group.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public deleteGroup(
    groupIdentifier: number,
    force?: boolean,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .deleteGroup(groupIdentifier, force, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the requested group details.
   * @summary Get group
   * @param {number} groupIdentifier Group identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public getGroup(groupIdentifier: number, options?: AxiosRequestConfig) {
    return GroupsApiFp(this.configuration)
      .getGroup(groupIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * If last-modified header is present it is used to check if the logo has been modified since the header date. If it hasn\'t been modified returns an empty 304 Not Modified response. If modified returns the image. If the group has no logo then returns a transparent 1x1 px PNG image.
   * @summary Get the group logo image.
   * @param {number} groupId Group identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public getGroupLogo(groupId: number, options?: AxiosRequestConfig) {
    return GroupsApiFp(this.configuration)
      .getGroupLogo(groupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get group users
   * @param {number} groupIdentifier Group identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public getGroupUsers(groupIdentifier: number, options?: AxiosRequestConfig) {
    return GroupsApiFp(this.configuration)
      .getGroupUsers(groupIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The catalog contains one or more groups. By default, there is 3 reserved groups (Internet, Intranet, Guest) and a sample group.<br/>This service returns all catalog groups when not authenticated or when current is user is an administrator. The list can contains or not reserved groups depending on the parameters.<br/>When authenticated, return user groups optionally filtered on a specific user profile.
   * @summary Get groups
   * @param {boolean} [withReservedGroup] Including Internet, Intranet, Guest groups or not
   * @param {string} [profile] For a specific profile
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public getGroups(
    withReservedGroup?: boolean,
    profile?: string,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .getGroups(withReservedGroup, profile, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a group
   * @param {number} groupIdentifier Group identifier
   * @param {Group} group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public updateGroup(
    groupIdentifier: number,
    group: Group,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .updateGroup(groupIdentifier, group, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HarvestersApi - axios parameter creator
 * @export
 */
export const HarvestersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Assign harvester records to a new source
     * @param {string} harvesterUuid The harvester UUID
     * @param {string} source The target source UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignHarvestedRecordToSource: async (
      harvesterUuid: string,
      source: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'harvesterUuid' is not null or undefined
      assertParamExists(
        'assignHarvestedRecordToSource',
        'harvesterUuid',
        harvesterUuid
      );
      // verify required parameter 'source' is not null or undefined
      assertParamExists('assignHarvestedRecordToSource', 'source', source);
      const localVarPath = `/harvesters/{harvesterUuid}/assign`.replace(
        `{${'harvesterUuid'}}`,
        encodeURIComponent(String(harvesterUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (source !== undefined) {
        localVarQueryParameter['source'] = source;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if a harvester name or host already exist
     * @param {string} property The harvester property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkHarvesterPropertyExist: async (
      property: string,
      exist: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'property' is not null or undefined
      assertParamExists('checkHarvesterPropertyExist', 'property', property);
      // verify required parameter 'exist' is not null or undefined
      assertParamExists('checkHarvesterPropertyExist', 'exist', exist);
      const localVarPath = `/harvesters/properties/{property}`.replace(
        `{${'property'}}`,
        encodeURIComponent(String(property))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (exist !== undefined) {
        localVarQueryParameter['exist'] = exist;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HarvestersApi - functional programming interface
 * @export
 */
export const HarvestersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    HarvestersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Assign harvester records to a new source
     * @param {string} harvesterUuid The harvester UUID
     * @param {string} source The target source UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignHarvestedRecordToSource(
      harvesterUuid: string,
      source: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.assignHarvestedRecordToSource(
          harvesterUuid,
          source,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Check if a harvester name or host already exist
     * @param {string} property The harvester property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkHarvesterPropertyExist(
      property: string,
      exist: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkHarvesterPropertyExist(
          property,
          exist,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * HarvestersApi - factory interface
 * @export
 */
export const HarvestersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HarvestersApiFp(configuration);
  return {
    /**
     *
     * @summary Assign harvester records to a new source
     * @param {string} harvesterUuid The harvester UUID
     * @param {string} source The target source UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignHarvestedRecordToSource(
      harvesterUuid: string,
      source: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .assignHarvestedRecordToSource(harvesterUuid, source, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check if a harvester name or host already exist
     * @param {string} property The harvester property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkHarvesterPropertyExist(
      property: string,
      exist: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .checkHarvesterPropertyExist(property, exist, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HarvestersApi - object-oriented interface
 * @export
 * @class HarvestersApi
 * @extends {BaseAPI}
 */
export class HarvestersApi extends BaseAPI {
  /**
   *
   * @summary Assign harvester records to a new source
   * @param {string} harvesterUuid The harvester UUID
   * @param {string} source The target source UUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HarvestersApi
   */
  public assignHarvestedRecordToSource(
    harvesterUuid: string,
    source: string,
    options?: AxiosRequestConfig
  ) {
    return HarvestersApiFp(this.configuration)
      .assignHarvestedRecordToSource(harvesterUuid, source, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check if a harvester name or host already exist
   * @param {string} property The harvester property to check
   * @param {string} exist The value to search
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HarvestersApi
   */
  public checkHarvesterPropertyExist(
    property: string,
    exist: string,
    options?: AxiosRequestConfig
  ) {
    return HarvestersApiFp(this.configuration)
      .checkHarvesterPropertyExist(property, exist, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IdentifiersApi - axios parameter creator
 * @export
 */
export const IdentifiersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add an identifier template
     * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addIdentifier: async (
      metadataIdentifierTemplate: MetadataIdentifierTemplate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataIdentifierTemplate' is not null or undefined
      assertParamExists(
        'addIdentifier',
        'metadataIdentifierTemplate',
        metadataIdentifierTemplate
      );
      const localVarPath = `/identifiers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        metadataIdentifierTemplate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove an identifier template
     * @param {number} identifier Identifier template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIdentifier: async (
      identifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'identifier' is not null or undefined
      assertParamExists('deleteIdentifier', 'identifier', identifier);
      const localVarPath = `/identifiers/{identifier}`.replace(
        `{${'identifier'}}`,
        encodeURIComponent(String(identifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Identifier templates are used to create record UUIDs havind a particular structure. The template will be used when user creates a new record. The template identifier to use is defined in the administration > settings.
     * @summary Get identifier templates
     * @param {boolean} [userDefinedOnly] Only user defined ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentifiers: async (
      userDefinedOnly?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/identifiers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userDefinedOnly !== undefined) {
        localVarQueryParameter['userDefinedOnly'] = userDefinedOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update an identifier template
     * @param {number} identifier Identifier template identifier
     * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIdentifier: async (
      identifier: number,
      metadataIdentifierTemplate: MetadataIdentifierTemplate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'identifier' is not null or undefined
      assertParamExists('updateIdentifier', 'identifier', identifier);
      // verify required parameter 'metadataIdentifierTemplate' is not null or undefined
      assertParamExists(
        'updateIdentifier',
        'metadataIdentifierTemplate',
        metadataIdentifierTemplate
      );
      const localVarPath = `/identifiers/{identifier}`.replace(
        `{${'identifier'}}`,
        encodeURIComponent(String(identifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        metadataIdentifierTemplate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IdentifiersApi - functional programming interface
 * @export
 */
export const IdentifiersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    IdentifiersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add an identifier template
     * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addIdentifier(
      metadataIdentifierTemplate: MetadataIdentifierTemplate,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addIdentifier(
        metadataIdentifierTemplate,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove an identifier template
     * @param {number} identifier Identifier template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteIdentifier(
      identifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteIdentifier(identifier, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Identifier templates are used to create record UUIDs havind a particular structure. The template will be used when user creates a new record. The template identifier to use is defined in the administration > settings.
     * @summary Get identifier templates
     * @param {boolean} [userDefinedOnly] Only user defined ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentifiers(
      userDefinedOnly?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MetadataIdentifierTemplate>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentifiers(
        userDefinedOnly,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update an identifier template
     * @param {number} identifier Identifier template identifier
     * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateIdentifier(
      identifier: number,
      metadataIdentifierTemplate: MetadataIdentifierTemplate,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateIdentifier(
          identifier,
          metadataIdentifierTemplate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * IdentifiersApi - factory interface
 * @export
 */
export const IdentifiersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = IdentifiersApiFp(configuration);
  return {
    /**
     *
     * @summary Add an identifier template
     * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addIdentifier(
      metadataIdentifierTemplate: MetadataIdentifierTemplate,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .addIdentifier(metadataIdentifierTemplate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove an identifier template
     * @param {number} identifier Identifier template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIdentifier(identifier: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteIdentifier(identifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Identifier templates are used to create record UUIDs havind a particular structure. The template will be used when user creates a new record. The template identifier to use is defined in the administration > settings.
     * @summary Get identifier templates
     * @param {boolean} [userDefinedOnly] Only user defined ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentifiers(
      userDefinedOnly?: boolean,
      options?: any
    ): AxiosPromise<Array<MetadataIdentifierTemplate>> {
      return localVarFp
        .getIdentifiers(userDefinedOnly, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update an identifier template
     * @param {number} identifier Identifier template identifier
     * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIdentifier(
      identifier: number,
      metadataIdentifierTemplate: MetadataIdentifierTemplate,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateIdentifier(identifier, metadataIdentifierTemplate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IdentifiersApi - object-oriented interface
 * @export
 * @class IdentifiersApi
 * @extends {BaseAPI}
 */
export class IdentifiersApi extends BaseAPI {
  /**
   *
   * @summary Add an identifier template
   * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentifiersApi
   */
  public addIdentifier(
    metadataIdentifierTemplate: MetadataIdentifierTemplate,
    options?: AxiosRequestConfig
  ) {
    return IdentifiersApiFp(this.configuration)
      .addIdentifier(metadataIdentifierTemplate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove an identifier template
   * @param {number} identifier Identifier template identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentifiersApi
   */
  public deleteIdentifier(identifier: number, options?: AxiosRequestConfig) {
    return IdentifiersApiFp(this.configuration)
      .deleteIdentifier(identifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Identifier templates are used to create record UUIDs havind a particular structure. The template will be used when user creates a new record. The template identifier to use is defined in the administration > settings.
   * @summary Get identifier templates
   * @param {boolean} [userDefinedOnly] Only user defined ones
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentifiersApi
   */
  public getIdentifiers(
    userDefinedOnly?: boolean,
    options?: AxiosRequestConfig
  ) {
    return IdentifiersApiFp(this.configuration)
      .getIdentifiers(userDefinedOnly, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update an identifier template
   * @param {number} identifier Identifier template identifier
   * @param {MetadataIdentifierTemplate} metadataIdentifierTemplate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentifiersApi
   */
  public updateIdentifier(
    identifier: number,
    metadataIdentifierTemplate: MetadataIdentifierTemplate,
    options?: AxiosRequestConfig
  ) {
    return IdentifiersApiFp(this.configuration)
      .updateIdentifier(identifier, metadataIdentifierTemplate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Add all default translations from all *Desc tables in the database. This operation will only add translations for a default catalog installation. Defaults can be customized in SQL scripts located in WEB-INF/classes/setup/sql/data/_*.
     * @summary Add a language
     * @param {string} langCode ISO 3 letter code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLanguages: async (
      langCode: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'langCode' is not null or undefined
      assertParamExists('addLanguages', 'langCode', langCode);
      const localVarPath = `/languages/{langCode}`.replace(
        `{${'langCode'}}`,
        encodeURIComponent(String(langCode))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete all translations from all *Desc tables in the database. Warning: This will also remove all translations you may have done to those objects (eg. custom groups).
     * @summary Remove a language
     * @param {string} langCode ISO 3 letter code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLanguage: async (
      langCode: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'langCode' is not null or undefined
      assertParamExists('deleteLanguage', 'langCode', langCode);
      const localVarPath = `/languages/{langCode}`.replace(
        `{${'langCode'}}`,
        encodeURIComponent(String(langCode))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Languages available in this version of the application. Those that you can add using PUT operation and which have SQL script to initialize the language.
     * @summary Get languages available in the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationLanguages: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/languages/application`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ISO languages provides a list of all languages (eg. used for autocompletion in metadata editor).
     * @summary Get ISO languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIsoLanguages: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/isolanguages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Languages for the application having translations in the database. All tables with \'Desc\' suffix contains translation for some domain objects like groups, tags, ...
     * @summary Get languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLanguages: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/languages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LanguagesApiAxiosParamCreator(configuration);
  return {
    /**
     * Add all default translations from all *Desc tables in the database. This operation will only add translations for a default catalog installation. Defaults can be customized in SQL scripts located in WEB-INF/classes/setup/sql/data/_*.
     * @summary Add a language
     * @param {string} langCode ISO 3 letter code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addLanguages(
      langCode: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addLanguages(
        langCode,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete all translations from all *Desc tables in the database. Warning: This will also remove all translations you may have done to those objects (eg. custom groups).
     * @summary Remove a language
     * @param {string} langCode ISO 3 letter code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLanguage(
      langCode: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLanguage(
        langCode,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Languages available in this version of the application. Those that you can add using PUT operation and which have SQL script to initialize the language.
     * @summary Get languages available in the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationLanguages(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Language>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getApplicationLanguages(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ISO languages provides a list of all languages (eg. used for autocompletion in metadata editor).
     * @summary Get ISO languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIsoLanguages(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<IsoLanguage>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIsoLanguages(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Languages for the application having translations in the database. All tables with \'Desc\' suffix contains translation for some domain objects like groups, tags, ...
     * @summary Get languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLanguages(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Language>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLanguages(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LanguagesApiFp(configuration);
  return {
    /**
     * Add all default translations from all *Desc tables in the database. This operation will only add translations for a default catalog installation. Defaults can be customized in SQL scripts located in WEB-INF/classes/setup/sql/data/_*.
     * @summary Add a language
     * @param {string} langCode ISO 3 letter code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLanguages(langCode: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .addLanguages(langCode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete all translations from all *Desc tables in the database. Warning: This will also remove all translations you may have done to those objects (eg. custom groups).
     * @summary Remove a language
     * @param {string} langCode ISO 3 letter code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLanguage(langCode: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteLanguage(langCode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Languages available in this version of the application. Those that you can add using PUT operation and which have SQL script to initialize the language.
     * @summary Get languages available in the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationLanguages(options?: any): AxiosPromise<Array<Language>> {
      return localVarFp
        .getApplicationLanguages(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ISO languages provides a list of all languages (eg. used for autocompletion in metadata editor).
     * @summary Get ISO languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIsoLanguages(options?: any): AxiosPromise<Array<IsoLanguage>> {
      return localVarFp
        .getIsoLanguages(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Languages for the application having translations in the database. All tables with \'Desc\' suffix contains translation for some domain objects like groups, tags, ...
     * @summary Get languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLanguages(options?: any): AxiosPromise<Array<Language>> {
      return localVarFp
        .getLanguages(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
  /**
   * Add all default translations from all *Desc tables in the database. This operation will only add translations for a default catalog installation. Defaults can be customized in SQL scripts located in WEB-INF/classes/setup/sql/data/_*.
   * @summary Add a language
   * @param {string} langCode ISO 3 letter code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LanguagesApi
   */
  public addLanguages(langCode: string, options?: AxiosRequestConfig) {
    return LanguagesApiFp(this.configuration)
      .addLanguages(langCode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete all translations from all *Desc tables in the database. Warning: This will also remove all translations you may have done to those objects (eg. custom groups).
   * @summary Remove a language
   * @param {string} langCode ISO 3 letter code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LanguagesApi
   */
  public deleteLanguage(langCode: string, options?: AxiosRequestConfig) {
    return LanguagesApiFp(this.configuration)
      .deleteLanguage(langCode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Languages available in this version of the application. Those that you can add using PUT operation and which have SQL script to initialize the language.
   * @summary Get languages available in the application
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LanguagesApi
   */
  public getApplicationLanguages(options?: AxiosRequestConfig) {
    return LanguagesApiFp(this.configuration)
      .getApplicationLanguages(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ISO languages provides a list of all languages (eg. used for autocompletion in metadata editor).
   * @summary Get ISO languages
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LanguagesApi
   */
  public getIsoLanguages(options?: AxiosRequestConfig) {
    return LanguagesApiFp(this.configuration)
      .getIsoLanguages(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Languages for the application having translations in the database. All tables with \'Desc\' suffix contains translation for some domain objects like groups, tags, ...
   * @summary Get languages
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LanguagesApi
   */
  public getLanguages(options?: AxiosRequestConfig) {
    return LanguagesApiFp(this.configuration)
      .getLanguages(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LinksApi - axios parameter creator
 * @export
 */
export const LinksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * One of uuids or bucket parameter is required if not an Administrator. Only records that you can edit will be validated.
     * @summary Analyze records links
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [removeFirst] Only allowed if Administrator.
     * @param {boolean} [analyze]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeRecordLinks: async (
      uuids?: Array<string>,
      bucket?: string,
      removeFirst?: boolean,
      analyze?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (removeFirst !== undefined) {
        localVarQueryParameter['removeFirst'] = removeFirst;
      }

      if (analyze !== undefined) {
        localVarQueryParameter['analyze'] = analyze;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record links
     * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
     * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
     * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
     * @param {number} [page] Results page you want to retrieve (0..N)
     * @param {number} [size] Number of records per page.
     * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordLinks: async (
      filter?: object,
      groupIdFilter?: Array<number>,
      groupOwnerIdFilter?: Array<number>,
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (groupIdFilter) {
        localVarQueryParameter['groupIdFilter'] = groupIdFilter;
      }

      if (groupOwnerIdFilter) {
        localVarQueryParameter['groupOwnerIdFilter'] = groupOwnerIdFilter;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get record links as CSV
     * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
     * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
     * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
     * @param {number} [page] Results page you want to retrieve (0..N)
     * @param {number} [size] Number of records per page.
     * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordLinksAsCsv: async (
      filter?: object,
      groupIdFilter?: Array<number>,
      groupOwnerIdFilter?: Array<number>,
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/links/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (groupIdFilter) {
        localVarQueryParameter['groupIdFilter'] = groupIdFilter;
      }

      if (groupOwnerIdFilter) {
        localVarQueryParameter['groupOwnerIdFilter'] = groupOwnerIdFilter;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove all links and status history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purgeAll: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LinksApi - functional programming interface
 * @export
 */
export const LinksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LinksApiAxiosParamCreator(configuration);
  return {
    /**
     * One of uuids or bucket parameter is required if not an Administrator. Only records that you can edit will be validated.
     * @summary Analyze records links
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [removeFirst] Only allowed if Administrator.
     * @param {boolean} [analyze]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async analyzeRecordLinks(
      uuids?: Array<string>,
      bucket?: string,
      removeFirst?: boolean,
      analyze?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.analyzeRecordLinks(
          uuids,
          bucket,
          removeFirst,
          analyze,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record links
     * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
     * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
     * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
     * @param {number} [page] Results page you want to retrieve (0..N)
     * @param {number} [size] Number of records per page.
     * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordLinks(
      filter?: object,
      groupIdFilter?: Array<number>,
      groupOwnerIdFilter?: Array<number>,
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageLink>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordLinks(
        filter,
        groupIdFilter,
        groupOwnerIdFilter,
        page,
        size,
        sort,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get record links as CSV
     * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
     * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
     * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
     * @param {number} [page] Results page you want to retrieve (0..N)
     * @param {number} [size] Number of records per page.
     * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordLinksAsCsv(
      filter?: object,
      groupIdFilter?: Array<number>,
      groupOwnerIdFilter?: Array<number>,
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordLinksAsCsv(
          filter,
          groupIdFilter,
          groupOwnerIdFilter,
          page,
          size,
          sort,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove all links and status history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purgeAll(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purgeAll(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LinksApi - factory interface
 * @export
 */
export const LinksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LinksApiFp(configuration);
  return {
    /**
     * One of uuids or bucket parameter is required if not an Administrator. Only records that you can edit will be validated.
     * @summary Analyze records links
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [removeFirst] Only allowed if Administrator.
     * @param {boolean} [analyze]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    analyzeRecordLinks(
      uuids?: Array<string>,
      bucket?: string,
      removeFirst?: boolean,
      analyze?: boolean,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .analyzeRecordLinks(uuids, bucket, removeFirst, analyze, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record links
     * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
     * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
     * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
     * @param {number} [page] Results page you want to retrieve (0..N)
     * @param {number} [size] Number of records per page.
     * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordLinks(
      filter?: object,
      groupIdFilter?: Array<number>,
      groupOwnerIdFilter?: Array<number>,
      page?: number,
      size?: number,
      sort?: string,
      options?: any
    ): AxiosPromise<PageLink> {
      return localVarFp
        .getRecordLinks(
          filter,
          groupIdFilter,
          groupOwnerIdFilter,
          page,
          size,
          sort,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get record links as CSV
     * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
     * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
     * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
     * @param {number} [page] Results page you want to retrieve (0..N)
     * @param {number} [size] Number of records per page.
     * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordLinksAsCsv(
      filter?: object,
      groupIdFilter?: Array<number>,
      groupOwnerIdFilter?: Array<number>,
      page?: number,
      size?: number,
      sort?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordLinksAsCsv(
          filter,
          groupIdFilter,
          groupOwnerIdFilter,
          page,
          size,
          sort,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove all links and status history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purgeAll(options?: any): AxiosPromise<string> {
      return localVarFp
        .purgeAll(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LinksApi - object-oriented interface
 * @export
 * @class LinksApi
 * @extends {BaseAPI}
 */
export class LinksApi extends BaseAPI {
  /**
   * One of uuids or bucket parameter is required if not an Administrator. Only records that you can edit will be validated.
   * @summary Analyze records links
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [removeFirst] Only allowed if Administrator.
   * @param {boolean} [analyze]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public analyzeRecordLinks(
    uuids?: Array<string>,
    bucket?: string,
    removeFirst?: boolean,
    analyze?: boolean,
    options?: AxiosRequestConfig
  ) {
    return LinksApiFp(this.configuration)
      .analyzeRecordLinks(uuids, bucket, removeFirst, analyze, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record links
   * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
   * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
   * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
   * @param {number} [page] Results page you want to retrieve (0..N)
   * @param {number} [size] Number of records per page.
   * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public getRecordLinks(
    filter?: object,
    groupIdFilter?: Array<number>,
    groupOwnerIdFilter?: Array<number>,
    page?: number,
    size?: number,
    sort?: string,
    options?: AxiosRequestConfig
  ) {
    return LinksApiFp(this.configuration)
      .getRecordLinks(
        filter,
        groupIdFilter,
        groupOwnerIdFilter,
        page,
        size,
        sort,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get record links as CSV
   * @param {object} [filter] Filter, e.g. \&quot;{url: \&#39;png\&#39;, lastState: \&#39;ko\&#39;, records: \&#39;e421\&#39;, groupId: 12}\&quot;, lastState being \&#39;ok\&#39;/\&#39;ko\&#39;/\&#39;unknown\&#39;
   * @param {Array<number>} [groupIdFilter] Optional, filter links to records published in that group.
   * @param {Array<number>} [groupOwnerIdFilter] Optional, filter links to records created in that group.
   * @param {number} [page] Results page you want to retrieve (0..N)
   * @param {number} [size] Number of records per page.
   * @param {string} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public getRecordLinksAsCsv(
    filter?: object,
    groupIdFilter?: Array<number>,
    groupOwnerIdFilter?: Array<number>,
    page?: number,
    size?: number,
    sort?: string,
    options?: AxiosRequestConfig
  ) {
    return LinksApiFp(this.configuration)
      .getRecordLinksAsCsv(
        filter,
        groupIdFilter,
        groupOwnerIdFilter,
        page,
        size,
        sort,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove all links and status history
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinksApi
   */
  public purgeAll(options?: AxiosRequestConfig) {
    return LinksApiFp(this.configuration)
      .purgeAll(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LogosApi - axios parameter creator
 * @export
 */
export const LogosApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add a logo
     * @param {Array<any>} file The logo image to upload
     * @param {boolean} [overwrite] Overwrite if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLogo: async (
      file: Array<any>,
      overwrite?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('addLogo', 'file', file);
      const localVarPath = `/logos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (file) {
        localVarQueryParameter['file'] = file;
      }

      if (overwrite !== undefined) {
        localVarQueryParameter['overwrite'] = overwrite;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a logo
     * @param {string} file The logo filename to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLogo: async (
      file: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('deleteLogo', 'file', file);
      const localVarPath = `/logos/{file}`.replace(
        `{${'file'}}`,
        encodeURIComponent(String(file))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Logos are used for the catalog, the groups logos, and harvester icons. Logos are stored in the data directory in <dataDirectory>/resources/images/harvesting.<br/> Records are attached to a source. A source can be the local catalog or a harvester node. When a source is created, its logo is located in the images/logos folder with the source UUID as filename. For some sources the logo can be automatically retrieved (eg. when harvesting GeoNetwork catalogs). For others, the logo is usually manually defined when configuring the harvester.
     * @summary Get all logos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogos: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/logos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogosApi - functional programming interface
 * @export
 */
export const LogosApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogosApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add a logo
     * @param {Array<any>} file The logo image to upload
     * @param {boolean} [overwrite] Overwrite if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addLogo(
      file: Array<any>,
      overwrite?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addLogo(
        file,
        overwrite,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a logo
     * @param {string} file The logo filename to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLogo(
      file: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLogo(
        file,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Logos are used for the catalog, the groups logos, and harvester icons. Logos are stored in the data directory in <dataDirectory>/resources/images/harvesting.<br/> Records are attached to a source. A source can be the local catalog or a harvester node. When a source is created, its logo is located in the images/logos folder with the source UUID as filename. For some sources the logo can be automatically retrieved (eg. when harvesting GeoNetwork catalogs). For others, the logo is usually manually defined when configuring the harvester.
     * @summary Get all logos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogos(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogos(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LogosApi - factory interface
 * @export
 */
export const LogosApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LogosApiFp(configuration);
  return {
    /**
     *
     * @summary Add a logo
     * @param {Array<any>} file The logo image to upload
     * @param {boolean} [overwrite] Overwrite if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLogo(
      file: Array<any>,
      overwrite?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .addLogo(file, overwrite, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a logo
     * @param {string} file The logo filename to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLogo(file: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteLogo(file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Logos are used for the catalog, the groups logos, and harvester icons. Logos are stored in the data directory in <dataDirectory>/resources/images/harvesting.<br/> Records are attached to a source. A source can be the local catalog or a harvester node. When a source is created, its logo is located in the images/logos folder with the source UUID as filename. For some sources the logo can be automatically retrieved (eg. when harvesting GeoNetwork catalogs). For others, the logo is usually manually defined when configuring the harvester.
     * @summary Get all logos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogos(options?: any): AxiosPromise<Set<string>> {
      return localVarFp
        .getLogos(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LogosApi - object-oriented interface
 * @export
 * @class LogosApi
 * @extends {BaseAPI}
 */
export class LogosApi extends BaseAPI {
  /**
   *
   * @summary Add a logo
   * @param {Array<any>} file The logo image to upload
   * @param {boolean} [overwrite] Overwrite if exists
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogosApi
   */
  public addLogo(
    file: Array<any>,
    overwrite?: boolean,
    options?: AxiosRequestConfig
  ) {
    return LogosApiFp(this.configuration)
      .addLogo(file, overwrite, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a logo
   * @param {string} file The logo filename to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogosApi
   */
  public deleteLogo(file: string, options?: AxiosRequestConfig) {
    return LogosApiFp(this.configuration)
      .deleteLogo(file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Logos are used for the catalog, the groups logos, and harvester icons. Logos are stored in the data directory in <dataDirectory>/resources/images/harvesting.<br/> Records are attached to a source. A source can be the local catalog or a harvester node. When a source is created, its logo is located in the images/logos folder with the source UUID as filename. For some sources the logo can be automatically retrieved (eg. when harvesting GeoNetwork catalogs). For others, the logo is usually manually defined when configuring the harvester.
   * @summary Get all logos
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogosApi
   */
  public getLogos(options?: AxiosRequestConfig) {
    return LogosApiFp(this.configuration)
      .getLogos(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MapserversApi - axios parameter creator
 * @export
 */
export const MapserversApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return the id of the newly created mapserver.
     * @summary Add a mapserver
     * @param {MapServer} mapServer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMapserver: async (
      mapServer: MapServer,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapServer' is not null or undefined
      assertParamExists('addMapserver', 'mapServer', mapServer);
      const localVarPath = `/mapservers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mapServer,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a mapserver
     * @param {number} mapserverId Mapserver identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMapserver: async (
      mapserverId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapserverId' is not null or undefined
      assertParamExists('deleteMapserver', 'mapserverId', mapserverId);
      const localVarPath = `/mapservers/{mapserverId}`.replace(
        `{${'mapserverId'}}`,
        encodeURIComponent(String(mapserverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a metadata mapserver resource
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMapserverResource: async (
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapserverId' is not null or undefined
      assertParamExists('deleteMapserverResource', 'mapserverId', mapserverId);
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'deleteMapserverResource',
        'metadataUuid',
        metadataUuid
      );
      // verify required parameter 'resource' is not null or undefined
      assertParamExists('deleteMapserverResource', 'resource', resource);
      const localVarPath = `/mapservers/{mapserverId}/records/{metadataUuid}`
        .replace(`{${'mapserverId'}}`, encodeURIComponent(String(mapserverId)))
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (resource !== undefined) {
        localVarQueryParameter['resource'] = resource;
      }

      if (metadataTitle !== undefined) {
        localVarQueryParameter['metadataTitle'] = metadataTitle;
      }

      if (metadataAbstract !== undefined) {
        localVarQueryParameter['metadataAbstract'] = metadataAbstract;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a mapserver
     * @param {string} mapserverId Mapserver identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMapserver: async (
      mapserverId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapserverId' is not null or undefined
      assertParamExists('getMapserver', 'mapserverId', mapserverId);
      const localVarPath = `/mapservers/{mapserverId}`.replace(
        `{${'mapserverId'}}`,
        encodeURIComponent(String(mapserverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check metadata mapserver resource is published
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMapserverResource: async (
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapserverId' is not null or undefined
      assertParamExists('getMapserverResource', 'mapserverId', mapserverId);
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getMapserverResource', 'metadataUuid', metadataUuid);
      // verify required parameter 'resource' is not null or undefined
      assertParamExists('getMapserverResource', 'resource', resource);
      const localVarPath = `/mapservers/{mapserverId}/records/{metadataUuid}`
        .replace(`{${'mapserverId'}}`, encodeURIComponent(String(mapserverId)))
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (resource !== undefined) {
        localVarQueryParameter['resource'] = resource;
      }

      if (metadataTitle !== undefined) {
        localVarQueryParameter['metadataTitle'] = metadataTitle;
      }

      if (metadataAbstract !== undefined) {
        localVarQueryParameter['metadataAbstract'] = metadataAbstract;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Mapservers are used by the catalog to publish record attachments (eg. ZIP file with shape) or record associated resources (eg. database table, file on the local network) in a remote mapserver like GeoServer or MapServer. The catalog communicate with the mapserver using GeoServer REST API.
     * @summary Get mapservers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMapservers: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mapservers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Publish a metadata resource in a mapserver
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishMapserverResource: async (
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapserverId' is not null or undefined
      assertParamExists('publishMapserverResource', 'mapserverId', mapserverId);
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'publishMapserverResource',
        'metadataUuid',
        metadataUuid
      );
      // verify required parameter 'resource' is not null or undefined
      assertParamExists('publishMapserverResource', 'resource', resource);
      const localVarPath = `/mapservers/{mapserverId}/records/{metadataUuid}`
        .replace(`{${'mapserverId'}}`, encodeURIComponent(String(mapserverId)))
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (resource !== undefined) {
        localVarQueryParameter['resource'] = resource;
      }

      if (metadataTitle !== undefined) {
        localVarQueryParameter['metadataTitle'] = metadataTitle;
      }

      if (metadataAbstract !== undefined) {
        localVarQueryParameter['metadataAbstract'] = metadataAbstract;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The remote mapserver REST API may require basic authentication. This operation set the username and password.
     * @summary Update a mapserver authentication
     * @param {number} mapserverId Mapserver identifier
     * @param {string} username User name
     * @param {string} password Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMapserver: async (
      mapserverId: number,
      username: string,
      password: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapserverId' is not null or undefined
      assertParamExists('updateMapserver', 'mapserverId', mapserverId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists('updateMapserver', 'username', username);
      // verify required parameter 'password' is not null or undefined
      assertParamExists('updateMapserver', 'password', password);
      const localVarPath = `/mapservers/{mapserverId}/auth`.replace(
        `{${'mapserverId'}}`,
        encodeURIComponent(String(mapserverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a mapserver
     * @param {number} mapserverId Mapserver identifier
     * @param {MapServer} mapServer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMapserver1: async (
      mapserverId: number,
      mapServer: MapServer,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mapserverId' is not null or undefined
      assertParamExists('updateMapserver1', 'mapserverId', mapserverId);
      // verify required parameter 'mapServer' is not null or undefined
      assertParamExists('updateMapserver1', 'mapServer', mapServer);
      const localVarPath = `/mapservers/{mapserverId}`.replace(
        `{${'mapserverId'}}`,
        encodeURIComponent(String(mapserverId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mapServer,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MapserversApi - functional programming interface
 * @export
 */
export const MapserversApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MapserversApiAxiosParamCreator(configuration);
  return {
    /**
     * Return the id of the newly created mapserver.
     * @summary Add a mapserver
     * @param {MapServer} mapServer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addMapserver(
      mapServer: MapServer,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addMapserver(
        mapServer,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a mapserver
     * @param {number} mapserverId Mapserver identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMapserver(
      mapserverId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMapserver(
        mapserverId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a metadata mapserver resource
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMapserverResource(
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteMapserverResource(
          mapserverId,
          metadataUuid,
          resource,
          metadataTitle,
          metadataAbstract,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a mapserver
     * @param {string} mapserverId Mapserver identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMapserver(
      mapserverId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMapserver(
        mapserverId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Check metadata mapserver resource is published
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMapserverResource(
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMapserverResource(
          mapserverId,
          metadataUuid,
          resource,
          metadataTitle,
          metadataAbstract,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Mapservers are used by the catalog to publish record attachments (eg. ZIP file with shape) or record associated resources (eg. database table, file on the local network) in a remote mapserver like GeoServer or MapServer. The catalog communicate with the mapserver using GeoServer REST API.
     * @summary Get mapservers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMapservers(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMapservers(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Publish a metadata resource in a mapserver
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishMapserverResource(
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.publishMapserverResource(
          mapserverId,
          metadataUuid,
          resource,
          metadataTitle,
          metadataAbstract,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The remote mapserver REST API may require basic authentication. This operation set the username and password.
     * @summary Update a mapserver authentication
     * @param {number} mapserverId Mapserver identifier
     * @param {string} username User name
     * @param {string} password Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMapserver(
      mapserverId: number,
      username: string,
      password: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMapserver(
        mapserverId,
        username,
        password,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a mapserver
     * @param {number} mapserverId Mapserver identifier
     * @param {MapServer} mapServer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMapserver1(
      mapserverId: number,
      mapServer: MapServer,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateMapserver1(
          mapserverId,
          mapServer,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * MapserversApi - factory interface
 * @export
 */
export const MapserversApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MapserversApiFp(configuration);
  return {
    /**
     * Return the id of the newly created mapserver.
     * @summary Add a mapserver
     * @param {MapServer} mapServer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMapserver(mapServer: MapServer, options?: any): AxiosPromise<number> {
      return localVarFp
        .addMapserver(mapServer, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a mapserver
     * @param {number} mapserverId Mapserver identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMapserver(mapserverId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteMapserver(mapserverId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a metadata mapserver resource
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMapserverResource(
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteMapserverResource(
          mapserverId,
          metadataUuid,
          resource,
          metadataTitle,
          metadataAbstract,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a mapserver
     * @param {string} mapserverId Mapserver identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMapserver(mapserverId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getMapserver(mapserverId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check metadata mapserver resource is published
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMapserverResource(
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getMapserverResource(
          mapserverId,
          metadataUuid,
          resource,
          metadataTitle,
          metadataAbstract,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Mapservers are used by the catalog to publish record attachments (eg. ZIP file with shape) or record associated resources (eg. database table, file on the local network) in a remote mapserver like GeoServer or MapServer. The catalog communicate with the mapserver using GeoServer REST API.
     * @summary Get mapservers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMapservers(options?: any): AxiosPromise<void> {
      return localVarFp
        .getMapservers(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Publish a metadata resource in a mapserver
     * @param {string} mapserverId Mapserver identifier
     * @param {string} metadataUuid Record UUID.
     * @param {string} resource Resource name (could be a file or a db connection)
     * @param {string} [metadataTitle] Metadata title
     * @param {string} [metadataAbstract] Metadata abstract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishMapserverResource(
      mapserverId: string,
      metadataUuid: string,
      resource: string,
      metadataTitle?: string,
      metadataAbstract?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .publishMapserverResource(
          mapserverId,
          metadataUuid,
          resource,
          metadataTitle,
          metadataAbstract,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The remote mapserver REST API may require basic authentication. This operation set the username and password.
     * @summary Update a mapserver authentication
     * @param {number} mapserverId Mapserver identifier
     * @param {string} username User name
     * @param {string} password Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMapserver(
      mapserverId: number,
      username: string,
      password: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateMapserver(mapserverId, username, password, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a mapserver
     * @param {number} mapserverId Mapserver identifier
     * @param {MapServer} mapServer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMapserver1(
      mapserverId: number,
      mapServer: MapServer,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateMapserver1(mapserverId, mapServer, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MapserversApi - object-oriented interface
 * @export
 * @class MapserversApi
 * @extends {BaseAPI}
 */
export class MapserversApi extends BaseAPI {
  /**
   * Return the id of the newly created mapserver.
   * @summary Add a mapserver
   * @param {MapServer} mapServer
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public addMapserver(mapServer: MapServer, options?: AxiosRequestConfig) {
    return MapserversApiFp(this.configuration)
      .addMapserver(mapServer, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a mapserver
   * @param {number} mapserverId Mapserver identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public deleteMapserver(mapserverId: number, options?: AxiosRequestConfig) {
    return MapserversApiFp(this.configuration)
      .deleteMapserver(mapserverId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a metadata mapserver resource
   * @param {string} mapserverId Mapserver identifier
   * @param {string} metadataUuid Record UUID.
   * @param {string} resource Resource name (could be a file or a db connection)
   * @param {string} [metadataTitle] Metadata title
   * @param {string} [metadataAbstract] Metadata abstract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public deleteMapserverResource(
    mapserverId: string,
    metadataUuid: string,
    resource: string,
    metadataTitle?: string,
    metadataAbstract?: string,
    options?: AxiosRequestConfig
  ) {
    return MapserversApiFp(this.configuration)
      .deleteMapserverResource(
        mapserverId,
        metadataUuid,
        resource,
        metadataTitle,
        metadataAbstract,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a mapserver
   * @param {string} mapserverId Mapserver identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public getMapserver(mapserverId: string, options?: AxiosRequestConfig) {
    return MapserversApiFp(this.configuration)
      .getMapserver(mapserverId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check metadata mapserver resource is published
   * @param {string} mapserverId Mapserver identifier
   * @param {string} metadataUuid Record UUID.
   * @param {string} resource Resource name (could be a file or a db connection)
   * @param {string} [metadataTitle] Metadata title
   * @param {string} [metadataAbstract] Metadata abstract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public getMapserverResource(
    mapserverId: string,
    metadataUuid: string,
    resource: string,
    metadataTitle?: string,
    metadataAbstract?: string,
    options?: AxiosRequestConfig
  ) {
    return MapserversApiFp(this.configuration)
      .getMapserverResource(
        mapserverId,
        metadataUuid,
        resource,
        metadataTitle,
        metadataAbstract,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Mapservers are used by the catalog to publish record attachments (eg. ZIP file with shape) or record associated resources (eg. database table, file on the local network) in a remote mapserver like GeoServer or MapServer. The catalog communicate with the mapserver using GeoServer REST API.
   * @summary Get mapservers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public getMapservers(options?: AxiosRequestConfig) {
    return MapserversApiFp(this.configuration)
      .getMapservers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Publish a metadata resource in a mapserver
   * @param {string} mapserverId Mapserver identifier
   * @param {string} metadataUuid Record UUID.
   * @param {string} resource Resource name (could be a file or a db connection)
   * @param {string} [metadataTitle] Metadata title
   * @param {string} [metadataAbstract] Metadata abstract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public publishMapserverResource(
    mapserverId: string,
    metadataUuid: string,
    resource: string,
    metadataTitle?: string,
    metadataAbstract?: string,
    options?: AxiosRequestConfig
  ) {
    return MapserversApiFp(this.configuration)
      .publishMapserverResource(
        mapserverId,
        metadataUuid,
        resource,
        metadataTitle,
        metadataAbstract,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The remote mapserver REST API may require basic authentication. This operation set the username and password.
   * @summary Update a mapserver authentication
   * @param {number} mapserverId Mapserver identifier
   * @param {string} username User name
   * @param {string} password Password
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public updateMapserver(
    mapserverId: number,
    username: string,
    password: string,
    options?: AxiosRequestConfig
  ) {
    return MapserversApiFp(this.configuration)
      .updateMapserver(mapserverId, username, password, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a mapserver
   * @param {number} mapserverId Mapserver identifier
   * @param {MapServer} mapServer
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapserversApi
   */
  public updateMapserver1(
    mapserverId: number,
    mapServer: MapServer,
    options?: AxiosRequestConfig
  ) {
    return MapserversApiFp(this.configuration)
      .updateMapserver1(mapserverId, mapServer, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * If not authenticated, return status 204 (NO_CONTENT), else return basic user information. This operation is usually used to know if current user is authenticated or not.It returns also info about groups and profiles.
     * @summary Get information about me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration);
  return {
    /**
     * If not authenticated, return status 204 (NO_CONTENT), else return basic user information. This operation is usually used to know if current user is authenticated or not.It returns also info about groups and profiles.
     * @summary Get information about me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMe(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MeApiFp(configuration);
  return {
    /**
     * If not authenticated, return status 204 (NO_CONTENT), else return basic user information. This operation is usually used to know if current user is authenticated or not.It returns also info about groups and profiles.
     * @summary Get information about me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMe(options?: any): AxiosPromise<MeResponse> {
      return localVarFp
        .getMe(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
  /**
   * If not authenticated, return status 204 (NO_CONTENT), else return basic user information. This operation is usually used to know if current user is authenticated or not.It returns also info about groups and profiles.
   * @summary Get information about me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeApi
   */
  public getMe(options?: AxiosRequestConfig) {
    return MeApiFp(this.configuration)
      .getMe(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OperationsApi - axios parameter creator
 * @export
 */
export const OperationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return the list of operations. Operations are used to define authorization per group. Extending the list of default operations (ie. view, dynamic, download, editing, notify, featured) might be feasible but is experimental.<br/> Featured is not really used anymore (was used in past version for home page highlights).
     * @summary Get operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OperationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return the list of operations. Operations are used to define authorization per group. Extending the list of default operations (ie. view, dynamic, download, editing, notify, featured) might be feasible but is experimental.<br/> Featured is not really used anymore (was used in past version for home page highlights).
     * @summary Get operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperations(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Operation>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOperations(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OperationsApiFp(configuration);
  return {
    /**
     * Return the list of operations. Operations are used to define authorization per group. Extending the list of default operations (ie. view, dynamic, download, editing, notify, featured) might be feasible but is experimental.<br/> Featured is not really used anymore (was used in past version for home page highlights).
     * @summary Get operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperations(options?: any): AxiosPromise<Array<Operation>> {
      return localVarFp
        .getOperations(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
  /**
   * Return the list of operations. Operations are used to define authorization per group. Extending the list of default operations (ie. view, dynamic, download, editing, notify, featured) might be feasible but is experimental.<br/> Featured is not really used anymore (was used in past version for home page highlights).
   * @summary Get operations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OperationsApi
   */
  public getOperations(options?: AxiosRequestConfig) {
    return OperationsApiFp(this.configuration)
      .getOperations(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PagesApi - axios parameter creator
 * @export
 */
export const PagesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Add a new Page object in DRAFT section in status HIDDEN
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {string} [link]
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPage: async (
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      link?: string,
      inlineObject?: InlineObject,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('addPage', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('addPage', 'pageId', pageId);
      // verify required parameter 'format' is not null or undefined
      assertParamExists('addPage', 'format', format);
      const localVarPath = `/pages/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (language !== undefined) {
        localVarQueryParameter['language'] = language;
      }

      if (pageId !== undefined) {
        localVarQueryParameter['pageId'] = pageId;
      }

      if (link !== undefined) {
        localVarQueryParameter['link'] = link;
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Adds the page to a section. This means that the link to the page will be shown in the list associated to that section.
     * @param {string} language
     * @param {string} pageId
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPageToSection: async (
      language: string,
      pageId: string,
      section:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('addPageToSection', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('addPageToSection', 'pageId', pageId);
      // verify required parameter 'section' is not null or undefined
      assertParamExists('addPageToSection', 'section', section);
      const localVarPath = `/pages/{language}/{pageId}/{section}`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)))
        .replace(`{${'section'}}`, encodeURIComponent(String(section)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Changes the status of a page.
     * @param {string} language
     * @param {string} pageId
     * @param {'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN'} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePageStatus: async (
      language: string,
      pageId: string,
      status: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('changePageStatus', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('changePageStatus', 'pageId', pageId);
      // verify required parameter 'status' is not null or undefined
      assertParamExists('changePageStatus', 'status', status);
      const localVarPath = `/pages/{language}/{pageId}/{status}`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)))
        .replace(`{${'status'}}`, encodeURIComponent(String(status)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Delete a Page object
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePage: async (
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('deletePage', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('deletePage', 'pageId', pageId);
      // verify required parameter 'format' is not null or undefined
      assertParamExists('deletePage', 'format', format);
      const localVarPath = `/pages/{language}/{pageId}`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Edit a Page content and format
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {string} [link]
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPage: async (
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      link?: string,
      inlineObject1?: InlineObject1,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('editPage', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('editPage', 'pageId', pageId);
      // verify required parameter 'format' is not null or undefined
      assertParamExists('editPage', 'format', format);
      const localVarPath = `/pages/{language}/{pageId}`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (link !== undefined) {
        localVarQueryParameter['link'] = link;
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject1,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Edit a Page name and language
     * @param {string} language
     * @param {string} pageId
     * @param {string} [newLanguage]
     * @param {string} [newPageId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPageName: async (
      language: string,
      pageId: string,
      newLanguage?: string,
      newPageId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('editPageName', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('editPageName', 'pageId', pageId);
      const localVarPath = `/pages/{language}/{pageId}`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (newLanguage !== undefined) {
        localVarQueryParameter['newLanguage'] = newLanguage;
      }

      if (newPageId !== undefined) {
        localVarQueryParameter['newPageId'] = newPageId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Return the page object details except the content
     * @param {string} language
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPage: async (
      language: string,
      pageId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('getPage', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('getPage', 'pageId', pageId);
      const localVarPath = `/pages/{language}/{pageId}`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Return the static html content identified by pageId
     * @param {string} language
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageContent: async (
      language: string,
      pageId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('getPageContent', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('getPageContent', 'pageId', pageId);
      const localVarPath = `/pages/{language}/{pageId}/content`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary List all pages according to the filters
     * @param {string} [language]
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} [section]
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} [format]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPages: async (
      language?: string,
      section?:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      format?: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/pages/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (language !== undefined) {
        localVarQueryParameter['language'] = language;
      }

      if (section !== undefined) {
        localVarQueryParameter['section'] = section;
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Removes the page from a section. This means that the link to the page will not be shown in the list associated to that section.
     * @param {string} language
     * @param {string} pageId
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePageFromSection: async (
      language: string,
      pageId: string,
      section:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('removePageFromSection', 'language', language);
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists('removePageFromSection', 'pageId', pageId);
      // verify required parameter 'section' is not null or undefined
      assertParamExists('removePageFromSection', 'section', section);
      const localVarPath = `/pages/{language}/{pageId}/{section}`
        .replace(`{${'language'}}`, encodeURIComponent(String(language)))
        .replace(`{${'pageId'}}`, encodeURIComponent(String(pageId)))
        .replace(`{${'section'}}`, encodeURIComponent(String(section)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PagesApi - functional programming interface
 * @export
 */
export const PagesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PagesApiAxiosParamCreator(configuration);
  return {
    /**
     * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Add a new Page object in DRAFT section in status HIDDEN
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {string} [link]
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPage(
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      link?: string,
      inlineObject?: InlineObject,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addPage(
        language,
        pageId,
        format,
        link,
        inlineObject,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Adds the page to a section. This means that the link to the page will be shown in the list associated to that section.
     * @param {string} language
     * @param {string} pageId
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPageToSection(
      language: string,
      pageId: string,
      section:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addPageToSection(
          language,
          pageId,
          section,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Changes the status of a page.
     * @param {string} language
     * @param {string} pageId
     * @param {'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN'} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePageStatus(
      language: string,
      pageId: string,
      status: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.changePageStatus(
          language,
          pageId,
          status,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Delete a Page object
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePage(
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePage(
        language,
        pageId,
        format,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Edit a Page content and format
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {string} [link]
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editPage(
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      link?: string,
      inlineObject1?: InlineObject1,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editPage(
        language,
        pageId,
        format,
        link,
        inlineObject1,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Edit a Page name and language
     * @param {string} language
     * @param {string} pageId
     * @param {string} [newLanguage]
     * @param {string} [newPageId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editPageName(
      language: string,
      pageId: string,
      newLanguage?: string,
      newPageId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editPageName(
        language,
        pageId,
        newLanguage,
        newPageId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Return the page object details except the content
     * @param {string} language
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPage(
      language: string,
      pageId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageJSONWrapper>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPage(
        language,
        pageId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Return the static html content identified by pageId
     * @param {string} language
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageContent(
      language: string,
      pageId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageContent(
        language,
        pageId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary List all pages according to the filters
     * @param {string} [language]
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} [section]
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} [format]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPages(
      language?: string,
      section?:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      format?: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPages(
        language,
        section,
        format,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Removes the page from a section. This means that the link to the page will not be shown in the list associated to that section.
     * @param {string} language
     * @param {string} pageId
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePageFromSection(
      language: string,
      pageId: string,
      section:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removePageFromSection(
          language,
          pageId,
          section,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PagesApi - factory interface
 * @export
 */
export const PagesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PagesApiFp(configuration);
  return {
    /**
     * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Add a new Page object in DRAFT section in status HIDDEN
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {string} [link]
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPage(
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      link?: string,
      inlineObject?: InlineObject,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addPage(language, pageId, format, link, inlineObject, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Adds the page to a section. This means that the link to the page will be shown in the list associated to that section.
     * @param {string} language
     * @param {string} pageId
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPageToSection(
      language: string,
      pageId: string,
      section:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addPageToSection(language, pageId, section, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Changes the status of a page.
     * @param {string} language
     * @param {string} pageId
     * @param {'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN'} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePageStatus(
      language: string,
      pageId: string,
      status: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .changePageStatus(language, pageId, status, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Delete a Page object
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePage(
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deletePage(language, pageId, format, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Edit a Page content and format
     * @param {string} language
     * @param {string} pageId
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
     * @param {string} [link]
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPage(
      language: string,
      pageId: string,
      format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      link?: string,
      inlineObject1?: InlineObject1,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .editPage(language, pageId, format, link, inlineObject1, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Edit a Page name and language
     * @param {string} language
     * @param {string} pageId
     * @param {string} [newLanguage]
     * @param {string} [newPageId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPageName(
      language: string,
      pageId: string,
      newLanguage?: string,
      newPageId?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .editPageName(language, pageId, newLanguage, newPageId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Return the page object details except the content
     * @param {string} language
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPage(
      language: string,
      pageId: string,
      options?: any
    ): AxiosPromise<PageJSONWrapper> {
      return localVarFp
        .getPage(language, pageId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Return the static html content identified by pageId
     * @param {string} language
     * @param {string} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageContent(
      language: string,
      pageId: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getPageContent(language, pageId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary List all pages according to the filters
     * @param {string} [language]
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} [section]
     * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} [format]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPages(
      language?: string,
      section?:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      format?: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .listPages(language, section, format, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
     * @summary Removes the page from a section. This means that the link to the page will not be shown in the list associated to that section.
     * @param {string} language
     * @param {string} pageId
     * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePageFromSection(
      language: string,
      pageId: string,
      section:
        | 'ALL'
        | 'TOP'
        | 'FOOTER'
        | 'MENU'
        | 'SUBMENU'
        | 'CUSTOM_MENU1'
        | 'CUSTOM_MENU2'
        | 'CUSTOM_MENU3'
        | 'DRAFT',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removePageFromSection(language, pageId, section, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PagesApi - object-oriented interface
 * @export
 * @class PagesApi
 * @extends {BaseAPI}
 */
export class PagesApi extends BaseAPI {
  /**
   * <p>Is not possible to load a link and a file at the same time.</p> <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Add a new Page object in DRAFT section in status HIDDEN
   * @param {string} language
   * @param {string} pageId
   * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
   * @param {string} [link]
   * @param {InlineObject} [inlineObject]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public addPage(
    language: string,
    pageId: string,
    format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
    link?: string,
    inlineObject?: InlineObject,
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .addPage(language, pageId, format, link, inlineObject, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Adds the page to a section. This means that the link to the page will be shown in the list associated to that section.
   * @param {string} language
   * @param {string} pageId
   * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public addPageToSection(
    language: string,
    pageId: string,
    section:
      | 'ALL'
      | 'TOP'
      | 'FOOTER'
      | 'MENU'
      | 'SUBMENU'
      | 'CUSTOM_MENU1'
      | 'CUSTOM_MENU2'
      | 'CUSTOM_MENU3'
      | 'DRAFT',
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .addPageToSection(language, pageId, section, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Changes the status of a page.
   * @param {string} language
   * @param {string} pageId
   * @param {'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN'} status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public changePageStatus(
    language: string,
    pageId: string,
    status: 'PUBLIC' | 'PUBLIC_ONLY' | 'PRIVATE' | 'HIDDEN',
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .changePageStatus(language, pageId, status, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Delete a Page object
   * @param {string} language
   * @param {string} pageId
   * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public deletePage(
    language: string,
    pageId: string,
    format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .deletePage(language, pageId, format, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Edit a Page content and format
   * @param {string} language
   * @param {string} pageId
   * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} format
   * @param {string} [link]
   * @param {InlineObject1} [inlineObject1]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public editPage(
    language: string,
    pageId: string,
    format: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
    link?: string,
    inlineObject1?: InlineObject1,
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .editPage(language, pageId, format, link, inlineObject1, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Edit a Page name and language
   * @param {string} language
   * @param {string} pageId
   * @param {string} [newLanguage]
   * @param {string} [newPageId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public editPageName(
    language: string,
    pageId: string,
    newLanguage?: string,
    newPageId?: string,
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .editPageName(language, pageId, newLanguage, newPageId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Return the page object details except the content
   * @param {string} language
   * @param {string} pageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public getPage(
    language: string,
    pageId: string,
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .getPage(language, pageId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Return the static html content identified by pageId
   * @param {string} language
   * @param {string} pageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public getPageContent(
    language: string,
    pageId: string,
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .getPageContent(language, pageId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary List all pages according to the filters
   * @param {string} [language]
   * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} [section]
   * @param {'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI'} [format]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public listPages(
    language?: string,
    section?:
      | 'ALL'
      | 'TOP'
      | 'FOOTER'
      | 'MENU'
      | 'SUBMENU'
      | 'CUSTOM_MENU1'
      | 'CUSTOM_MENU2'
      | 'CUSTOM_MENU3'
      | 'DRAFT',
    format?: 'LINK' | 'HTML' | 'TEXT' | 'MARKDOWN' | 'WIKI',
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .listPages(language, section, format, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/4.0.x/eng/users/user-guide/define-static-pages/define-pages.html\'>More info</a>
   * @summary Removes the page from a section. This means that the link to the page will not be shown in the list associated to that section.
   * @param {string} language
   * @param {string} pageId
   * @param {'ALL' | 'TOP' | 'FOOTER' | 'MENU' | 'SUBMENU' | 'CUSTOM_MENU1' | 'CUSTOM_MENU2' | 'CUSTOM_MENU3' | 'DRAFT'} section
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PagesApi
   */
  public removePageFromSection(
    language: string,
    pageId: string,
    section:
      | 'ALL'
      | 'TOP'
      | 'FOOTER'
      | 'MENU'
      | 'SUBMENU'
      | 'CUSTOM_MENU1'
      | 'CUSTOM_MENU2'
      | 'CUSTOM_MENU3'
      | 'DRAFT',
    options?: AxiosRequestConfig
  ) {
    return PagesApiFp(this.configuration)
      .removePageFromSection(language, pageId, section, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProcessesApi - axios parameter creator
 * @export
 */
export const ProcessesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Clear process reports list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/processes/reports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
     * @summary Get current process reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessReport: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/processes/reports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview process result applied to one or more records
     * @param {string} process Process identifier
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [appendFirst] Append documents before processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessRecords: async (
      process: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      uuids?: Array<string>,
      bucket?: string,
      appendFirst?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'process' is not null or undefined
      assertParamExists('previewProcessRecords', 'process', process);
      const localVarPath = `/processes/{process}`.replace(
        `{${'process'}}`,
        encodeURIComponent(String(process))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (diffType !== undefined) {
        localVarQueryParameter['diffType'] = diffType;
      }

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (appendFirst !== undefined) {
        localVarQueryParameter['appendFirst'] = appendFirst;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview of search and replace text.
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessSearchAndReplace: async (
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'search' is not null or undefined
      assertParamExists('previewProcessSearchAndReplace', 'search', search);
      const localVarPath = `/processes/db/search-and-replace`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (useRegexp !== undefined) {
        localVarQueryParameter['useRegexp'] = useRegexp;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (replace !== undefined) {
        localVarQueryParameter['replace'] = replace;
      }

      if (regexpFlags !== undefined) {
        localVarQueryParameter['regexpFlags'] = regexpFlags;
      }

      if (diffType !== undefined) {
        localVarQueryParameter['diffType'] = diffType;
      }

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process to one or more records
     * @param {string} process Process identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecords: async (
      process: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'process' is not null or undefined
      assertParamExists('processRecords', 'process', process);
      const localVarPath = `/processes/{process}`.replace(
        `{${'process'}}`,
        encodeURIComponent(String(process))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (updateDateStamp !== undefined) {
        localVarQueryParameter['updateDateStamp'] = updateDateStamp;
      }

      if (index !== undefined) {
        localVarQueryParameter['index'] = index;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a database search and replace to one or more records
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processSearchAndReplace: async (
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'search' is not null or undefined
      assertParamExists('processSearchAndReplace', 'search', search);
      const localVarPath = `/processes/db/search-and-replace`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (useRegexp !== undefined) {
        localVarQueryParameter['useRegexp'] = useRegexp;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (replace !== undefined) {
        localVarQueryParameter['replace'] = replace;
      }

      if (regexpFlags !== undefined) {
        localVarQueryParameter['regexpFlags'] = regexpFlags;
      }

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (updateDateStamp !== undefined) {
        localVarQueryParameter['updateDateStamp'] = updateDateStamp;
      }

      if (index !== undefined) {
        localVarQueryParameter['index'] = index;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
     * @summary Search and replace values in one or more records
     * @param {string} [process]
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
     * @param {boolean} [isCaseInsensitive] Case insensitive search.
     * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAndReplace: async (
      process?: string,
      uuids?: Array<string>,
      bucket?: string,
      isTesting?: boolean,
      isCaseInsensitive?: boolean,
      vacuumMode?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/processes/search-and-replace`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (process !== undefined) {
        localVarQueryParameter['process'] = process;
      }

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (isTesting !== undefined) {
        localVarQueryParameter['isTesting'] = isTesting;
      }

      if (isCaseInsensitive !== undefined) {
        localVarQueryParameter['isCaseInsensitive'] = isCaseInsensitive;
      }

      if (vacuumMode !== undefined) {
        localVarQueryParameter['vacuumMode'] = vacuumMode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProcessesApi - functional programming interface
 * @export
 */
export const ProcessesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProcessesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Clear process reports list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
     * @summary Get current process reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProcessReport(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProcessingReport>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProcessReport(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview process result applied to one or more records
     * @param {string} process Process identifier
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [appendFirst] Append documents before processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewProcessRecords(
      process: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      uuids?: Array<string>,
      bucket?: string,
      appendFirst?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewProcessRecords(
          process,
          diffType,
          uuids,
          bucket,
          appendFirst,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *  When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview of search and replace text.
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewProcessSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewProcessSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          diffType,
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process to one or more records
     * @param {string} process Process identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processRecords(
      process: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<XsltMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.processRecords(
        process,
        uuids,
        bucket,
        updateDateStamp,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a database search and replace to one or more records
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<XsltMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.processSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          uuids,
          bucket,
          updateDateStamp,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
     * @summary Search and replace values in one or more records
     * @param {string} [process]
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
     * @param {boolean} [isCaseInsensitive] Case insensitive search.
     * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAndReplace(
      process?: string,
      uuids?: Array<string>,
      bucket?: string,
      isTesting?: boolean,
      isCaseInsensitive?: boolean,
      vacuumMode?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataReplacementProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchAndReplace(
          process,
          uuids,
          bucket,
          isTesting,
          isCaseInsensitive,
          vacuumMode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProcessesApi - factory interface
 * @export
 */
export const ProcessesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProcessesApiFp(configuration);
  return {
    /**
     *
     * @summary Clear process reports list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(options?: any): AxiosPromise<void> {
      return localVarFp
        ._delete(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
     * @summary Get current process reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProcessReport(options?: any): AxiosPromise<Array<ProcessingReport>> {
      return localVarFp
        .getProcessReport(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview process result applied to one or more records
     * @param {string} process Process identifier
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [appendFirst] Append documents before processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessRecords(
      process: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      uuids?: Array<string>,
      bucket?: string,
      appendFirst?: boolean,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewProcessRecords(
          process,
          diffType,
          uuids,
          bucket,
          appendFirst,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  When errors occur during processing, the processing report is returned in JSON format.
     * @summary Preview of search and replace text.
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewProcessSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewProcessSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          diffType,
          uuids,
          bucket,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process to one or more records
     * @param {string} process Process identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecords(
      process: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: any
    ): AxiosPromise<XsltMetadataProcessingReport> {
      return localVarFp
        .processRecords(process, uuids, bucket, updateDateStamp, index, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a database search and replace to one or more records
     * @param {string} search Value to search for
     * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
     * @param {string} [replace] Replacement
     * @param {string} [regexpFlags] regexpFlags
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {boolean} [index] Index after processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processSearchAndReplace(
      search: string,
      useRegexp?: boolean,
      replace?: string,
      regexpFlags?: string,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      index?: boolean,
      options?: any
    ): AxiosPromise<XsltMetadataProcessingReport> {
      return localVarFp
        .processSearchAndReplace(
          search,
          useRegexp,
          replace,
          regexpFlags,
          uuids,
          bucket,
          updateDateStamp,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
     * @summary Search and replace values in one or more records
     * @param {string} [process]
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
     * @param {boolean} [isCaseInsensitive] Case insensitive search.
     * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAndReplace(
      process?: string,
      uuids?: Array<string>,
      bucket?: string,
      isTesting?: boolean,
      isCaseInsensitive?: boolean,
      vacuumMode?: string,
      options?: any
    ): AxiosPromise<MetadataReplacementProcessingReport> {
      return localVarFp
        .searchAndReplace(
          process,
          uuids,
          bucket,
          isTesting,
          isCaseInsensitive,
          vacuumMode,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProcessesApi - object-oriented interface
 * @export
 * @class ProcessesApi
 * @extends {BaseAPI}
 */
export class ProcessesApi extends BaseAPI {
  /**
   *
   * @summary Clear process reports list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public _delete(options?: AxiosRequestConfig) {
    return ProcessesApiFp(this.configuration)
      ._delete(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
   * @summary Get current process reports
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public getProcessReport(options?: AxiosRequestConfig) {
    return ProcessesApiFp(this.configuration)
      .getProcessReport(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \'.csv\', the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
   * @summary Preview process result applied to one or more records
   * @param {string} process Process identifier
   * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [appendFirst] Append documents before processing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public previewProcessRecords(
    process: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    appendFirst?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .previewProcessRecords(
        process,
        diffType,
        uuids,
        bucket,
        appendFirst,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  When errors occur during processing, the processing report is returned in JSON format.
   * @summary Preview of search and replace text.
   * @param {string} search Value to search for
   * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   * @param {string} [replace] Replacement
   * @param {string} [regexpFlags] regexpFlags
   * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public previewProcessSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .previewProcessSearchAndReplace(
        search,
        useRegexp,
        replace,
        regexpFlags,
        diffType,
        uuids,
        bucket,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Apply a process to one or more records
   * @param {string} process Process identifier
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param {boolean} [index] Index after processing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public processRecords(
    process: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .processRecords(process, uuids, bucket, updateDateStamp, index, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Apply a database search and replace to one or more records
   * @param {string} search Value to search for
   * @param {boolean} [useRegexp] Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   * @param {string} [replace] Replacement
   * @param {string} [regexpFlags] regexpFlags
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param {boolean} [index] Index after processing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public processSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .processSearchAndReplace(
        search,
        useRegexp,
        replace,
        regexpFlags,
        uuids,
        bucket,
        updateDateStamp,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372=metadata  * mdfield-1398155513728=id.contact.individualName  * replaceValue-1398155513728=Juan  * searchValue-1398155513728=Jose  TODO: Would be good to provide a simple object to define list of changes instead of group of parameters.<br/>Batch editing can also be used for similar works.
   * @summary Search and replace values in one or more records
   * @param {string} [process]
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [isTesting] Test only (ie. metadata are not saved). Return the report only.
   * @param {boolean} [isCaseInsensitive] Case insensitive search.
   * @param {string} [vacuumMode] \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcessesApi
   */
  public searchAndReplace(
    process?: string,
    uuids?: Array<string>,
    bucket?: string,
    isTesting?: boolean,
    isCaseInsensitive?: boolean,
    vacuumMode?: string,
    options?: AxiosRequestConfig
  ) {
    return ProcessesApiFp(this.configuration)
      .searchAndReplace(
        process,
        uuids,
        bucket,
        isTesting,
        isCaseInsensitive,
        vacuumMode,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RecordsApi - axios parameter creator
 * @export
 */
export const RecordsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Reorder element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the element to move.
     * @param {'up' | 'down'} direction Direction
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement: async (
      metadataUuid: string,
      ref: string,
      direction: 'up' | 'down',
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('addElement', 'metadataUuid', metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists('addElement', 'ref', ref);
      // verify required parameter 'direction' is not null or undefined
      assertParamExists('addElement', 'direction', direction);
      const localVarPath = `/records/{metadataUuid}/editor/elements/{direction}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'direction'}}`, encodeURIComponent(String(direction)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref !== undefined) {
        localVarQueryParameter['ref'] = ref;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter['displayAttributes'] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the insertion point.
     * @param {string} name Name of the element to add (with prefix)
     * @param {string} [child] Use geonet:attribute for attributes or child name.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement1: async (
      metadataUuid: string,
      ref: string,
      name: string,
      child?: string,
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('addElement1', 'metadataUuid', metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists('addElement1', 'ref', ref);
      // verify required parameter 'name' is not null or undefined
      assertParamExists('addElement1', 'name', name);
      const localVarPath = `/records/{metadataUuid}/editor/elements`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref !== undefined) {
        localVarQueryParameter['ref'] = ref;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (child !== undefined) {
        localVarQueryParameter['child'] = child;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter['displayAttributes'] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
     * @summary Add samples
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSamples: async (
      schema: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('addSamples', 'schema', schema);
      const localVarPath = `/records/samples`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (schema) {
        localVarQueryParameter['schema'] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
     * @summary Add templates
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTemplates: async (
      schema: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('addTemplates', 'schema', schema);
      const localVarPath = `/records/templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (schema) {
        localVarQueryParameter['schema'] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
     * @summary Apply a saved query for this metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} savedQuery The saved query to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applyQuery: async (
      metadataUuid: string,
      savedQuery: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('applyQuery', 'metadataUuid', metadataUuid);
      // verify required parameter 'savedQuery' is not null or undefined
      assertParamExists('applyQuery', 'savedQuery', savedQuery);
      const localVarPath = `/records/{metadataUuid}/query/{savedQuery}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'savedQuery'}}`, encodeURIComponent(String(savedQuery)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchEdit: async (
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'batchEditParameter' is not null or undefined
      assertParamExists('batchEdit', 'batchEditParameter', batchEditParameter);
      const localVarPath = `/records/batchediting`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (updateDateStamp !== undefined) {
        localVarQueryParameter['updateDateStamp'] = updateDateStamp;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchEditParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel current editing session.
     * @summary Cancel edits
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelEdits: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('cancelEdits', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/editor`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkDoiStatus: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('checkDoiStatus', 'metadataUuid', metadataUuid);
      const localVarPath =
        `/records/{metadataUuid}/doi/checkPreConditions`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
     * @summary Check the status of validation with the INSPIRE service.
     * @param {string} testId Test identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkValidation: async (
      testId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'testId' is not null or undefined
      assertParamExists('checkValidation', 'testId', testId);
      const localVarPath = `/records/{testId}/validate/inspire`.replace(
        `{${'testId'}}`,
        encodeURIComponent(String(testId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Clear validation status of one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanValidationStatus: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Close a record task
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {string} closeDate Close date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTask: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      closeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('closeTask', 'metadataUuid', metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists('closeTask', 'statusId', statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('closeTask', 'userId', userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists('closeTask', 'changeDate', changeDate);
      // verify required parameter 'closeDate' is not null or undefined
      assertParamExists('closeTask', 'closeDate', closeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/close`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${'statusId'}}`, encodeURIComponent(String(statusId)))
          .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
          .replace(`{${'changeDate'}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (closeDate !== undefined) {
        localVarQueryParameter['closeDate'] = closeDate;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
     * @summary Create a new record
     * @param {string} sourceUuid UUID of the source record to copy.
     * @param {string} group The group the record is attached to.
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
     * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [hasCategoryOfSource] Copy categories from source?
     * @param {boolean} [isChildOfSource] Is child of the record to copy?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      sourceUuid: string,
      group: string,
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      targetUuid?: string,
      isVisibleByAllGroupMembers?: boolean,
      category?: Array<string>,
      hasCategoryOfSource?: boolean,
      isChildOfSource?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sourceUuid' is not null or undefined
      assertParamExists('create', 'sourceUuid', sourceUuid);
      // verify required parameter 'group' is not null or undefined
      assertParamExists('create', 'group', group);
      const localVarPath = `/records/duplicate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadataType !== undefined) {
        localVarQueryParameter['metadataType'] = metadataType;
      }

      if (sourceUuid !== undefined) {
        localVarQueryParameter['sourceUuid'] = sourceUuid;
      }

      if (targetUuid !== undefined) {
        localVarQueryParameter['targetUuid'] = targetUuid;
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (isVisibleByAllGroupMembers !== undefined) {
        localVarQueryParameter['isVisibleByAllGroupMembers'] =
          isVisibleByAllGroupMembers;
      }

      if (category) {
        localVarQueryParameter['category'] = category;
      }

      if (hasCategoryOfSource !== undefined) {
        localVarQueryParameter['hasCategoryOfSource'] = hasCategoryOfSource;
      }

      if (isChildOfSource !== undefined) {
        localVarQueryParameter['isChildOfSource'] = isChildOfSource;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit a record to the Datacite metadata store in order to create a DOI.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDoi: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('createDoi', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/doi`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResource: async (
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('delResource', 'metadataUuid', metadataUuid);
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists('delResource', 'resourceId', resourceId);
      const localVarPath = `/records/{metadataUuid}/attachments/{resourceId}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'resourceId'}}`, encodeURIComponent(String(resourceId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete all uploaded metadata resources
     * @param {string} metadataUuid The metadata UUID
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResources: async (
      metadataUuid: string,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('delResources', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete all record status
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllRecordStatus: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('deleteAllRecordStatus', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/status`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete attribute
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the attribute to remove.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttribute: async (
      metadataUuid: string,
      ref: string,
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('deleteAttribute', 'metadataUuid', metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists('deleteAttribute', 'ref', ref);
      const localVarPath = `/records/{metadataUuid}/editor/attributes`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref !== undefined) {
        localVarQueryParameter['ref'] = ref;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter['displayAttributes'] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete element
     * @param {string} metadataUuid Record UUID.
     * @param {Array<string>} ref Reference of the element to remove.
     * @param {string} parent Name of the parent.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteElement: async (
      metadataUuid: string,
      ref: Array<string>,
      parent: string,
      displayAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('deleteElement', 'metadataUuid', metadataUuid);
      // verify required parameter 'ref' is not null or undefined
      assertParamExists('deleteElement', 'ref', ref);
      // verify required parameter 'parent' is not null or undefined
      assertParamExists('deleteElement', 'parent', parent);
      const localVarPath = `/records/{metadataUuid}/editor/elements`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ref) {
        localVarQueryParameter['ref'] = ref;
      }

      if (parent !== undefined) {
        localVarQueryParameter['parent'] = parent;
      }

      if (displayAttributes !== undefined) {
        localVarQueryParameter['displayAttributes'] = displayAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
     * @summary Delete a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecord: async (
      metadataUuid: string,
      withBackup?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('deleteRecord', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (withBackup !== undefined) {
        localVarQueryParameter['withBackup'] = withBackup;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a record status
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecordStatus: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('deleteRecordStatus', 'metadataUuid', metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists('deleteRecordStatus', 'statusId', statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('deleteRecordStatus', 'userId', userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists('deleteRecordStatus', 'changeDate', changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${'statusId'}}`, encodeURIComponent(String(statusId)))
          .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
          .replace(`{${'changeDate'}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to delete it.
     * @summary Delete one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecords: async (
      uuids?: Array<string>,
      bucket?: string,
      withBackup?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (withBackup !== undefined) {
        localVarQueryParameter['withBackup'] = withBackup;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete tags to one or more records
     * @param {Array<number>} id Tag identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTagForRecords: async (
      id: Array<number>,
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteTagForRecords', 'id', id);
      const localVarPath = `/records/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete tags of a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTags: async (
      metadataUuid: string,
      id?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('deleteTags', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/tags`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Download MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBackup: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/backups/latest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary (Experimental) Enable version control
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControl: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('enableVersionControl', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/versions`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary (Experimental) Enable version control for one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControlForRecords: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/versions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The CSV is a short summary of each records.
     * @summary Get a set of metadata records as CSV
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsCsv: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a set of metadata records as ZIP
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsMef: async (
      uuids?: Array<string>,
      bucket?: string,
      format?: 'simple' | 'partial' | 'full',
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/zip`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      if (withRelated !== undefined) {
        localVarQueryParameter['withRelated'] = withRelated;
      }

      if (withXLinksResolved !== undefined) {
        localVarQueryParameter['withXLinksResolved'] = withXLinksResolved;
      }

      if (withXLinkAttribute !== undefined) {
        localVarQueryParameter['withXLinkAttribute'] = withXLinkAttribute;
      }

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter['addSchemaLocation'] = addSchemaLocation;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
     * @summary Get a set of metadata records as PDF
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsPdf: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/pdf`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the list of users \"active\" during a time period.
     * @param {string} dateFrom From date of users login date
     * @param {string} dateTo To date of users login date
     * @param {Array<number>} [groups] Group(s) for the users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveUsers: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists('getActiveUsers', 'dateFrom', dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists('getActiveUsers', 'dateTo', dateTo);
      const localVarPath = `/reports/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (groups) {
        localVarQueryParameter['groups'] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get record extents as image
     * @param {string} metadataUuid Record UUID.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsImage: async (
      metadataUuid: string,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'getAllRecordExtentAsImage',
        'metadataUuid',
        metadataUuid
      );
      const localVarPath = `/records/{metadataUuid}/extents.png`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mapsrs !== undefined) {
        localVarQueryParameter['mapsrs'] = mapsrs;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (background !== undefined) {
        localVarQueryParameter['background'] = background;
      }

      if (fillColor !== undefined) {
        localVarQueryParameter['fillColor'] = fillColor;
      }

      if (strokeColor !== undefined) {
        localVarQueryParameter['strokeColor'] = strokeColor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get list of record extents
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsJson: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'getAllRecordExtentAsJson',
        'metadataUuid',
        metadataUuid
      );
      const localVarPath = `/records/{metadataUuid}/extents.json`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
     * @summary List all metadata attachments
     * @param {string} metadataUuid The metadata UUID
     * @param {'type' | 'name'} [sort] Sort by
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllResources: async (
      metadataUuid: string,
      sort?: 'type' | 'name',
      approved?: boolean,
      filter?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getAllResources', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * .
     * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
     * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
     * @param {number} [hitsPerPage] Indicates the number of hits per page.
     * @param {string} [any] Search key
     * @param {string} [title] A search key for the title.
     * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
     * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
     * @param {string} [sortOrder] Sort order. Possible values: reverse.
     * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsRdf: async (
      from?: number,
      hitsPerPage?: number,
      any?: string,
      title?: string,
      facetQ?: string,
      sortBy?: string,
      sortOrder?: string,
      similarity?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter['from'] = from;
      }

      if (hitsPerPage !== undefined) {
        localVarQueryParameter['hitsPerPage'] = hitsPerPage;
      }

      if (any !== undefined) {
        localVarQueryParameter['any'] = any;
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title;
      }

      if (facetQ !== undefined) {
        localVarQueryParameter['facet.q'] = facetQ;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter['sortOrder'] = sortOrder;
      }

      if (similarity !== undefined) {
        localVarQueryParameter['similarity'] = similarity;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources
     * @param {string} metadataUuid Record UUID.
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     * @param {number} [rows] Number of rows returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociatedResources: async (
      metadataUuid: string,
      type?: Array<
        | 'children'
        | 'parent'
        | 'brothersAndSisters'
        | 'siblings'
        | 'associated'
        | 'services'
        | 'datasets'
        | 'fcats'
        | 'hasfeaturecats'
        | 'sources'
        | 'hassources'
        | 'related'
        | 'onlines'
        | 'thumbnails'
      >,
      start?: number,
      rows?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getAssociatedResources', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/related`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      if (start !== undefined) {
        localVarQueryParameter['start'] = start;
      }

      if (rows !== undefined) {
        localVarQueryParameter['rows'] = rows;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeatureCatalog: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getFeatureCatalog', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/featureCatalog`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get one record extent as image
     * @param {string} metadataUuid Record UUID.
     * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneRecordExtentAsImage: async (
      metadataUuid: string,
      geometryIndex: number,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'getOneRecordExtentAsImage',
        'metadataUuid',
        metadataUuid
      );
      // verify required parameter 'geometryIndex' is not null or undefined
      assertParamExists(
        'getOneRecordExtentAsImage',
        'geometryIndex',
        geometryIndex
      );
      const localVarPath = `/records/{metadataUuid}/extents/{geometryIndex}.png`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(
          `{${'geometryIndex'}}`,
          encodeURIComponent(String(geometryIndex))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mapsrs !== undefined) {
        localVarQueryParameter['mapsrs'] = mapsrs;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (background !== undefined) {
        localVarQueryParameter['background'] = background;
      }

      if (fillColor !== undefined) {
        localVarQueryParameter['fillColor'] = fillColor;
      }

      if (strokeColor !== undefined) {
        localVarQueryParameter['strokeColor'] = strokeColor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
     * @summary Increase record popularity
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecord', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/popularity`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
     * @summary Get a metadata record
     * @param {string} metadataUuid Record UUID.
     * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord1: async (
      metadataUuid: string,
      accept: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecord1', 'metadataUuid', metadataUuid);
      // verify required parameter 'accept' is not null or undefined
      assertParamExists('getRecord1', 'accept', accept);
      const localVarPath = `/records/{metadataUuid}`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs: async (
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecordAs', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/xml`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter['addSchemaLocation'] = addSchemaLocation;
      }

      if (increasePopularity !== undefined) {
        localVarQueryParameter['increasePopularity'] = increasePopularity;
      }

      if (withInfo !== undefined) {
        localVarQueryParameter['withInfo'] = withInfo;
      }

      if (attachment !== undefined) {
        localVarQueryParameter['attachment'] = attachment;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs1: async (
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecordAs1', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/json`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter['addSchemaLocation'] = addSchemaLocation;
      }

      if (increasePopularity !== undefined) {
        localVarQueryParameter['increasePopularity'] = increasePopularity;
      }

      if (withInfo !== undefined) {
        localVarQueryParameter['withInfo'] = withInfo;
      }

      if (attachment !== undefined) {
        localVarQueryParameter['attachment'] = attachment;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a metadata record as ZIP
     * @param {string} metadataUuid Record UUID.
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAsZip: async (
      metadataUuid: string,
      format?: 'simple' | 'partial' | 'full',
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecordAsZip', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/zip`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      if (withRelated !== undefined) {
        localVarQueryParameter['withRelated'] = withRelated;
      }

      if (withXLinksResolved !== undefined) {
        localVarQueryParameter['withXLinksResolved'] = withXLinksResolved;
      }

      if (withXLinkAttribute !== undefined) {
        localVarQueryParameter['withXLinkAttribute'] = withXLinkAttribute;
      }

      if (addSchemaLocation !== undefined) {
        localVarQueryParameter['addSchemaLocation'] = addSchemaLocation;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a formatted metadata record
     * @param {string} formatterId
     * @param {string} metadataUuid Record UUID.
     * @param {string} [accept] Formatter type to use.
     * @param {'_25' | '_50' | '_75' | '_100'} [width]
     * @param {string} [mdpath]
     * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
     * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
     * @param {boolean} [approved] Download the approved version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordFormattedBy: async (
      formatterId: string,
      metadataUuid: string,
      accept?: string,
      width?: '_25' | '_50' | '_75' | '_100',
      mdpath?: string,
      language?: string,
      output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'formatterId' is not null or undefined
      assertParamExists('getRecordFormattedBy', 'formatterId', formatterId);
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecordFormattedBy', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/formatters/{formatterId}`
        .replace(`{${'formatterId'}}`, encodeURIComponent(String(formatterId)))
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      if (mdpath !== undefined) {
        localVarQueryParameter['mdpath'] = mdpath;
      }

      if (language !== undefined) {
        localVarQueryParameter['language'] = language;
      }

      if (output !== undefined) {
        localVarQueryParameter['output'] = output;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return current sharing options for a record.
     * @summary Get record sharing settings
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordSharingSettings: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'getRecordSharingSettings',
        'metadataUuid',
        metadataUuid
      );
      const localVarPath = `/records/{metadataUuid}/sharing`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record status history
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistory: async (
      metadataUuid: string,
      details?: boolean,
      sortOrder?: 'ASC' | 'DESC',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecordStatusHistory', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/status`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (details !== undefined) {
        localVarQueryParameter['details'] = details;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter['sortOrder'] = sortOrder;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record status history by type
     * @param {string} metadataUuid Record UUID.
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistoryByType: async (
      metadataUuid: string,
      type: 'workflow' | 'task' | 'event',
      details?: boolean,
      sortOrder?: 'ASC' | 'DESC',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'getRecordStatusHistoryByType',
        'metadataUuid',
        metadataUuid
      );
      // verify required parameter 'type' is not null or undefined
      assertParamExists('getRecordStatusHistoryByType', 'type', type);
      const localVarPath = `/records/{metadataUuid}/status/{type}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'type'}}`, encodeURIComponent(String(type)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (details !== undefined) {
        localVarQueryParameter['details'] = details;
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter['sortOrder'] = sortOrder;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
     * @summary Get record tags
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordTags: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getRecordTags', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/tags`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of metadata file downloads
     * @param {string} dateFrom From date of the metadata downloads
     * @param {string} dateTo To date of the metadata downloads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataDownloads: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists('getReportDataDownloads', 'dateFrom', dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists('getReportDataDownloads', 'dateTo', dateTo);
      const localVarPath = `/reports/datadownloads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (groups) {
        localVarQueryParameter['groups'] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get uploaded files to metadata records during a period.
     * @param {string} dateFrom From date of the metadata uploads
     * @param {string} dateTo To date of the metadata uploads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataUploads: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists('getReportDataUploads', 'dateFrom', dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists('getReportDataUploads', 'dateTo', dateTo);
      const localVarPath = `/reports/datauploads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (groups) {
        localVarQueryParameter['groups'] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the metadata not published during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportInternalMetadata: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists('getReportInternalMetadata', 'dateFrom', dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists('getReportInternalMetadata', 'dateTo', dateTo);
      const localVarPath = `/reports/metadatainternal`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (groups) {
        localVarQueryParameter['groups'] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the updated metadata during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportUpdatedMetadata: async (
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists('getReportUpdatedMetadata', 'dateFrom', dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists('getReportUpdatedMetadata', 'dateTo', dateTo);
      const localVarPath = `/reports/metadataupdated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (groups) {
        localVarQueryParameter['groups'] = groups;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {number} [size] Size (only applies to images). From 1px to 2048px.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource: async (
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getResource', 'metadataUuid', metadataUuid);
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists('getResource', 'resourceId', resourceId);
      const localVarPath = `/records/{metadataUuid}/attachments/{resourceId}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'resourceId'}}`, encodeURIComponent(String(resourceId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List saved queries for this metadata
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSavedQueries: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getSavedQueries', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/query`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record sharing settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharingSettings: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/sharing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get last workflow status for a record
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getStatus', 'metadataUuid', metadataUuid);
      const localVarPath =
        `/records/{metadataUuid}/status/workflow/last`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
     * @summary Get suggestions
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSuggestions: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getSuggestions', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/processes`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * TG13, TG2, ...
     * @summary Get test suites available.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuites: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getTestSuites', 'metadataUuid', metadataUuid);
      const localVarPath =
        `/records/{metadataUuid}/validate/inspire/testsuites`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search status
     * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
     * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
     * @param {Array<number>} [author] One or more event author. Default is all.
     * @param {Array<number>} [owner] One or more event owners. Default is all.
     * @param {Array<number>} [id] One or more record identifier. Default is all.
     * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
     * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
     * @param {string} [dateFrom] Start date
     * @param {string} [dateTo] End date
     * @param {number} [from] From page
     * @param {number} [size] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflowStatusByType: async (
      type?: Array<'workflow' | 'task' | 'event'>,
      details?: boolean,
      author?: Array<number>,
      owner?: Array<number>,
      id?: Array<number>,
      record?: Array<number>,
      uuid?: Array<string>,
      dateFrom?: string,
      dateTo?: string,
      from?: number,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/status/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      if (details !== undefined) {
        localVarQueryParameter['details'] = details;
      }

      if (author) {
        localVarQueryParameter['author'] = author;
      }

      if (owner) {
        localVarQueryParameter['owner'] = owner;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }

      if (record) {
        localVarQueryParameter['record'] = record;
      }

      if (uuid) {
        localVarQueryParameter['uuid'] = uuid;
      }

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (from !== undefined) {
        localVarQueryParameter['from'] = from;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Index a set of records provided either by a bucket or a list of uuids
     * @summary Index a set of records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/index`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
     * @summary Add a record
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<string>} [url] URL of a file to download and insert.
     * @param {string} [serverFolder] Server folder where to look for files.
     * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insert: async (
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      url?: Array<string>,
      serverFolder?: string,
      recursiveSearch?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      body?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadataType !== undefined) {
        localVarQueryParameter['metadataType'] = metadataType;
      }

      if (url) {
        localVarQueryParameter['url'] = url;
      }

      if (serverFolder !== undefined) {
        localVarQueryParameter['serverFolder'] = serverFolder;
      }

      if (recursiveSearch !== undefined) {
        localVarQueryParameter['recursiveSearch'] = recursiveSearch;
      }

      if (publishToAll !== undefined) {
        localVarQueryParameter['publishToAll'] = publishToAll;
      }

      if (assignToCatalog !== undefined) {
        localVarQueryParameter['assignToCatalog'] = assignToCatalog;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter['uuidProcessing'] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (category) {
        localVarQueryParameter['category'] = category;
      }

      if (rejectIfInvalid !== undefined) {
        localVarQueryParameter['rejectIfInvalid'] = rejectIfInvalid;
      }

      if (transformWith !== undefined) {
        localVarQueryParameter['transformWith'] = transformWith;
      }

      if (schema !== undefined) {
        localVarQueryParameter['schema'] = schema;
      }

      if (extra !== undefined) {
        localVarQueryParameter['extra'] = extra;
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add record in the catalog by uploading files.
     * @summary Add a record from XML or MEF/ZIP file
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<any>} [file] XML or MEF file to upload
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertFile: async (
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      file?: Array<any>,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadataType !== undefined) {
        localVarQueryParameter['metadataType'] = metadataType;
      }

      if (file) {
        localVarQueryParameter['file'] = file;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter['uuidProcessing'] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (category) {
        localVarQueryParameter['category'] = category;
      }

      if (rejectIfInvalid !== undefined) {
        localVarQueryParameter['rejectIfInvalid'] = rejectIfInvalid;
      }

      if (publishToAll !== undefined) {
        localVarQueryParameter['publishToAll'] = publishToAll;
      }

      if (assignToCatalog !== undefined) {
        localVarQueryParameter['assignToCatalog'] = assignToCatalog;
      }

      if (transformWith !== undefined) {
        localVarQueryParameter['transformWith'] = transformWith;
      }

      if (schema !== undefined) {
        localVarQueryParameter['schema'] = schema;
      }

      if (extra !== undefined) {
        localVarQueryParameter['extra'] = extra;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add record in the catalog by uploading a map context.
     * @summary Add a map metadata record from OGC OWS context
     * @param {string} title A map title
     * @param {string} [recordAbstract] A map abstract
     * @param {string} [xml] OGC OWS context as string
     * @param {string} [filename] OGC OWS context file name
     * @param {string} [url] OGC OWS context URL
     * @param {string} [viewerUrl] A map viewer URL to visualize the map
     * @param {string} [overview] Map overview as PNG (base64 encoded)
     * @param {string} [overviewFilename] Map overview filename
     * @param {string} [topic] Topic category
     * @param {boolean} [publishToAll] Publish record.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertOgcMapContextFile: async (
      title: string,
      recordAbstract?: string,
      xml?: string,
      filename?: string,
      url?: string,
      viewerUrl?: string,
      overview?: string,
      overviewFilename?: string,
      topic?: string,
      publishToAll?: boolean,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'title' is not null or undefined
      assertParamExists('insertOgcMapContextFile', 'title', title);
      const localVarPath = `/records/importfrommap`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (title !== undefined) {
        localVarQueryParameter['title'] = title;
      }

      if (recordAbstract !== undefined) {
        localVarQueryParameter['recordAbstract'] = recordAbstract;
      }

      if (xml !== undefined) {
        localVarQueryParameter['xml'] = xml;
      }

      if (filename !== undefined) {
        localVarQueryParameter['filename'] = filename;
      }

      if (url !== undefined) {
        localVarQueryParameter['url'] = url;
      }

      if (viewerUrl !== undefined) {
        localVarQueryParameter['viewerUrl'] = viewerUrl;
      }

      if (overview !== undefined) {
        localVarQueryParameter['overview'] = overview;
      }

      if (overviewFilename !== undefined) {
        localVarQueryParameter['overviewFilename'] = overviewFilename;
      }

      if (topic !== undefined) {
        localVarQueryParameter['topic'] = topic;
      }

      if (publishToAll !== undefined) {
        localVarQueryParameter['publishToAll'] = publishToAll;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter['uuidProcessing'] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the metadata resource visibility
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {'public' | 'private'} visibility The visibility
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResource: async (
      metadataUuid: string,
      resourceId: string,
      visibility: 'public' | 'private',
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('patchResource', 'metadataUuid', metadataUuid);
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists('patchResource', 'resourceId', resourceId);
      // verify required parameter 'visibility' is not null or undefined
      assertParamExists('patchResource', 'visibility', visibility);
      const localVarPath = `/records/{metadataUuid}/attachments/{resourceId}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'resourceId'}}`, encodeURIComponent(String(resourceId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (visibility !== undefined) {
        localVarQueryParameter['visibility'] = visibility;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Preview edits made by XPath expressions.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewBatchEdit: async (
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'batchEditParameter' is not null or undefined
      assertParamExists(
        'previewBatchEdit',
        'batchEditParameter',
        batchEditParameter
      );
      const localVarPath = `/records/batchediting/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (diffType !== undefined) {
        localVarQueryParameter['diffType'] = diffType;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchEditParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecord: async (
      metadataUuid: string,
      process: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('processRecord', 'metadataUuid', metadataUuid);
      // verify required parameter 'process' is not null or undefined
      assertParamExists('processRecord', 'process', process);
      const localVarPath = `/records/{metadataUuid}/processes/{process}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'process'}}`, encodeURIComponent(String(process)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Preview process result
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecordPreview: async (
      metadataUuid: string,
      process: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('processRecordPreview', 'metadataUuid', metadataUuid);
      // verify required parameter 'process' is not null or undefined
      assertParamExists('processRecordPreview', 'process', process);
      const localVarPath = `/records/{metadataUuid}/processes/{process}`
        .replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        )
        .replace(`{${'process'}}`, encodeURIComponent(String(process)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('publish', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/publish`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * See record sharing for more details.
     * @summary Publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish1: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/publish`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new resource for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResource: async (
      metadataUuid: string,
      visibility?: 'public' | 'private',
      approved?: boolean,
      inlineObject2?: InlineObject2,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('putResource', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (visibility !== undefined) {
        localVarQueryParameter['visibility'] = visibility;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject2,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new resource from a URL for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} url The URL to load in the store
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResourceFromURL: async (
      metadataUuid: string,
      url: string,
      visibility?: 'public' | 'private',
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('putResourceFromURL', 'metadataUuid', metadataUuid);
      // verify required parameter 'url' is not null or undefined
      assertParamExists('putResourceFromURL', 'url', url);
      const localVarPath = `/records/{metadataUuid}/attachments`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (visibility !== undefined) {
        localVarQueryParameter['visibility'] = visibility;
      }

      if (url !== undefined) {
        localVarQueryParameter['url'] = url;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
     * @summary Rate a record
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rateRecord: async (
      metadataUuid: string,
      body: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('rateRecord', 'metadataUuid', metadataUuid);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('rateRecord', 'body', body);
      const localVarPath = `/records/{metadataUuid}/rate`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Restore saved content from a status record
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreAtStatusSave: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('restoreAtStatusSave', 'metadataUuid', metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists('restoreAtStatusSave', 'statusId', statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('restoreAtStatusSave', 'userId', userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists('restoreAtStatusSave', 'changeDate', changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/restore`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${'statusId'}}`, encodeURIComponent(String(statusId)))
          .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
          .replace(`{${'changeDate'}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Save the HTML form content.
     * @summary Save edits
     * @param {string} metadataUuid Record UUID.
     * @param {string} [tab] Tab
     * @param {boolean} [withAttributes]
     * @param {boolean} [withValidationErrors]
     * @param {boolean} [minor]
     * @param {string} [status] Submit for review directly after save.
     * @param {boolean} [commit] Save current edits.
     * @param {boolean} [terminate] Save and terminate session.
     * @param {string} [data] Record as XML. TODO: rename xml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEdits: async (
      metadataUuid: string,
      tab?: string,
      withAttributes?: boolean,
      withValidationErrors?: boolean,
      minor?: boolean,
      status?: string,
      commit?: boolean,
      terminate?: boolean,
      data?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('saveEdits', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/editor`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tab !== undefined) {
        localVarQueryParameter['tab'] = tab;
      }

      if (withAttributes !== undefined) {
        localVarQueryParameter['withAttributes'] = withAttributes;
      }

      if (withValidationErrors !== undefined) {
        localVarQueryParameter['withValidationErrors'] = withValidationErrors;
      }

      if (minor !== undefined) {
        localVarQueryParameter['minor'] = minor;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (commit !== undefined) {
        localVarQueryParameter['commit'] = commit;
      }

      if (terminate !== undefined) {
        localVarQueryParameter['terminate'] = terminate;
      }

      if (data !== undefined) {
        localVarQueryParameter['data'] = data;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
     * @summary Create an overview using the map print module
     * @param {string} metadataUuid Record UUID.
     * @param {string} jsonConfig The mapprint module JSON configuration
     * @param {number} [rotationAngle] The rotation angle of the map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveThumbnail: async (
      metadataUuid: string,
      jsonConfig: string,
      rotationAngle?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('saveThumbnail', 'metadataUuid', metadataUuid);
      // verify required parameter 'jsonConfig' is not null or undefined
      assertParamExists('saveThumbnail', 'jsonConfig', jsonConfig);
      const localVarPath =
        `/records/{metadataUuid}/attachments/print-thumbnail`.replace(
          `{${'metadataUuid'}}`,
          encodeURIComponent(String(metadataUuid))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (jsonConfig !== undefined) {
        localVarQueryParameter['jsonConfig'] = jsonConfig;
      }

      if (rotationAngle !== undefined) {
        localVarQueryParameter['rotationAngle'] = rotationAngle;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set group and owner for one or more records
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGroupAndOwner: async (
      groupIdentifier: number,
      userIdentifier: number,
      uuids?: Array<string>,
      bucket?: string,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists('setGroupAndOwner', 'groupIdentifier', groupIdentifier);
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('setGroupAndOwner', 'userIdentifier', userIdentifier);
      const localVarPath = `/records/ownership`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (groupIdentifier !== undefined) {
        localVarQueryParameter['groupIdentifier'] = groupIdentifier;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (userIdentifier !== undefined) {
        localVarQueryParameter['userIdentifier'] = userIdentifier;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A record is related to one group.
     * @summary Set record group
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordGroup: async (
      metadataUuid: string,
      body: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('setRecordGroup', 'metadataUuid', metadataUuid);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('setRecordGroup', 'body', body);
      const localVarPath = `/records/{metadataUuid}/group`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set record group and owner
     * @param {string} metadataUuid Record UUID.
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordOwnership: async (
      metadataUuid: string,
      groupIdentifier: number,
      userIdentifier: number,
      approved?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('setRecordOwnership', 'metadataUuid', metadataUuid);
      // verify required parameter 'groupIdentifier' is not null or undefined
      assertParamExists(
        'setRecordOwnership',
        'groupIdentifier',
        groupIdentifier
      );
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('setRecordOwnership', 'userIdentifier', userIdentifier);
      const localVarPath = `/records/{metadataUuid}/ownership`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (groupIdentifier !== undefined) {
        localVarQueryParameter['groupIdentifier'] = groupIdentifier;
      }

      if (userIdentifier !== undefined) {
        localVarQueryParameter['userIdentifier'] = userIdentifier;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the record status
     * @param {string} metadataUuid Record UUID.
     * @param {MetadataStatusParameter} metadataStatusParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setStatus: async (
      metadataUuid: string,
      metadataStatusParameter: MetadataStatusParameter,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('setStatus', 'metadataUuid', metadataUuid);
      // verify required parameter 'metadataStatusParameter' is not null or undefined
      assertParamExists(
        'setStatus',
        'metadataStatusParameter',
        metadataStatusParameter
      );
      const localVarPath = `/records/{metadataUuid}/status`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        metadataStatusParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * See record sharing for more details.
     * @summary Set sharing settings for one or more records
     * @param {SharingParameter} sharingParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share: async (
      sharingParameter: SharingParameter,
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sharingParameter' is not null or undefined
      assertParamExists('share', 'sharingParameter', sharingParameter);
      const localVarPath = `/records/sharing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sharingParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
     * @summary Set record sharing
     * @param {string} metadataUuid Record UUID.
     * @param {SharingParameter} sharingParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share1: async (
      metadataUuid: string,
      sharingParameter: SharingParameter,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('share1', 'metadataUuid', metadataUuid);
      // verify required parameter 'sharingParameter' is not null or undefined
      assertParamExists('share1', 'sharingParameter', sharingParameter);
      const localVarPath = `/records/{metadataUuid}/sharing`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sharingParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get saved content from the status record after changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusAfter: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('showStatusAfter', 'metadataUuid', metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists('showStatusAfter', 'statusId', statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('showStatusAfter', 'userId', userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists('showStatusAfter', 'changeDate', changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/after`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${'statusId'}}`, encodeURIComponent(String(statusId)))
          .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
          .replace(`{${'changeDate'}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get saved content from the status record before changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusBefore: async (
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('showStatusBefore', 'metadataUuid', metadataUuid);
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists('showStatusBefore', 'statusId', statusId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('showStatusBefore', 'userId', userId);
      // verify required parameter 'changeDate' is not null or undefined
      assertParamExists('showStatusBefore', 'changeDate', changeDate);
      const localVarPath =
        `/records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/before`
          .replace(
            `{${'metadataUuid'}}`,
            encodeURIComponent(String(metadataUuid))
          )
          .replace(`{${'statusId'}}`, encodeURIComponent(String(statusId)))
          .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
          .replace(`{${'changeDate'}}`, encodeURIComponent(String(changeDate)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return HTML form for editing.
     * @summary Edit a record
     * @param {string} metadataUuid Record UUID.
     * @param {string} [currTab] Tab
     * @param {boolean} [withAttributes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startEditing: async (
      metadataUuid: string,
      currTab?: string,
      withAttributes?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('startEditing', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/editor`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (currTab !== undefined) {
        localVarQueryParameter['currTab'] = currTab;
      }

      if (withAttributes !== undefined) {
        localVarQueryParameter['withAttributes'] = withAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add tags to a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} id Tag identifier
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecord: async (
      metadataUuid: string,
      id: Array<number>,
      clear?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('tagRecord', 'metadataUuid', metadataUuid);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('tagRecord', 'id', id);
      const localVarPath = `/records/{metadataUuid}/tags`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }

      if (clear !== undefined) {
        localVarQueryParameter['clear'] = clear;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add or remove tags to one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {Array<number>} [id] Tag identifier
     * @param {Array<number>} [removeId] Tag identifier to remove.
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecords: async (
      uuids?: Array<string>,
      bucket?: string,
      id?: Array<number>,
      removeId?: Array<number>,
      clear?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }

      if (removeId) {
        localVarQueryParameter['removeId'] = removeId;
      }

      if (clear !== undefined) {
        localVarQueryParameter['clear'] = clear;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Trigger MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trigger: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/records/backups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * See record sharing for more details.
     * @summary Un-publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish: async (
      uuids?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/unpublish`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unsets privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish1: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('unpublish1', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/unpublish`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unregisterDoi: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('unregisterDoi', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/doi`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
     * @summary Validate a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecord: async (
      metadataUuid: string,
      isvalid?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('validateRecord', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/validate/internal`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (isvalid !== undefined) {
        localVarQueryParameter['isvalid'] = isvalid;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
     * @summary Submit a record to the INSPIRE service for validation.
     * @param {string} metadataUuid Record UUID.
     * @param {string} testsuite Test suite to run
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordForInspire: async (
      metadataUuid: string,
      testsuite: string,
      mode?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'validateRecordForInspire',
        'metadataUuid',
        metadataUuid
      );
      // verify required parameter 'testsuite' is not null or undefined
      assertParamExists('validateRecordForInspire', 'testsuite', testsuite);
      const localVarPath = `/records/{metadataUuid}/validate/inspire`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (testsuite !== undefined) {
        localVarQueryParameter['testsuite'] = testsuite;
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecords: async (
      uuids?: Array<string>,
      approved?: boolean,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (approved !== undefined) {
        localVarQueryParameter['approved'] = approved;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records in INSPIRE validator
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordsInspire: async (
      uuids?: Array<string>,
      bucket?: string,
      mode?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/records/validate/inspire`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (mode !== undefined) {
        localVarQueryParameter['mode'] = mode;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecordsApi - functional programming interface
 * @export
 */
export const RecordsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RecordsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Reorder element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the element to move.
     * @param {'up' | 'down'} direction Direction
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addElement(
      metadataUuid: string,
      ref: string,
      direction: 'up' | 'down',
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addElement(
        metadataUuid,
        ref,
        direction,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the insertion point.
     * @param {string} name Name of the element to add (with prefix)
     * @param {string} [child] Use geonet:attribute for attributes or child name.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addElement1(
      metadataUuid: string,
      ref: string,
      name: string,
      child?: string,
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addElement1(
        metadataUuid,
        ref,
        name,
        child,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
     * @summary Add samples
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addSamples(
      schema: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addSamples(
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
     * @summary Add templates
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTemplates(
      schema: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplates(
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
     * @summary Apply a saved query for this metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} savedQuery The saved query to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async applyQuery(
      metadataUuid: string,
      savedQuery: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.applyQuery(
        metadataUuid,
        savedQuery,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async batchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<IProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.batchEdit(
        batchEditParameter,
        uuids,
        bucket,
        updateDateStamp,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Cancel current editing session.
     * @summary Cancel edits
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelEdits(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEdits(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkDoiStatus(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: boolean }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkDoiStatus(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
     * @summary Check the status of validation with the INSPIRE service.
     * @param {string} testId Test identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkValidation(
      testId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkValidation(
        testId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Clear validation status of one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cleanValidationStatus(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cleanValidationStatus(
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Close a record task
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {string} closeDate Close date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async closeTask(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      closeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.closeTask(
        metadataUuid,
        statusId,
        userId,
        changeDate,
        closeDate,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
     * @summary Create a new record
     * @param {string} sourceUuid UUID of the source record to copy.
     * @param {string} group The group the record is attached to.
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
     * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [hasCategoryOfSource] Copy categories from source?
     * @param {boolean} [isChildOfSource] Is child of the record to copy?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      sourceUuid: string,
      group: string,
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      targetUuid?: string,
      isVisibleByAllGroupMembers?: boolean,
      category?: Array<string>,
      hasCategoryOfSource?: boolean,
      isChildOfSource?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        sourceUuid,
        group,
        metadataType,
        targetUuid,
        isVisibleByAllGroupMembers,
        category,
        hasCategoryOfSource,
        isChildOfSource,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Submit a record to the Datacite metadata store in order to create a DOI.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDoi(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDoi(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.delResource(
        metadataUuid,
        resourceId,
        approved,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete all uploaded metadata resources
     * @param {string} metadataUuid The metadata UUID
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delResources(
      metadataUuid: string,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.delResources(
        metadataUuid,
        approved,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete all record status
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAllRecordStatus(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAllRecordStatus(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete attribute
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the attribute to remove.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAttribute(
      metadataUuid: string,
      ref: string,
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttribute(
        metadataUuid,
        ref,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete element
     * @param {string} metadataUuid Record UUID.
     * @param {Array<string>} ref Reference of the element to remove.
     * @param {string} parent Name of the parent.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteElement(
      metadataUuid: string,
      ref: Array<string>,
      parent: string,
      displayAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteElement(
        metadataUuid,
        ref,
        parent,
        displayAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
     * @summary Delete a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecord(
      metadataUuid: string,
      withBackup?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecord(
        metadataUuid,
        withBackup,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete a record status
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecordStatus(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteRecordStatus(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to delete it.
     * @summary Delete one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecords(
      uuids?: Array<string>,
      bucket?: string,
      withBackup?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecords(
        uuids,
        bucket,
        withBackup,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete tags to one or more records
     * @param {Array<number>} id Tag identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTagForRecords(
      id: Array<number>,
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteTagForRecords(
          id,
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete tags of a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTags(
      metadataUuid: string,
      id?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTags(
        metadataUuid,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Download MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadBackup(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBackup(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary (Experimental) Enable version control
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enableVersionControl(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.enableVersionControl(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary (Experimental) Enable version control for one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enableVersionControlForRecords(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.enableVersionControlForRecords(
          uuids,
          bucket,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The CSV is a short summary of each records.
     * @summary Get a set of metadata records as CSV
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exportAsCsv(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.exportAsCsv(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a set of metadata records as ZIP
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exportAsMef(
      uuids?: Array<string>,
      bucket?: string,
      format?: 'simple' | 'partial' | 'full',
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.exportAsMef(
        uuids,
        bucket,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
     * @summary Get a set of metadata records as PDF
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exportAsPdf(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.exportAsPdf(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the list of users \"active\" during a time period.
     * @param {string} dateFrom From date of users login date
     * @param {string} dateTo To date of users login date
     * @param {Array<number>} [groups] Group(s) for the users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveUsers(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveUsers(
        dateFrom,
        dateTo,
        groups,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get record extents as image
     * @param {string} metadataUuid Record UUID.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllRecordExtentAsImage(
      metadataUuid: string,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllRecordExtentAsImage(
          metadataUuid,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get list of record extents
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllRecordExtentAsJson(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ExtentDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllRecordExtentAsJson(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
     * @summary List all metadata attachments
     * @param {string} metadataUuid The metadata UUID
     * @param {'type' | 'name'} [sort] Sort by
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllResources(
      metadataUuid: string,
      sort?: 'type' | 'name',
      approved?: boolean,
      filter?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MetadataResource>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllResources(
        metadataUuid,
        sort,
        approved,
        filter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * .
     * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
     * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
     * @param {number} [hitsPerPage] Indicates the number of hits per page.
     * @param {string} [any] Search key
     * @param {string} [title] A search key for the title.
     * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
     * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
     * @param {string} [sortOrder] Sort order. Possible values: reverse.
     * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAsRdf(
      from?: number,
      hitsPerPage?: number,
      any?: string,
      title?: string,
      facetQ?: string,
      sortBy?: string,
      sortOrder?: string,
      similarity?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAsRdf(
        from,
        hitsPerPage,
        any,
        title,
        facetQ,
        sortBy,
        sortOrder,
        similarity,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources
     * @param {string} metadataUuid Record UUID.
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     * @param {number} [rows] Number of rows returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssociatedResources(
      metadataUuid: string,
      type?: Array<
        | 'children'
        | 'parent'
        | 'brothersAndSisters'
        | 'siblings'
        | 'associated'
        | 'services'
        | 'datasets'
        | 'fcats'
        | 'hasfeaturecats'
        | 'sources'
        | 'hassources'
        | 'related'
        | 'onlines'
        | 'thumbnails'
      >,
      start?: number,
      rows?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RelatedResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAssociatedResources(
          metadataUuid,
          type,
          start,
          rows,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeatureCatalog(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FeatureResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFeatureCatalog(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get one record extent as image
     * @param {string} metadataUuid Record UUID.
     * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOneRecordExtentAsImage(
      metadataUuid: string,
      geometryIndex: number,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOneRecordExtentAsImage(
          metadataUuid,
          geometryIndex,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
     * @summary Increase record popularity
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecord(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
     * @summary Get a metadata record
     * @param {string} metadataUuid Record UUID.
     * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecord1(
      metadataUuid: string,
      accept: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord1(
        metadataUuid,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordAs(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordAs(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordAs1(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordAs1(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a metadata record as ZIP
     * @param {string} metadataUuid Record UUID.
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordAsZip(
      metadataUuid: string,
      format?: 'simple' | 'partial' | 'full',
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordAsZip(
        metadataUuid,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a formatted metadata record
     * @param {string} formatterId
     * @param {string} metadataUuid Record UUID.
     * @param {string} [accept] Formatter type to use.
     * @param {'_25' | '_50' | '_75' | '_100'} [width]
     * @param {string} [mdpath]
     * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
     * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
     * @param {boolean} [approved] Download the approved version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordFormattedBy(
      formatterId: string,
      metadataUuid: string,
      accept?: string,
      width?: '_25' | '_50' | '_75' | '_100',
      mdpath?: string,
      language?: string,
      output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordFormattedBy(
          formatterId,
          metadataUuid,
          accept,
          width,
          mdpath,
          language,
          output,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return current sharing options for a record.
     * @summary Get record sharing settings
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordSharingSettings(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SharingResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordSharingSettings(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record status history
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordStatusHistory(
      metadataUuid: string,
      details?: boolean,
      sortOrder?: 'ASC' | 'DESC',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordStatusHistory(
          metadataUuid,
          details,
          sortOrder,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record status history by type
     * @param {string} metadataUuid Record UUID.
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordStatusHistoryByType(
      metadataUuid: string,
      type: 'workflow' | 'task' | 'event',
      details?: boolean,
      sortOrder?: 'ASC' | 'DESC',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecordStatusHistoryByType(
          metadataUuid,
          type,
          details,
          sortOrder,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
     * @summary Get record tags
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordTags(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Set<MetadataCategory>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordTags(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of metadata file downloads
     * @param {string} dateFrom From date of the metadata downloads
     * @param {string} dateTo To date of the metadata downloads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportDataDownloads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportDataDownloads(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get uploaded files to metadata records during a period.
     * @param {string} dateFrom From date of the metadata uploads
     * @param {string} dateTo To date of the metadata uploads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportDataUploads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportDataUploads(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the metadata not published during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportInternalMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportInternalMetadata(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the updated metadata during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportUpdatedMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReportUpdatedMetadata(
          dateFrom,
          dateTo,
          groups,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {number} [size] Size (only applies to images). From 1px to 2048px.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(
        metadataUuid,
        resourceId,
        approved,
        size,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List saved queries for this metadata
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSavedQueries(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SavedQuery>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedQueries(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record sharing settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSharingSettings(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SharingResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSharingSettings(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get last workflow status for a record
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
     * @summary Get suggestions
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSuggestions(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SuggestionType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSuggestions(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * TG13, TG2, ...
     * @summary Get test suites available.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTestSuites(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: Array<string> }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTestSuites(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Search status
     * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
     * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
     * @param {Array<number>} [author] One or more event author. Default is all.
     * @param {Array<number>} [owner] One or more event owners. Default is all.
     * @param {Array<number>} [id] One or more record identifier. Default is all.
     * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
     * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
     * @param {string} [dateFrom] Start date
     * @param {string} [dateTo] End date
     * @param {number} [from] From page
     * @param {number} [size] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWorkflowStatusByType(
      type?: Array<'workflow' | 'task' | 'event'>,
      details?: boolean,
      author?: Array<number>,
      owner?: Array<number>,
      id?: Array<number>,
      record?: Array<number>,
      uuid?: Array<string>,
      dateFrom?: string,
      dateTo?: string,
      from?: number,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWorkflowStatusByType(
          type,
          details,
          author,
          owner,
          id,
          record,
          uuid,
          dateFrom,
          dateTo,
          from,
          size,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Index a set of records provided either by a bucket or a list of uuids
     * @summary Index a set of records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async index(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.index(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
     * @summary Add a record
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<string>} [url] URL of a file to download and insert.
     * @param {string} [serverFolder] Server folder where to look for files.
     * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async insert(
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      url?: Array<string>,
      serverFolder?: string,
      recursiveSearch?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      body?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.insert(
        metadataType,
        url,
        serverFolder,
        recursiveSearch,
        publishToAll,
        assignToCatalog,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        transformWith,
        schema,
        extra,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add record in the catalog by uploading files.
     * @summary Add a record from XML or MEF/ZIP file
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<any>} [file] XML or MEF file to upload
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async insertFile(
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      file?: Array<any>,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.insertFile(
        metadataType,
        file,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        publishToAll,
        assignToCatalog,
        transformWith,
        schema,
        extra,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Add record in the catalog by uploading a map context.
     * @summary Add a map metadata record from OGC OWS context
     * @param {string} title A map title
     * @param {string} [recordAbstract] A map abstract
     * @param {string} [xml] OGC OWS context as string
     * @param {string} [filename] OGC OWS context file name
     * @param {string} [url] OGC OWS context URL
     * @param {string} [viewerUrl] A map viewer URL to visualize the map
     * @param {string} [overview] Map overview as PNG (base64 encoded)
     * @param {string} [overviewFilename] Map overview filename
     * @param {string} [topic] Topic category
     * @param {boolean} [publishToAll] Publish record.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async insertOgcMapContextFile(
      title: string,
      recordAbstract?: string,
      xml?: string,
      filename?: string,
      url?: string,
      viewerUrl?: string,
      overview?: string,
      overviewFilename?: string,
      topic?: string,
      publishToAll?: boolean,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.insertOgcMapContextFile(
          title,
          recordAbstract,
          xml,
          filename,
          url,
          viewerUrl,
          overview,
          overviewFilename,
          topic,
          publishToAll,
          uuidProcessing,
          group,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update the metadata resource visibility
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {'public' | 'private'} visibility The visibility
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchResource(
      metadataUuid: string,
      resourceId: string,
      visibility: 'public' | 'private',
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchResource(
        metadataUuid,
        resourceId,
        visibility,
        approved,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Preview edits made by XPath expressions.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewBatchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewBatchEdit(
          batchEditParameter,
          uuids,
          bucket,
          diffType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processRecord(
      metadataUuid: string,
      process: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.processRecord(
        metadataUuid,
        process,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Preview process result
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processRecordPreview(
      metadataUuid: string,
      process: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.processRecordPreview(
          metadataUuid,
          process,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publish(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publish(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * See record sharing for more details.
     * @summary Publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publish1(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publish1(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a new resource for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putResource(
      metadataUuid: string,
      visibility?: 'public' | 'private',
      approved?: boolean,
      inlineObject2?: InlineObject2,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putResource(
        metadataUuid,
        visibility,
        approved,
        inlineObject2,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a new resource from a URL for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} url The URL to load in the store
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putResourceFromURL(
      metadataUuid: string,
      url: string,
      visibility?: 'public' | 'private',
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putResourceFromURL(
          metadataUuid,
          url,
          visibility,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
     * @summary Rate a record
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rateRecord(
      metadataUuid: string,
      body: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rateRecord(
        metadataUuid,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Restore saved content from a status record
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restoreAtStatusSave(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.restoreAtStatusSave(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Save the HTML form content.
     * @summary Save edits
     * @param {string} metadataUuid Record UUID.
     * @param {string} [tab] Tab
     * @param {boolean} [withAttributes]
     * @param {boolean} [withValidationErrors]
     * @param {boolean} [minor]
     * @param {string} [status] Submit for review directly after save.
     * @param {boolean} [commit] Save current edits.
     * @param {boolean} [terminate] Save and terminate session.
     * @param {string} [data] Record as XML. TODO: rename xml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveEdits(
      metadataUuid: string,
      tab?: string,
      withAttributes?: boolean,
      withValidationErrors?: boolean,
      minor?: boolean,
      status?: string,
      commit?: boolean,
      terminate?: boolean,
      data?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveEdits(
        metadataUuid,
        tab,
        withAttributes,
        withValidationErrors,
        minor,
        status,
        commit,
        terminate,
        data,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
     * @summary Create an overview using the map print module
     * @param {string} metadataUuid Record UUID.
     * @param {string} jsonConfig The mapprint module JSON configuration
     * @param {number} [rotationAngle] The rotation angle of the map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveThumbnail(
      metadataUuid: string,
      jsonConfig: string,
      rotationAngle?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataResource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveThumbnail(
        metadataUuid,
        jsonConfig,
        rotationAngle,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set group and owner for one or more records
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setGroupAndOwner(
      groupIdentifier: number,
      userIdentifier: number,
      uuids?: Array<string>,
      bucket?: string,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setGroupAndOwner(
          groupIdentifier,
          userIdentifier,
          uuids,
          bucket,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * A record is related to one group.
     * @summary Set record group
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setRecordGroup(
      metadataUuid: string,
      body: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setRecordGroup(
        metadataUuid,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set record group and owner
     * @param {string} metadataUuid Record UUID.
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setRecordOwnership(
      metadataUuid: string,
      groupIdentifier: number,
      userIdentifier: number,
      approved?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setRecordOwnership(
          metadataUuid,
          groupIdentifier,
          userIdentifier,
          approved,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set the record status
     * @param {string} metadataUuid Record UUID.
     * @param {MetadataStatusParameter} metadataStatusParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setStatus(
      metadataUuid: string,
      metadataStatusParameter: MetadataStatusParameter,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setStatus(
        metadataUuid,
        metadataStatusParameter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * See record sharing for more details.
     * @summary Set sharing settings for one or more records
     * @param {SharingParameter} sharingParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async share(
      sharingParameter: SharingParameter,
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.share(
        sharingParameter,
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
     * @summary Set record sharing
     * @param {string} metadataUuid Record UUID.
     * @param {SharingParameter} sharingParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async share1(
      metadataUuid: string,
      sharingParameter: SharingParameter,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.share1(
        metadataUuid,
        sharingParameter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get saved content from the status record after changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showStatusAfter(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showStatusAfter(
        metadataUuid,
        statusId,
        userId,
        changeDate,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get saved content from the status record before changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showStatusBefore(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showStatusBefore(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return HTML form for editing.
     * @summary Edit a record
     * @param {string} metadataUuid Record UUID.
     * @param {string} [currTab] Tab
     * @param {boolean} [withAttributes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startEditing(
      metadataUuid: string,
      currTab?: string,
      withAttributes?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startEditing(
        metadataUuid,
        currTab,
        withAttributes,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add tags to a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} id Tag identifier
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagRecord(
      metadataUuid: string,
      id: Array<number>,
      clear?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tagRecord(
        metadataUuid,
        id,
        clear,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add or remove tags to one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {Array<number>} [id] Tag identifier
     * @param {Array<number>} [removeId] Tag identifier to remove.
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagRecords(
      uuids?: Array<string>,
      bucket?: string,
      id?: Array<number>,
      removeId?: Array<number>,
      clear?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tagRecords(
        uuids,
        bucket,
        id,
        removeId,
        clear,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Trigger MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trigger(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.trigger(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * See record sharing for more details.
     * @summary Un-publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unpublish(
      uuids?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish(
        uuids,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Unsets privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unpublish1(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish1(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unregisterDoi(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterDoi(
        metadataUuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
     * @summary Validate a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecord(
      metadataUuid: string,
      isvalid?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reports>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateRecord(
        metadataUuid,
        isvalid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
     * @summary Submit a record to the INSPIRE service for validation.
     * @param {string} metadataUuid Record UUID.
     * @param {string} testsuite Test suite to run
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecordForInspire(
      metadataUuid: string,
      testsuite: string,
      mode?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateRecordForInspire(
          metadataUuid,
          testsuite,
          mode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecords(
      uuids?: Array<string>,
      approved?: boolean,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateRecords(
        uuids,
        approved,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records in INSPIRE validator
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateRecordsInspire(
      uuids?: Array<string>,
      bucket?: string,
      mode?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateRecordsInspire(
          uuids,
          bucket,
          mode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RecordsApi - factory interface
 * @export
 */
export const RecordsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RecordsApiFp(configuration);
  return {
    /**
     *
     * @summary Reorder element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the element to move.
     * @param {'up' | 'down'} direction Direction
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement(
      metadataUuid: string,
      ref: string,
      direction: 'up' | 'down',
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addElement(metadataUuid, ref, direction, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add element
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the insertion point.
     * @param {string} name Name of the element to add (with prefix)
     * @param {string} [child] Use geonet:attribute for attributes or child name.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addElement1(
      metadataUuid: string,
      ref: string,
      name: string,
      child?: string,
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addElement1(metadataUuid, ref, name, child, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
     * @summary Add samples
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSamples(
      schema: Array<string>,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .addSamples(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
     * @summary Add templates
     * @param {Array<string>} schema Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTemplates(
      schema: Array<string>,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .addTemplates(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
     * @summary Apply a saved query for this metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} savedQuery The saved query to apply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applyQuery(
      metadataUuid: string,
      savedQuery: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .applyQuery(metadataUuid, savedQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      updateDateStamp?: boolean,
      options?: any
    ): AxiosPromise<IProcessingReport> {
      return localVarFp
        .batchEdit(batchEditParameter, uuids, bucket, updateDateStamp, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Cancel current editing session.
     * @summary Cancel edits
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelEdits(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .cancelEdits(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkDoiStatus(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<{ [key: string]: boolean }> {
      return localVarFp
        .checkDoiStatus(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
     * @summary Check the status of validation with the INSPIRE service.
     * @param {string} testId Test identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkValidation(
      testId: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .checkValidation(testId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Clear validation status of one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanValidationStatus(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .cleanValidationStatus(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Close a record task
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {string} closeDate Close date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTask(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      closeDate: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .closeTask(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          closeDate,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
     * @summary Create a new record
     * @param {string} sourceUuid UUID of the source record to copy.
     * @param {string} group The group the record is attached to.
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
     * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [hasCategoryOfSource] Copy categories from source?
     * @param {boolean} [isChildOfSource] Is child of the record to copy?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      sourceUuid: string,
      group: string,
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      targetUuid?: string,
      isVisibleByAllGroupMembers?: boolean,
      category?: Array<string>,
      hasCategoryOfSource?: boolean,
      isChildOfSource?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .create(
          sourceUuid,
          group,
          metadataType,
          targetUuid,
          isVisibleByAllGroupMembers,
          category,
          hasCategoryOfSource,
          isChildOfSource,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Submit a record to the Datacite metadata store in order to create a DOI.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDoi(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .createDoi(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .delResource(metadataUuid, resourceId, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete all uploaded metadata resources
     * @param {string} metadataUuid The metadata UUID
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delResources(
      metadataUuid: string,
      approved?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .delResources(metadataUuid, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete all record status
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllRecordStatus(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAllRecordStatus(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete attribute
     * @param {string} metadataUuid Record UUID.
     * @param {string} ref Reference of the attribute to remove.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttribute(
      metadataUuid: string,
      ref: string,
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAttribute(metadataUuid, ref, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete element
     * @param {string} metadataUuid Record UUID.
     * @param {Array<string>} ref Reference of the element to remove.
     * @param {string} parent Name of the parent.
     * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteElement(
      metadataUuid: string,
      ref: Array<string>,
      parent: string,
      displayAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteElement(metadataUuid, ref, parent, displayAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
     * @summary Delete a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecord(
      metadataUuid: string,
      withBackup?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteRecord(metadataUuid, withBackup, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a record status
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecordStatus(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteRecordStatus(metadataUuid, statusId, userId, changeDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to delete it.
     * @summary Delete one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecords(
      uuids?: Array<string>,
      bucket?: string,
      withBackup?: boolean,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .deleteRecords(uuids, bucket, withBackup, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete tags to one or more records
     * @param {Array<number>} id Tag identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTagForRecords(
      id: Array<number>,
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .deleteTagForRecords(id, uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete tags of a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTags(
      metadataUuid: string,
      id?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteTags(metadataUuid, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Download MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBackup(options?: any): AxiosPromise<void> {
      return localVarFp
        .downloadBackup(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary (Experimental) Enable version control
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControl(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .enableVersionControl(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary (Experimental) Enable version control for one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableVersionControlForRecords(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .enableVersionControlForRecords(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The CSV is a short summary of each records.
     * @summary Get a set of metadata records as CSV
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsCsv(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .exportAsCsv(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a set of metadata records as ZIP
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsMef(
      uuids?: Array<string>,
      bucket?: string,
      format?: 'simple' | 'partial' | 'full',
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .exportAsMef(
          uuids,
          bucket,
          format,
          withRelated,
          withXLinksResolved,
          withXLinkAttribute,
          addSchemaLocation,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
     * @summary Get a set of metadata records as PDF
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportAsPdf(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .exportAsPdf(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the list of users \"active\" during a time period.
     * @param {string} dateFrom From date of users login date
     * @param {string} dateTo To date of users login date
     * @param {Array<number>} [groups] Group(s) for the users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveUsers(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getActiveUsers(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get record extents as image
     * @param {string} metadataUuid Record UUID.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsImage(
      metadataUuid: string,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getAllRecordExtentAsImage(
          metadataUuid,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get list of record extents
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRecordExtentAsJson(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Array<ExtentDto>> {
      return localVarFp
        .getAllRecordExtentAsJson(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
     * @summary List all metadata attachments
     * @param {string} metadataUuid The metadata UUID
     * @param {'type' | 'name'} [sort] Sort by
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllResources(
      metadataUuid: string,
      sort?: 'type' | 'name',
      approved?: boolean,
      filter?: string,
      options?: any
    ): AxiosPromise<Array<MetadataResource>> {
      return localVarFp
        .getAllResources(metadataUuid, sort, approved, filter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * .
     * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
     * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
     * @param {number} [hitsPerPage] Indicates the number of hits per page.
     * @param {string} [any] Search key
     * @param {string} [title] A search key for the title.
     * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
     * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
     * @param {string} [sortOrder] Sort order. Possible values: reverse.
     * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsRdf(
      from?: number,
      hitsPerPage?: number,
      any?: string,
      title?: string,
      facetQ?: string,
      sortBy?: string,
      sortOrder?: string,
      similarity?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getAsRdf(
          from,
          hitsPerPage,
          any,
          title,
          facetQ,
          sortBy,
          sortOrder,
          similarity,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources
     * @param {string} metadataUuid Record UUID.
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
     * @param {number} [rows] Number of rows returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociatedResources(
      metadataUuid: string,
      type?: Array<
        | 'children'
        | 'parent'
        | 'brothersAndSisters'
        | 'siblings'
        | 'associated'
        | 'services'
        | 'datasets'
        | 'fcats'
        | 'hasfeaturecats'
        | 'sources'
        | 'hassources'
        | 'related'
        | 'onlines'
        | 'thumbnails'
      >,
      start?: number,
      rows?: number,
      options?: any
    ): AxiosPromise<RelatedResponse> {
      return localVarFp
        .getAssociatedResources(metadataUuid, type, start, rows, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeatureCatalog(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<FeatureResponse> {
      return localVarFp
        .getFeatureCatalog(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
     * @summary Get one record extent as image
     * @param {string} metadataUuid Record UUID.
     * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
     * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneRecordExtentAsImage(
      metadataUuid: string,
      geometryIndex: number,
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      fillColor?: string,
      strokeColor?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getOneRecordExtentAsImage(
          metadataUuid,
          geometryIndex,
          mapsrs,
          width,
          height,
          background,
          fillColor,
          strokeColor,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
     * @summary Increase record popularity
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getRecord(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
     * @summary Get a metadata record
     * @param {string} metadataUuid Record UUID.
     * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecord1(
      metadataUuid: string,
      accept: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getRecord1(metadataUuid, accept, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getRecordAs(
          metadataUuid,
          addSchemaLocation,
          increasePopularity,
          withInfo,
          attachment,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a metadata record as XML or JSON
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
     * @param {boolean} [increasePopularity] Increase record popularity
     * @param {boolean} [withInfo] Add geonet:info details
     * @param {boolean} [attachment] Download as a file
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAs1(
      metadataUuid: string,
      addSchemaLocation?: boolean,
      increasePopularity?: boolean,
      withInfo?: boolean,
      attachment?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getRecordAs1(
          metadataUuid,
          addSchemaLocation,
          increasePopularity,
          withInfo,
          attachment,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
     * @summary Get a metadata record as ZIP
     * @param {string} metadataUuid Record UUID.
     * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
     * @param {boolean} [withRelated] With related records (parent and service).
     * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
     * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
     * @param {boolean} [addSchemaLocation]
     * @param {boolean} [approved] Download the approved version
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordAsZip(
      metadataUuid: string,
      format?: 'simple' | 'partial' | 'full',
      withRelated?: boolean,
      withXLinksResolved?: boolean,
      withXLinkAttribute?: boolean,
      addSchemaLocation?: boolean,
      approved?: boolean,
      accept?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordAsZip(
          metadataUuid,
          format,
          withRelated,
          withXLinksResolved,
          withXLinkAttribute,
          addSchemaLocation,
          approved,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a formatted metadata record
     * @param {string} formatterId
     * @param {string} metadataUuid Record UUID.
     * @param {string} [accept] Formatter type to use.
     * @param {'_25' | '_50' | '_75' | '_100'} [width]
     * @param {string} [mdpath]
     * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
     * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
     * @param {boolean} [approved] Download the approved version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordFormattedBy(
      formatterId: string,
      metadataUuid: string,
      accept?: string,
      width?: '_25' | '_50' | '_75' | '_100',
      mdpath?: string,
      language?: string,
      output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
      approved?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordFormattedBy(
          formatterId,
          metadataUuid,
          accept,
          width,
          mdpath,
          language,
          output,
          approved,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return current sharing options for a record.
     * @summary Get record sharing settings
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordSharingSettings(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<SharingResponse> {
      return localVarFp
        .getRecordSharingSettings(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record status history
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistory(
      metadataUuid: string,
      details?: boolean,
      sortOrder?: 'ASC' | 'DESC',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordStatusHistory(metadataUuid, details, sortOrder, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record status history by type
     * @param {string} metadataUuid Record UUID.
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {boolean} [details]
     * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordStatusHistoryByType(
      metadataUuid: string,
      type: 'workflow' | 'task' | 'event',
      details?: boolean,
      sortOrder?: 'ASC' | 'DESC',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getRecordStatusHistoryByType(
          metadataUuid,
          type,
          details,
          sortOrder,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
     * @summary Get record tags
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordTags(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Set<MetadataCategory>> {
      return localVarFp
        .getRecordTags(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of metadata file downloads
     * @param {string} dateFrom From date of the metadata downloads
     * @param {string} dateTo To date of the metadata downloads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataDownloads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportDataDownloads(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get uploaded files to metadata records during a period.
     * @param {string} dateFrom From date of the metadata uploads
     * @param {string} dateTo To date of the metadata uploads
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportDataUploads(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportDataUploads(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the metadata not published during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportInternalMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportInternalMetadata(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the updated metadata during a period.
     * @param {string} dateFrom From date of metadata change date
     * @param {string} dateTo To date of metadata change date
     * @param {Array<number>} [groups] Metadata group(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportUpdatedMetadata(
      dateFrom: string,
      dateTo: string,
      groups?: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getReportUpdatedMetadata(dateFrom, dateTo, groups, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a metadata resource
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {boolean} [approved] Use approved version or not
     * @param {number} [size] Size (only applies to images). From 1px to 2048px.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource(
      metadataUuid: string,
      resourceId: string,
      approved?: boolean,
      size?: number,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getResource(metadataUuid, resourceId, approved, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List saved queries for this metadata
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSavedQueries(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Array<SavedQuery>> {
      return localVarFp
        .getSavedQueries(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record sharing settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSharingSettings(options?: any): AxiosPromise<SharingResponse> {
      return localVarFp
        .getSharingSettings(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get last workflow status for a record
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getStatus(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
     * @summary Get suggestions
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSuggestions(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<Array<SuggestionType>> {
      return localVarFp
        .getSuggestions(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * TG13, TG2, ...
     * @summary Get test suites available.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuites(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp
        .getTestSuites(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search status
     * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
     * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
     * @param {Array<number>} [author] One or more event author. Default is all.
     * @param {Array<number>} [owner] One or more event owners. Default is all.
     * @param {Array<number>} [id] One or more record identifier. Default is all.
     * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
     * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
     * @param {string} [dateFrom] Start date
     * @param {string} [dateTo] End date
     * @param {number} [from] From page
     * @param {number} [size] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflowStatusByType(
      type?: Array<'workflow' | 'task' | 'event'>,
      details?: boolean,
      author?: Array<number>,
      owner?: Array<number>,
      id?: Array<number>,
      record?: Array<number>,
      uuid?: Array<string>,
      dateFrom?: string,
      dateTo?: string,
      from?: number,
      size?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getWorkflowStatusByType(
          type,
          details,
          author,
          owner,
          id,
          record,
          uuid,
          dateFrom,
          dateTo,
          from,
          size,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Index a set of records provided either by a bucket or a list of uuids
     * @summary Index a set of records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<{ [key: string]: object }> {
      return localVarFp
        .index(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
     * @summary Add a record
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<string>} [url] URL of a file to download and insert.
     * @param {string} [serverFolder] Server folder where to look for files.
     * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insert(
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      url?: Array<string>,
      serverFolder?: string,
      recursiveSearch?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      body?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .insert(
          metadataType,
          url,
          serverFolder,
          recursiveSearch,
          publishToAll,
          assignToCatalog,
          uuidProcessing,
          group,
          category,
          rejectIfInvalid,
          transformWith,
          schema,
          extra,
          body,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Add record in the catalog by uploading files.
     * @summary Add a record from XML or MEF/ZIP file
     * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
     * @param {Array<any>} [file] XML or MEF file to upload
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {Array<string>} [category] Tags to assign to the record.
     * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
     * @param {boolean} [publishToAll] (XML file only) Publish record.
     * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
     * @param {string} [transformWith] XSL transformation to apply to the record.
     * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
     * @param {string} [extra] (experimental) Add extra information to the record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertFile(
      metadataType?:
        | 'METADATA'
        | 'TEMPLATE'
        | 'SUB_TEMPLATE'
        | 'TEMPLATE_OF_SUB_TEMPLATE',
      file?: Array<any>,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      category?: Array<string>,
      rejectIfInvalid?: boolean,
      publishToAll?: boolean,
      assignToCatalog?: boolean,
      transformWith?: string,
      schema?: string,
      extra?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .insertFile(
          metadataType,
          file,
          uuidProcessing,
          group,
          category,
          rejectIfInvalid,
          publishToAll,
          assignToCatalog,
          transformWith,
          schema,
          extra,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Add record in the catalog by uploading a map context.
     * @summary Add a map metadata record from OGC OWS context
     * @param {string} title A map title
     * @param {string} [recordAbstract] A map abstract
     * @param {string} [xml] OGC OWS context as string
     * @param {string} [filename] OGC OWS context file name
     * @param {string} [url] OGC OWS context URL
     * @param {string} [viewerUrl] A map viewer URL to visualize the map
     * @param {string} [overview] Map overview as PNG (base64 encoded)
     * @param {string} [overviewFilename] Map overview filename
     * @param {string} [topic] Topic category
     * @param {boolean} [publishToAll] Publish record.
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {string} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertOgcMapContextFile(
      title: string,
      recordAbstract?: string,
      xml?: string,
      filename?: string,
      url?: string,
      viewerUrl?: string,
      overview?: string,
      overviewFilename?: string,
      topic?: string,
      publishToAll?: boolean,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .insertOgcMapContextFile(
          title,
          recordAbstract,
          xml,
          filename,
          url,
          viewerUrl,
          overview,
          overviewFilename,
          topic,
          publishToAll,
          uuidProcessing,
          group,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the metadata resource visibility
     * @param {string} metadataUuid The metadata UUID
     * @param {string} resourceId The resource identifier (ie. filename)
     * @param {'public' | 'private'} visibility The visibility
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResource(
      metadataUuid: string,
      resourceId: string,
      visibility: 'public' | 'private',
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .patchResource(metadataUuid, resourceId, visibility, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Preview edits made by XPath expressions.
     * @param {Array<BatchEditParameter>} batchEditParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewBatchEdit(
      batchEditParameter: Array<BatchEditParameter>,
      uuids?: Array<string>,
      bucket?: string,
      diffType?: 'patch' | 'diff' | 'diffhtml',
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewBatchEdit(batchEditParameter, uuids, bucket, diffType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Apply a process
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecord(
      metadataUuid: string,
      process: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .processRecord(metadataUuid, process, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
     * @summary Preview process result
     * @param {string} metadataUuid Record UUID.
     * @param {string} process Process identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processRecordPreview(
      metadataUuid: string,
      process: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .processRecordPreview(metadataUuid, process, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .publish(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * See record sharing for more details.
     * @summary Publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publish1(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .publish1(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new resource for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResource(
      metadataUuid: string,
      visibility?: 'public' | 'private',
      approved?: boolean,
      inlineObject2?: InlineObject2,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .putResource(metadataUuid, visibility, approved, inlineObject2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new resource from a URL for a given metadata
     * @param {string} metadataUuid The metadata UUID
     * @param {string} url The URL to load in the store
     * @param {'public' | 'private'} [visibility] The sharing policy
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putResourceFromURL(
      metadataUuid: string,
      url: string,
      visibility?: 'public' | 'private',
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .putResourceFromURL(metadataUuid, url, visibility, approved, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
     * @summary Rate a record
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rateRecord(
      metadataUuid: string,
      body: number,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .rateRecord(metadataUuid, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Restore saved content from a status record
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreAtStatusSave(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .restoreAtStatusSave(
          metadataUuid,
          statusId,
          userId,
          changeDate,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Save the HTML form content.
     * @summary Save edits
     * @param {string} metadataUuid Record UUID.
     * @param {string} [tab] Tab
     * @param {boolean} [withAttributes]
     * @param {boolean} [withValidationErrors]
     * @param {boolean} [minor]
     * @param {string} [status] Submit for review directly after save.
     * @param {boolean} [commit] Save current edits.
     * @param {boolean} [terminate] Save and terminate session.
     * @param {string} [data] Record as XML. TODO: rename xml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEdits(
      metadataUuid: string,
      tab?: string,
      withAttributes?: boolean,
      withValidationErrors?: boolean,
      minor?: boolean,
      status?: string,
      commit?: boolean,
      terminate?: boolean,
      data?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .saveEdits(
          metadataUuid,
          tab,
          withAttributes,
          withValidationErrors,
          minor,
          status,
          commit,
          terminate,
          data,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
     * @summary Create an overview using the map print module
     * @param {string} metadataUuid Record UUID.
     * @param {string} jsonConfig The mapprint module JSON configuration
     * @param {number} [rotationAngle] The rotation angle of the map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveThumbnail(
      metadataUuid: string,
      jsonConfig: string,
      rotationAngle?: number,
      options?: any
    ): AxiosPromise<MetadataResource> {
      return localVarFp
        .saveThumbnail(metadataUuid, jsonConfig, rotationAngle, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set group and owner for one or more records
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGroupAndOwner(
      groupIdentifier: number,
      userIdentifier: number,
      uuids?: Array<string>,
      bucket?: string,
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .setGroupAndOwner(
          groupIdentifier,
          userIdentifier,
          uuids,
          bucket,
          approved,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A record is related to one group.
     * @summary Set record group
     * @param {string} metadataUuid Record UUID.
     * @param {number} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordGroup(
      metadataUuid: string,
      body: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .setRecordGroup(metadataUuid, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set record group and owner
     * @param {string} metadataUuid Record UUID.
     * @param {number} groupIdentifier Group identifier
     * @param {number} userIdentifier User identifier
     * @param {boolean} [approved] Use approved version or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setRecordOwnership(
      metadataUuid: string,
      groupIdentifier: number,
      userIdentifier: number,
      approved?: boolean,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .setRecordOwnership(
          metadataUuid,
          groupIdentifier,
          userIdentifier,
          approved,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set the record status
     * @param {string} metadataUuid Record UUID.
     * @param {MetadataStatusParameter} metadataStatusParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setStatus(
      metadataUuid: string,
      metadataStatusParameter: MetadataStatusParameter,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .setStatus(metadataUuid, metadataStatusParameter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * See record sharing for more details.
     * @summary Set sharing settings for one or more records
     * @param {SharingParameter} sharingParameter
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share(
      sharingParameter: SharingParameter,
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .share(sharingParameter, uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
     * @summary Set record sharing
     * @param {string} metadataUuid Record UUID.
     * @param {SharingParameter} sharingParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    share1(
      metadataUuid: string,
      sharingParameter: SharingParameter,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .share1(metadataUuid, sharingParameter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get saved content from the status record after changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusAfter(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .showStatusAfter(metadataUuid, statusId, userId, changeDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get saved content from the status record before changes
     * @param {string} metadataUuid Record UUID.
     * @param {number} statusId Status identifier
     * @param {number} userId User identifier
     * @param {string} changeDate Change date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showStatusBefore(
      metadataUuid: string,
      statusId: number,
      userId: number,
      changeDate: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .showStatusBefore(metadataUuid, statusId, userId, changeDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return HTML form for editing.
     * @summary Edit a record
     * @param {string} metadataUuid Record UUID.
     * @param {string} [currTab] Tab
     * @param {boolean} [withAttributes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startEditing(
      metadataUuid: string,
      currTab?: string,
      withAttributes?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .startEditing(metadataUuid, currTab, withAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add tags to a record
     * @param {string} metadataUuid Record UUID.
     * @param {Array<number>} id Tag identifier
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecord(
      metadataUuid: string,
      id: Array<number>,
      clear?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .tagRecord(metadataUuid, id, clear, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add or remove tags to one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {Array<number>} [id] Tag identifier
     * @param {Array<number>} [removeId] Tag identifier to remove.
     * @param {boolean} [clear] Clear all before adding new ones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagRecords(
      uuids?: Array<string>,
      bucket?: string,
      id?: Array<number>,
      removeId?: Array<number>,
      clear?: boolean,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .tagRecords(uuids, bucket, id, removeId, clear, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The backup contains all metadata not harvested including templates.
     * @summary Trigger MEF backup archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trigger(options?: any): AxiosPromise<string> {
      return localVarFp
        .trigger(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * See record sharing for more details.
     * @summary Un-publish one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish(
      uuids?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<MetadataProcessingReport> {
      return localVarFp
        .unpublish(uuids, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unsets privileges for ALL group to publish the metadata for all users.
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublish1(metadataUuid: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .unpublish1(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
     * @param {string} metadataUuid Record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unregisterDoi(metadataUuid: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .unregisterDoi(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
     * @summary Validate a record
     * @param {string} metadataUuid Record UUID.
     * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecord(
      metadataUuid: string,
      isvalid?: boolean,
      options?: any
    ): AxiosPromise<Reports> {
      return localVarFp
        .validateRecord(metadataUuid, isvalid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
     * @summary Submit a record to the INSPIRE service for validation.
     * @param {string} metadataUuid Record UUID.
     * @param {string} testsuite Test suite to run
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordForInspire(
      metadataUuid: string,
      testsuite: string,
      mode?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .validateRecordForInspire(metadataUuid, testsuite, mode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {boolean} [approved] Use approved version or not
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecords(
      uuids?: Array<string>,
      approved?: boolean,
      bucket?: string,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .validateRecords(uuids, approved, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update validation status for all records.
     * @summary Validate one or more records in INSPIRE validator
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRecordsInspire(
      uuids?: Array<string>,
      bucket?: string,
      mode?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .validateRecordsInspire(uuids, bucket, mode, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RecordsApi - object-oriented interface
 * @export
 * @class RecordsApi
 * @extends {BaseAPI}
 */
export class RecordsApi extends BaseAPI {
  /**
   *
   * @summary Reorder element
   * @param {string} metadataUuid Record UUID.
   * @param {string} ref Reference of the element to move.
   * @param {'up' | 'down'} direction Direction
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addElement(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .addElement(metadataUuid, ref, direction, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add element
   * @param {string} metadataUuid Record UUID.
   * @param {string} ref Reference of the insertion point.
   * @param {string} name Name of the element to add (with prefix)
   * @param {string} [child] Use geonet:attribute for attributes or child name.
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addElement1(
    metadataUuid: string,
    ref: string,
    name: string,
    child?: string,
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .addElement1(metadataUuid, ref, name, child, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
   * @summary Add samples
   * @param {Array<string>} schema Schema identifiers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addSamples(schema: Array<string>, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .addSamples(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
   * @summary Add templates
   * @param {Array<string>} schema Schema identifiers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public addTemplates(schema: Array<string>, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .addTemplates(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
   * @summary Apply a saved query for this metadata
   * @param {string} metadataUuid The metadata UUID
   * @param {string} savedQuery The saved query to apply
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .applyQuery(metadataUuid, savedQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
   * @param {Array<BatchEditParameter>} batchEditParameter
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [updateDateStamp] If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public batchEdit(
    batchEditParameter: Array<BatchEditParameter>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .batchEdit(batchEditParameter, uuids, bucket, updateDateStamp, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel current editing session.
   * @summary Cancel edits
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public cancelEdits(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .cancelEdits(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public checkDoiStatus(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .checkDoiStatus(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
   * @summary Check the status of validation with the INSPIRE service.
   * @param {string} testId Test identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public checkValidation(testId: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .checkValidation(testId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Clear validation status of one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .cleanValidationStatus(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Close a record task
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {string} closeDate Close date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public closeTask(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    closeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .closeTask(metadataUuid, statusId, userId, changeDate, closeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
   * @summary Create a new record
   * @param {string} sourceUuid UUID of the source record to copy.
   * @param {string} group The group the record is attached to.
   * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
   * @param {string} [targetUuid] Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
   * @param {boolean} [isVisibleByAllGroupMembers] Is published to all user group members? If not, only the author and administrator can edit the record.
   * @param {Array<string>} [category] Tags to assign to the record.
   * @param {boolean} [hasCategoryOfSource] Copy categories from source?
   * @param {boolean} [isChildOfSource] Is child of the record to copy?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    isVisibleByAllGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .create(
        sourceUuid,
        group,
        metadataType,
        targetUuid,
        isVisibleByAllGroupMembers,
        category,
        hasCategoryOfSource,
        isChildOfSource,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Submit a record to the Datacite metadata store in order to create a DOI.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public createDoi(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .createDoi(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a metadata resource
   * @param {string} metadataUuid The metadata UUID
   * @param {string} resourceId The resource identifier (ie. filename)
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public delResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .delResource(metadataUuid, resourceId, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete all uploaded metadata resources
   * @param {string} metadataUuid The metadata UUID
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public delResources(
    metadataUuid: string,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .delResources(metadataUuid, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete all record status
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteAllRecordStatus(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteAllRecordStatus(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete attribute
   * @param {string} metadataUuid Record UUID.
   * @param {string} ref Reference of the attribute to remove.
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteAttribute(metadataUuid, ref, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete element
   * @param {string} metadataUuid Record UUID.
   * @param {Array<string>} ref Reference of the element to remove.
   * @param {string} parent Name of the parent.
   * @param {boolean} [displayAttributes] Should attributes be shown on the editor snippet?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteElement(metadataUuid, ref, parent, displayAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
   * @summary Delete a record
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteRecord(
    metadataUuid: string,
    withBackup?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteRecord(metadataUuid, withBackup, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a record status
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteRecordStatus(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteRecordStatus(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to delete it.
   * @summary Delete one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [withBackup] Backup first the record as MEF in the metadata removed folder.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteRecords(uuids, bucket, withBackup, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete tags to one or more records
   * @param {Array<number>} id Tag identifier
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteTagForRecords(id, uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete tags of a record
   * @param {string} metadataUuid Record UUID.
   * @param {Array<number>} [id] Tag identifier. If none, all tags are removed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .deleteTags(metadataUuid, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * @summary Download MEF backup archive
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public downloadBackup(options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .downloadBackup(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary (Experimental) Enable version control
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public enableVersionControl(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .enableVersionControl(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary (Experimental) Enable version control for one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .enableVersionControlForRecords(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The CSV is a short summary of each records.
   * @summary Get a set of metadata records as CSV
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .exportAsCsv(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @summary Get a set of metadata records as ZIP
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
   * @param {boolean} [withRelated] With related records (parent and service).
   * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
   * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
   * @param {boolean} [addSchemaLocation]
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .exportAsMef(
        uuids,
        bucket,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
   * @summary Get a set of metadata records as PDF
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .exportAsPdf(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the list of users \"active\" during a time period.
   * @param {string} dateFrom From date of users login date
   * @param {string} dateTo To date of users login date
   * @param {Array<number>} [groups] Group(s) for the users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getActiveUsers(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @summary Get record extents as image
   * @param {string} metadataUuid Record UUID.
   * @param {string} [mapsrs]
   * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
   * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
   * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAllRecordExtentAsImage(
    metadataUuid: string,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAllRecordExtentAsImage(
        metadataUuid,
        mapsrs,
        width,
        height,
        background,
        fillColor,
        strokeColor,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @summary Get list of record extents
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAllRecordExtentAsJson(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\'>More info</a>
   * @summary List all metadata attachments
   * @param {string} metadataUuid The metadata UUID
   * @param {'type' | 'name'} [sort] Sort by
   * @param {boolean} [approved] Use approved version or not
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAllResources(metadataUuid, sort, approved, filter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * .
   * @summary Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
   * @param {number} [from] Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
   * @param {number} [hitsPerPage] Indicates the number of hits per page.
   * @param {string} [any] Search key
   * @param {string} [title] A search key for the title.
   * @param {string} [facetQ] A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
   * @param {string} [sortBy] Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
   * @param {string} [sortOrder] Sort order. Possible values: reverse.
   * @param {number} [similarity] Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAsRdf(
    from?: number,
    hitsPerPage?: number,
    any?: string,
    title?: string,
    facetQ?: string,
    sortBy?: string,
    sortOrder?: string,
    similarity?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAsRdf(
        from,
        hitsPerPage,
        any,
        title,
        facetQ,
        sortBy,
        sortOrder,
        similarity,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
   * @summary Get record related resources
   * @param {string} metadataUuid Record UUID.
   * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
   * @param {number} [start] Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
   * @param {number} [rows] Number of rows returned. Default 100.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    start?: number,
    rows?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getAssociatedResources(metadataUuid, type, start, rows, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
   * @summary Returns a map to decode attributes in a dataset (from the associated feature catalog)
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getFeatureCatalog(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getFeatureCatalog(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @summary Get one record extent as image
   * @param {string} metadataUuid Record UUID.
   * @param {number} geometryIndex Index of the geometry or bounding box to display. Starts at 1.
   * @param {string} [mapsrs]
   * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
   * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
   * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   * @param {string} [fillColor] (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   * @param {string} [strokeColor] (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getOneRecordExtentAsImage(
    metadataUuid: string,
    geometryIndex: number,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getOneRecordExtentAsImage(
        metadataUuid,
        geometryIndex,
        mapsrs,
        width,
        height,
        background,
        fillColor,
        strokeColor,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
   * @summary Increase record popularity
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecord(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getRecord(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
   * @summary Get a metadata record
   * @param {string} metadataUuid Record UUID.
   * @param {string} accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecord1(
    metadataUuid: string,
    accept: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecord1(metadataUuid, accept, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a metadata record as XML or JSON
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param {boolean} [increasePopularity] Increase record popularity
   * @param {boolean} [withInfo] Add geonet:info details
   * @param {boolean} [attachment] Download as a file
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordAs(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a metadata record as XML or JSON
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [addSchemaLocation] Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param {boolean} [increasePopularity] Increase record popularity
   * @param {boolean} [withInfo] Add geonet:info details
   * @param {boolean} [attachment] Download as a file
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordAs1(
        metadataUuid,
        addSchemaLocation,
        increasePopularity,
        withInfo,
        attachment,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @summary Get a metadata record as ZIP
   * @param {string} metadataUuid Record UUID.
   * @param {'simple' | 'partial' | 'full'} [format] MEF file format.
   * @param {boolean} [withRelated] With related records (parent and service).
   * @param {boolean} [withXLinksResolved] Resolve XLinks in the records.
   * @param {boolean} [withXLinkAttribute] Preserve XLink URLs in the records.
   * @param {boolean} [addSchemaLocation]
   * @param {boolean} [approved] Download the approved version
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordAsZip(
        metadataUuid,
        format,
        withRelated,
        withXLinksResolved,
        withXLinkAttribute,
        addSchemaLocation,
        approved,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a formatted metadata record
   * @param {string} formatterId
   * @param {string} metadataUuid Record UUID.
   * @param {string} [accept] Formatter type to use.
   * @param {'_25' | '_50' | '_75' | '_100'} [width]
   * @param {string} [mdpath]
   * @param {string} [language] Optional language ISO 3 letters code to override HTTP Accept-language header.
   * @param {'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf'} [output]
   * @param {boolean} [approved] Download the approved version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordFormattedBy(
        formatterId,
        metadataUuid,
        accept,
        width,
        mdpath,
        language,
        output,
        approved,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return current sharing options for a record.
   * @summary Get record sharing settings
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordSharingSettings(
    metadataUuid: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordSharingSettings(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record status history
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [details]
   * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordStatusHistory(metadataUuid, details, sortOrder, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record status history by type
   * @param {string} metadataUuid Record UUID.
   * @param {'workflow' | 'task' | 'event'} type Type
   * @param {boolean} [details]
   * @param {'ASC' | 'DESC'} [sortOrder] Sort direction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getRecordStatusHistoryByType(
        metadataUuid,
        type,
        details,
        sortOrder,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Tags are used to classify information.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\'>More info</a>
   * @summary Get record tags
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getRecordTags(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getRecordTags(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of metadata file downloads
   * @param {string} dateFrom From date of the metadata downloads
   * @param {string} dateTo To date of the metadata downloads
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportDataDownloads(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get uploaded files to metadata records during a period.
   * @param {string} dateFrom From date of the metadata uploads
   * @param {string} dateTo To date of the metadata uploads
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportDataUploads(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the metadata not published during a period.
   * @param {string} dateFrom From date of metadata change date
   * @param {string} dateTo To date of metadata change date
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportInternalMetadata(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the updated metadata during a period.
   * @param {string} dateFrom From date of metadata change date
   * @param {string} dateTo To date of metadata change date
   * @param {Array<number>} [groups] Metadata group(s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getReportUpdatedMetadata(dateFrom, dateTo, groups, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a metadata resource
   * @param {string} metadataUuid The metadata UUID
   * @param {string} resourceId The resource identifier (ie. filename)
   * @param {boolean} [approved] Use approved version or not
   * @param {number} [size] Size (only applies to images). From 1px to 2048px.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getResource(metadataUuid, resourceId, approved, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List saved queries for this metadata
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getSavedQueries(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getSavedQueries(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record sharing settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getSharingSettings(options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getSharingSettings(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get last workflow status for a record
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getStatus(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getStatus(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Analyze the record an suggest processes to improve the quality of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\'>More info</a>
   * @summary Get suggestions
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getSuggestions(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getSuggestions(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * TG13, TG2, ...
   * @summary Get test suites available.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getTestSuites(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .getTestSuites(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search status
   * @param {Array<'workflow' | 'task' | 'event'>} [type] One or more types to retrieve (ie. worflow, event, task). Default is all.
   * @param {boolean} [details] All event details including XML changes. Responses are bigger. Default is false
   * @param {Array<number>} [author] One or more event author. Default is all.
   * @param {Array<number>} [owner] One or more event owners. Default is all.
   * @param {Array<number>} [id] One or more record identifier. Default is all.
   * @param {Array<number>} [record] One or more metadata record identifier. Default is all.
   * @param {Array<string>} [uuid] One or more metadata uuid. Default is all.
   * @param {string} [dateFrom] Start date
   * @param {string} [dateTo] End date
   * @param {number} [from] From page
   * @param {number} [size] Number of records to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    record?: Array<number>,
    uuid?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .getWorkflowStatusByType(
        type,
        details,
        author,
        owner,
        id,
        record,
        uuid,
        dateFrom,
        dateTo,
        from,
        size,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Index a set of records provided either by a bucket or a list of uuids
   * @summary Index a set of records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public index(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .index(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
   * @summary Add a record
   * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
   * @param {Array<string>} [url] URL of a file to download and insert.
   * @param {string} [serverFolder] Server folder where to look for files.
   * @param {boolean} [recursiveSearch] (Server folder import only) Recursive search in folder.
   * @param {boolean} [publishToAll] (XML file only) Publish record.
   * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {string} [group] The group the record is attached to.
   * @param {Array<string>} [category] Tags to assign to the record.
   * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
   * @param {string} [transformWith] XSL transformation to apply to the record.
   * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param {string} [extra] (experimental) Add extra information to the record.
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    body?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .insert(
        metadataType,
        url,
        serverFolder,
        recursiveSearch,
        publishToAll,
        assignToCatalog,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        transformWith,
        schema,
        extra,
        body,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add record in the catalog by uploading files.
   * @summary Add a record from XML or MEF/ZIP file
   * @param {'METADATA' | 'TEMPLATE' | 'SUB_TEMPLATE' | 'TEMPLATE_OF_SUB_TEMPLATE'} [metadataType] The type of record.
   * @param {Array<any>} [file] XML or MEF file to upload
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {string} [group] The group the record is attached to.
   * @param {Array<string>} [category] Tags to assign to the record.
   * @param {boolean} [rejectIfInvalid] Validate the record first and reject it if not valid.
   * @param {boolean} [publishToAll] (XML file only) Publish record.
   * @param {boolean} [assignToCatalog] (MEF file only) Assign to current catalog.
   * @param {string} [transformWith] XSL transformation to apply to the record.
   * @param {string} [schema] Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param {string} [extra] (experimental) Add extra information to the record.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<any>,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .insertFile(
        metadataType,
        file,
        uuidProcessing,
        group,
        category,
        rejectIfInvalid,
        publishToAll,
        assignToCatalog,
        transformWith,
        schema,
        extra,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add record in the catalog by uploading a map context.
   * @summary Add a map metadata record from OGC OWS context
   * @param {string} title A map title
   * @param {string} [recordAbstract] A map abstract
   * @param {string} [xml] OGC OWS context as string
   * @param {string} [filename] OGC OWS context file name
   * @param {string} [url] OGC OWS context URL
   * @param {string} [viewerUrl] A map viewer URL to visualize the map
   * @param {string} [overview] Map overview as PNG (base64 encoded)
   * @param {string} [overviewFilename] Map overview filename
   * @param {string} [topic] Topic category
   * @param {boolean} [publishToAll] Publish record.
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {string} [group] The group the record is attached to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .insertOgcMapContextFile(
        title,
        recordAbstract,
        xml,
        filename,
        url,
        viewerUrl,
        overview,
        overviewFilename,
        topic,
        publishToAll,
        uuidProcessing,
        group,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the metadata resource visibility
   * @param {string} metadataUuid The metadata UUID
   * @param {string} resourceId The resource identifier (ie. filename)
   * @param {'public' | 'private'} visibility The visibility
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .patchResource(metadataUuid, resourceId, visibility, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Preview edits made by XPath expressions.
   * @param {Array<BatchEditParameter>} batchEditParameter
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {'patch' | 'diff' | 'diffhtml'} [diffType] Return differences with diff, diffhtml or patch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public previewBatchEdit(
    batchEditParameter: Array<BatchEditParameter>,
    uuids?: Array<string>,
    bucket?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .previewBatchEdit(batchEditParameter, uuids, bucket, diffType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Apply a process
   * @param {string} metadataUuid Record UUID.
   * @param {string} process Process identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public processRecord(
    metadataUuid: string,
    process: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .processRecord(metadataUuid, process, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @summary Preview process result
   * @param {string} metadataUuid Record UUID.
   * @param {string} process Process identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .processRecordPreview(metadataUuid, process, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set privileges for ALL group to publish the metadata for all users.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public publish(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .publish(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * See record sharing for more details.
   * @summary Publish one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public publish1(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .publish1(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new resource for a given metadata
   * @param {string} metadataUuid The metadata UUID
   * @param {'public' | 'private'} [visibility] The sharing policy
   * @param {boolean} [approved] Use approved version or not
   * @param {InlineObject2} [inlineObject2]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public putResource(
    metadataUuid: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    inlineObject2?: InlineObject2,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .putResource(metadataUuid, visibility, approved, inlineObject2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new resource from a URL for a given metadata
   * @param {string} metadataUuid The metadata UUID
   * @param {string} url The URL to load in the store
   * @param {'public' | 'private'} [visibility] The sharing policy
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .putResourceFromURL(metadataUuid, url, visibility, approved, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User rating of metadata. If the metadata was harvested using the \'GeoNetwork\' protocol and the system setting localrating/enable is false (the default), the user\'s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \'local rating\' is applied, counting only rating from users of this node.<br/>When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
   * @summary Rate a record
   * @param {string} metadataUuid Record UUID.
   * @param {number} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public rateRecord(
    metadataUuid: string,
    body: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .rateRecord(metadataUuid, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Restore saved content from a status record
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .restoreAtStatusSave(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Save the HTML form content.
   * @summary Save edits
   * @param {string} metadataUuid Record UUID.
   * @param {string} [tab] Tab
   * @param {boolean} [withAttributes]
   * @param {boolean} [withValidationErrors]
   * @param {boolean} [minor]
   * @param {string} [status] Submit for review directly after save.
   * @param {boolean} [commit] Save current edits.
   * @param {boolean} [terminate] Save and terminate session.
   * @param {string} [data] Record as XML. TODO: rename xml
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .saveEdits(
        metadataUuid,
        tab,
        withAttributes,
        withValidationErrors,
        minor,
        status,
        commit,
        terminate,
        data,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * <a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\'>More info</a>
   * @summary Create an overview using the map print module
   * @param {string} metadataUuid Record UUID.
   * @param {string} jsonConfig The mapprint module JSON configuration
   * @param {number} [rotationAngle] The rotation angle of the map
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .saveThumbnail(metadataUuid, jsonConfig, rotationAngle, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set group and owner for one or more records
   * @param {number} groupIdentifier Group identifier
   * @param {number} userIdentifier User identifier
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setGroupAndOwner(
        groupIdentifier,
        userIdentifier,
        uuids,
        bucket,
        approved,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A record is related to one group.
   * @summary Set record group
   * @param {string} metadataUuid Record UUID.
   * @param {number} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setRecordGroup(metadataUuid, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set record group and owner
   * @param {string} metadataUuid Record UUID.
   * @param {number} groupIdentifier Group identifier
   * @param {number} userIdentifier User identifier
   * @param {boolean} [approved] Use approved version or not
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setRecordOwnership(
        metadataUuid,
        groupIdentifier,
        userIdentifier,
        approved,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set the record status
   * @param {string} metadataUuid Record UUID.
   * @param {MetadataStatusParameter} metadataStatusParameter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public setStatus(
    metadataUuid: string,
    metadataStatusParameter: MetadataStatusParameter,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .setStatus(metadataUuid, metadataStatusParameter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * See record sharing for more details.
   * @summary Set sharing settings for one or more records
   * @param {SharingParameter} sharingParameter
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public share(
    sharingParameter: SharingParameter,
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .share(sharingParameter, uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet & Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\'s groups is set in catalog configuration user MUST be a member of the group.<br/>Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\'>More info</a>
   * @summary Set record sharing
   * @param {string} metadataUuid Record UUID.
   * @param {SharingParameter} sharingParameter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public share1(
    metadataUuid: string,
    sharingParameter: SharingParameter,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .share1(metadataUuid, sharingParameter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get saved content from the status record after changes
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .showStatusAfter(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get saved content from the status record before changes
   * @param {string} metadataUuid Record UUID.
   * @param {number} statusId Status identifier
   * @param {number} userId User identifier
   * @param {string} changeDate Change date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .showStatusBefore(metadataUuid, statusId, userId, changeDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return HTML form for editing.
   * @summary Edit a record
   * @param {string} metadataUuid Record UUID.
   * @param {string} [currTab] Tab
   * @param {boolean} [withAttributes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public startEditing(
    metadataUuid: string,
    currTab?: string,
    withAttributes?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .startEditing(metadataUuid, currTab, withAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add tags to a record
   * @param {string} metadataUuid Record UUID.
   * @param {Array<number>} id Tag identifier
   * @param {boolean} [clear] Clear all before adding new ones
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .tagRecord(metadataUuid, id, clear, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add or remove tags to one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {Array<number>} [id] Tag identifier
   * @param {Array<number>} [removeId] Tag identifier to remove.
   * @param {boolean} [clear] Clear all before adding new ones
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .tagRecords(uuids, bucket, id, removeId, clear, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The backup contains all metadata not harvested including templates.
   * @summary Trigger MEF backup archive
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public trigger(options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .trigger(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * See record sharing for more details.
   * @summary Un-publish one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .unpublish(uuids, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unsets privileges for ALL group to publish the metadata for all users.
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public unpublish1(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .unpublish1(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
   * @param {string} metadataUuid Record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public unregisterDoi(metadataUuid: string, options?: AxiosRequestConfig) {
    return RecordsApiFp(this.configuration)
      .unregisterDoi(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
   * @summary Validate a record
   * @param {string} metadataUuid Record UUID.
   * @param {boolean} [isvalid] Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecord(metadataUuid, isvalid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
   * @summary Submit a record to the INSPIRE service for validation.
   * @param {string} metadataUuid Record UUID.
   * @param {string} testsuite Test suite to run
   * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecordForInspire(metadataUuid, testsuite, mode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update validation status for all records.
   * @summary Validate one or more records
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {boolean} [approved] Use approved version or not
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecords(uuids, approved, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update validation status for all records.
   * @summary Validate one or more records in INSPIRE validator
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [mode] Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecordsApi
   */
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    options?: AxiosRequestConfig
  ) {
    return RecordsApiFp(this.configuration)
      .validateRecordsInspire(uuids, bucket, mode, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RegionsApi - axios parameter creator
 * @export
 */
export const RegionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * A rendering of the geometry as a png.
     * @summary Get geometry as image
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [geom] (optional) a wkt or gml encoded geometry.
     * @param {string} [geomtype] (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
     * @param {string} [geomsrs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeomAsImage: async (
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      geom?: string,
      geomtype?: string,
      geomsrs?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/regions/geom.png`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mapsrs !== undefined) {
        localVarQueryParameter['mapsrs'] = mapsrs;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (background !== undefined) {
        localVarQueryParameter['background'] = background;
      }

      if (geom !== undefined) {
        localVarQueryParameter['geom'] = geom;
      }

      if (geomtype !== undefined) {
        localVarQueryParameter['geomtype'] = geomtype;
      }

      if (geomsrs !== undefined) {
        localVarQueryParameter['geomsrs'] = geomsrs;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of region types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegionTypes: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/regions/types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of regions
     * @param {string} [label]
     * @param {string} [categoryId]
     * @param {number} [maxRecords]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions: async (
      label?: string,
      categoryId?: string,
      maxRecords?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/regions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (label !== undefined) {
        localVarQueryParameter['label'] = label;
      }

      if (categoryId !== undefined) {
        localVarQueryParameter['categoryId'] = categoryId;
      }

      if (maxRecords !== undefined) {
        localVarQueryParameter['maxRecords'] = maxRecords;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RegionsApi - functional programming interface
 * @export
 */
export const RegionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RegionsApiAxiosParamCreator(configuration);
  return {
    /**
     * A rendering of the geometry as a png.
     * @summary Get geometry as image
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [geom] (optional) a wkt or gml encoded geometry.
     * @param {string} [geomtype] (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
     * @param {string} [geomsrs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeomAsImage(
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      geom?: string,
      geomtype?: string,
      geomsrs?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGeomAsImage(
        mapsrs,
        width,
        height,
        background,
        geom,
        geomtype,
        geomsrs,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of region types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRegionTypes(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Category>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionTypes(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of regions
     * @param {string} [label]
     * @param {string} [categoryId]
     * @param {number} [maxRecords]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRegions(
      label?: string,
      categoryId?: string,
      maxRecords?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListRegionsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(
        label,
        categoryId,
        maxRecords,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RegionsApi - factory interface
 * @export
 */
export const RegionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RegionsApiFp(configuration);
  return {
    /**
     * A rendering of the geometry as a png.
     * @summary Get geometry as image
     * @param {string} [mapsrs]
     * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
     * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
     * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
     * @param {string} [geom] (optional) a wkt or gml encoded geometry.
     * @param {string} [geomtype] (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
     * @param {string} [geomsrs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeomAsImage(
      mapsrs?: string,
      width?: number,
      height?: number,
      background?: string,
      geom?: string,
      geomtype?: string,
      geomsrs?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getGeomAsImage(
          mapsrs,
          width,
          height,
          background,
          geom,
          geomtype,
          geomsrs,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of region types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegionTypes(options?: any): AxiosPromise<Array<Category>> {
      return localVarFp
        .getRegionTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of regions
     * @param {string} [label]
     * @param {string} [categoryId]
     * @param {number} [maxRecords]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions(
      label?: string,
      categoryId?: string,
      maxRecords?: number,
      options?: any
    ): AxiosPromise<ListRegionsResponse> {
      return localVarFp
        .getRegions(label, categoryId, maxRecords, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RegionsApi - object-oriented interface
 * @export
 * @class RegionsApi
 * @extends {BaseAPI}
 */
export class RegionsApi extends BaseAPI {
  /**
   * A rendering of the geometry as a png.
   * @summary Get geometry as image
   * @param {string} [mapsrs]
   * @param {number} [width] (optional) width of the image that is created. Only one of width and height are permitted
   * @param {number} [height] (optional) height of the image that is created. Only one of width and height are permitted
   * @param {string} [background] (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS Getmap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   * @param {string} [geom] (optional) a wkt or gml encoded geometry.
   * @param {string} [geomtype] (optional) defines if geom is wkt or gml. Allowed values are wkt and gml. if not specified the it is assumed the geometry is wkt
   * @param {string} [geomsrs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegionsApi
   */
  public getGeomAsImage(
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    geom?: string,
    geomtype?: string,
    geomsrs?: string,
    options?: AxiosRequestConfig
  ) {
    return RegionsApiFp(this.configuration)
      .getGeomAsImage(
        mapsrs,
        width,
        height,
        background,
        geom,
        geomtype,
        geomsrs,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of region types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegionsApi
   */
  public getRegionTypes(options?: AxiosRequestConfig) {
    return RegionsApiFp(this.configuration)
      .getRegionTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of regions
   * @param {string} [label]
   * @param {string} [categoryId]
   * @param {number} [maxRecords]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegionsApi
   */
  public getRegions(
    label?: string,
    categoryId?: string,
    maxRecords?: number,
    options?: AxiosRequestConfig
  ) {
    return RegionsApiFp(this.configuration)
      .getRegions(label, categoryId, maxRecords, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RegistriesApi - axios parameter creator
 * @export
 */
export const RegistriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a thesaurus.
     * @summary Delete a thesaurus by name
     * @param {string} thesaurus Thesaurus to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThesaurus: async (
      thesaurus: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists('deleteThesaurus', 'thesaurus', thesaurus);
      const localVarPath = `/registries/vocabularies/{thesaurus}`.replace(
        `{${'thesaurus'}}`,
        encodeURIComponent(String(thesaurus))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Extracts directory entries from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists('extractEntries', 'xpath', xpath);
      const localVarPath = `/registries/actions/entries/collect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter['xpath'] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter['identifierXpath'] = identifierXpath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get CRS
     * @param {string} id CRS identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrs: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCrs', 'id', id);
      const localVarPath = `/registries/crs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of CRS type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrsTypes: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/crs/types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
     * @summary Get a directory entry
     * @param {string} uuid Directory entry UUID.
     * @param {Array<string>} [process] Process
     * @param {string} [transformation] Transformation
     * @param {Array<string>} [lang] lang
     * @param {string} [schema] schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntry: async (
      uuid: string,
      process?: Array<string>,
      transformation?: string,
      lang?: Array<string>,
      schema?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getEntry', 'uuid', uuid);
      const localVarPath = `/registries/entries/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (process) {
        localVarQueryParameter['process'] = process;
      }

      if (transformation !== undefined) {
        localVarQueryParameter['transformation'] = transformation;
      }

      if (lang) {
        localVarQueryParameter['lang'] = lang;
      }

      if (schema !== undefined) {
        localVarQueryParameter['schema'] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById: async (
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getKeywordById', 'id', id);
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists('getKeywordById', 'thesaurus', thesaurus);
      const localVarPath = `/registries/vocabularies/keyword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (thesaurus !== undefined) {
        localVarQueryParameter['thesaurus'] = thesaurus;
      }

      if (lang) {
        localVarQueryParameter['lang'] = lang;
      }

      if (keywordOnly !== undefined) {
        localVarQueryParameter['keywordOnly'] = keywordOnly;
      }

      if (transformation !== undefined) {
        localVarQueryParameter['transformation'] = transformation;
      }

      if (langMap !== undefined) {
        localVarQueryParameter['langMap'] = langMap;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById1: async (
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getKeywordById1', 'id', id);
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists('getKeywordById1', 'thesaurus', thesaurus);
      const localVarPath = `/registries/vocabularies/keyword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (thesaurus !== undefined) {
        localVarQueryParameter['thesaurus'] = thesaurus;
      }

      if (lang) {
        localVarQueryParameter['lang'] = lang;
      }

      if (keywordOnly !== undefined) {
        localVarQueryParameter['keywordOnly'] = keywordOnly;
      }

      if (transformation !== undefined) {
        localVarQueryParameter['transformation'] = transformation;
      }

      if (langMap !== undefined) {
        localVarQueryParameter['langMap'] = langMap;
      }

      if (accept !== undefined && accept !== null) {
        localVarHeaderParameter['Accept'] = String(accept);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download the thesaurus in SKOS format.
     * @summary Download a thesaurus by name
     * @param {string} thesaurus Thesaurus to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThesaurus: async (
      thesaurus: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'thesaurus' is not null or undefined
      assertParamExists('getThesaurus', 'thesaurus', thesaurus);
      const localVarPath = `/registries/vocabularies/{thesaurus}`.replace(
        `{${'thesaurus'}}`,
        encodeURIComponent(String(thesaurus))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
     * @summary Uploads a CSV file and convert it to SKOS format
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [encoding] Encoding. Default is UTF-8.
     * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
     * @param {Array<string>} [languages] Thesaurus languages
     * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
     * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
     * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
     * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
     * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
     * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
     * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
     * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
     * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importCsvAsThesaurus: async (
      type?: 'external' | 'local',
      dir?: string,
      encoding?: string,
      thesaurusNs?: string,
      languages?: Array<string>,
      thesaurusTitle?: string,
      conceptIdColumn?: string,
      conceptLabelColumn?: string,
      conceptDescriptionColumn?: string,
      conceptBroaderIdColumn?: string,
      conceptNarrowerIdColumn?: string,
      conceptRelatedIdColumn?: string,
      conceptLinkSeparator?: string,
      importAsThesaurus?: boolean,
      inlineObject5?: InlineObject5,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies/import/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (dir !== undefined) {
        localVarQueryParameter['dir'] = dir;
      }

      if (encoding !== undefined) {
        localVarQueryParameter['encoding'] = encoding;
      }

      if (thesaurusNs !== undefined) {
        localVarQueryParameter['thesaurusNs'] = thesaurusNs;
      }

      if (languages) {
        localVarQueryParameter['languages'] = languages;
      }

      if (thesaurusTitle !== undefined) {
        localVarQueryParameter['thesaurusTitle'] = thesaurusTitle;
      }

      if (conceptIdColumn !== undefined) {
        localVarQueryParameter['conceptIdColumn'] = conceptIdColumn;
      }

      if (conceptLabelColumn !== undefined) {
        localVarQueryParameter['conceptLabelColumn'] = conceptLabelColumn;
      }

      if (conceptDescriptionColumn !== undefined) {
        localVarQueryParameter['conceptDescriptionColumn'] =
          conceptDescriptionColumn;
      }

      if (conceptBroaderIdColumn !== undefined) {
        localVarQueryParameter['conceptBroaderIdColumn'] =
          conceptBroaderIdColumn;
      }

      if (conceptNarrowerIdColumn !== undefined) {
        localVarQueryParameter['conceptNarrowerIdColumn'] =
          conceptNarrowerIdColumn;
      }

      if (conceptRelatedIdColumn !== undefined) {
        localVarQueryParameter['conceptRelatedIdColumn'] =
          conceptRelatedIdColumn;
      }

      if (conceptLinkSeparator !== undefined) {
        localVarQueryParameter['conceptLinkSeparator'] = conceptLinkSeparator;
      }

      if (importAsThesaurus !== undefined) {
        localVarQueryParameter['importAsThesaurus'] = importAsThesaurus;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject5,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
     * @summary Import spatial directory entries
     * @param {any} file The ZIP file to upload containing the Shapefile.
     * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
     * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
     * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
     * @param {string} [geomProjectionTo] geomProjectionTo
     * @param {boolean} [lenient] lenient
     * @param {string} [charset] Attribute table charset
     * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
     * @param {string} [process] Process
     * @param {string} [schema] Schema identifier
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {number} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importSpatialEntries: async (
      file: any,
      uuidAttribute?: string,
      uuidPattern?: string,
      descriptionAttribute?: string,
      geomProjectionTo?: string,
      lenient?: boolean,
      charset?: string,
      onlyBoundingBox?: boolean,
      process?: string,
      schema?: string,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('importSpatialEntries', 'file', file);
      const localVarPath = `/registries/actions/entries/import/spatial`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (uuidAttribute !== undefined) {
        localVarQueryParameter['uuidAttribute'] = uuidAttribute;
      }

      if (uuidPattern !== undefined) {
        localVarQueryParameter['uuidPattern'] = uuidPattern;
      }

      if (descriptionAttribute !== undefined) {
        localVarQueryParameter['descriptionAttribute'] = descriptionAttribute;
      }

      if (geomProjectionTo !== undefined) {
        localVarQueryParameter['geomProjectionTo'] = geomProjectionTo;
      }

      if (lenient !== undefined) {
        localVarQueryParameter['lenient'] = lenient;
      }

      if (charset !== undefined) {
        localVarQueryParameter['charset'] = charset;
      }

      if (onlyBoundingBox !== undefined) {
        localVarQueryParameter['onlyBoundingBox'] = onlyBoundingBox;
      }

      if (process !== undefined) {
        localVarQueryParameter['process'] = process;
      }

      if (schema !== undefined) {
        localVarQueryParameter['schema'] = schema;
      }

      if (uuidProcessing !== undefined) {
        localVarQueryParameter['uuidProcessing'] = uuidProcessing;
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Preview directory entries extracted from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewExtractedEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists('previewExtractedEntries', 'xpath', xpath);
      const localVarPath = `/registries/actions/entries/collect`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter['xpath'] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter['identifierXpath'] = identifierXpath;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Preview updated matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewUpdatedRecordEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists('previewUpdatedRecordEntries', 'xpath', xpath);
      const localVarPath = `/registries/actions/entries/synchronize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter['xpath'] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter['identifierXpath'] = identifierXpath;
      }

      if (propertiesToCopy) {
        localVarQueryParameter['propertiesToCopy'] = propertiesToCopy;
      }

      if (substituteAsXLink !== undefined) {
        localVarQueryParameter['substituteAsXLink'] = substituteAsXLink;
      }

      if (fq !== undefined) {
        localVarQueryParameter['fq'] = fq;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
     * @summary Search coordinate reference system (CRS)
     * @param {string} [q] Search value
     * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
     * @param {number} [rows] Number of results. Default is: 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCrs: async (
      q?: string,
      type?:
        | 'CoordinateReferenceSystem'
        | 'VerticalCRS'
        | 'GeographicCRS'
        | 'ProjectedCRS',
      rows?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/crs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (rows !== undefined) {
        localVarQueryParameter['rows'] = rows;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search keywords
     * @param {string} [q] Query
     * @param {string} [lang] Query in that language
     * @param {number} [rows] Number of rows
     * @param {number} [start] Start from
     * @param {Array<string>} [pLang] Return keyword information in one or more languages
     * @param {Array<string>} [thesaurus] Thesaurus identifier
     * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
     * @param {string} [uri] URI query
     * @param {string} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchKeywords: async (
      q?: string,
      lang?: string,
      rows?: number,
      start?: number,
      pLang?: Array<string>,
      thesaurus?: Array<string>,
      type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
      uri?: string,
      sort?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (lang !== undefined) {
        localVarQueryParameter['lang'] = lang;
      }

      if (rows !== undefined) {
        localVarQueryParameter['rows'] = rows;
      }

      if (start !== undefined) {
        localVarQueryParameter['start'] = start;
      }

      if (pLang) {
        localVarQueryParameter['pLang'] = pLang;
      }

      if (thesaurus) {
        localVarQueryParameter['thesaurus'] = thesaurus;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (uri !== undefined) {
        localVarQueryParameter['uri'] = uri;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Update matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecordEntries: async (
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xpath' is not null or undefined
      assertParamExists('updateRecordEntries', 'xpath', xpath);
      const localVarPath = `/registries/actions/entries/synchronize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuids) {
        localVarQueryParameter['uuids'] = uuids;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      if (xpath !== undefined) {
        localVarQueryParameter['xpath'] = xpath;
      }

      if (identifierXpath !== undefined) {
        localVarQueryParameter['identifierXpath'] = identifierXpath;
      }

      if (propertiesToCopy) {
        localVarQueryParameter['propertiesToCopy'] = propertiesToCopy;
      }

      if (substituteAsXLink !== undefined) {
        localVarQueryParameter['substituteAsXLink'] = substituteAsXLink;
      }

      if (fq !== undefined) {
        localVarQueryParameter['fq'] = fq;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from a file
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurus: async (
      type?: 'external' | 'local',
      dir?: string,
      stylesheet?: string,
      inlineObject4?: InlineObject4,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (dir !== undefined) {
        localVarQueryParameter['dir'] = dir;
      }

      if (stylesheet !== undefined) {
        localVarQueryParameter['stylesheet'] = stylesheet;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject4,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from URL or Registry
     * @param {string} [url] If set, try to download from the Internet.
     * @param {string} [registryUrl] If set, try to download from a registry.
     * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
     * @param {Array<string>} [registryLanguage] Languages to download from a registry.
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurusFromUrl: async (
      url?: string,
      registryUrl?: string,
      registryType?: 're3gistry' | 'ldRegistry',
      registryLanguage?: Array<string>,
      type?: 'external' | 'local',
      dir?: string,
      stylesheet?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/registries/vocabularies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (url !== undefined) {
        localVarQueryParameter['url'] = url;
      }

      if (registryUrl !== undefined) {
        localVarQueryParameter['registryUrl'] = registryUrl;
      }

      if (registryType !== undefined) {
        localVarQueryParameter['registryType'] = registryType;
      }

      if (registryLanguage) {
        localVarQueryParameter['registryLanguage'] = registryLanguage;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (dir !== undefined) {
        localVarQueryParameter['dir'] = dir;
      }

      if (stylesheet !== undefined) {
        localVarQueryParameter['stylesheet'] = stylesheet;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RegistriesApi - functional programming interface
 * @export
 */
export const RegistriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RegistriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a thesaurus.
     * @summary Delete a thesaurus by name
     * @param {string} thesaurus Thesaurus to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteThesaurus(
      thesaurus: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThesaurus(
        thesaurus,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Extracts directory entries from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async extractEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.extractEntries(
        xpath,
        uuids,
        bucket,
        identifierXpath,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get CRS
     * @param {string} id CRS identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCrs(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Crs>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCrs(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of CRS type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCrsTypes(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCrsTypes(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
     * @summary Get a directory entry
     * @param {string} uuid Directory entry UUID.
     * @param {Array<string>} [process] Process
     * @param {string} [transformation] Transformation
     * @param {Array<string>} [lang] lang
     * @param {string} [schema] schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntry(
      uuid: string,
      process?: Array<string>,
      transformation?: string,
      lang?: Array<string>,
      schema?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntry(
        uuid,
        process,
        transformation,
        lang,
        schema,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeywordById(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywordById(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeywordById1(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywordById1(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Download the thesaurus in SKOS format.
     * @summary Download a thesaurus by name
     * @param {string} thesaurus Thesaurus to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThesaurus(
      thesaurus: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThesaurus(
        thesaurus,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
     * @summary Uploads a CSV file and convert it to SKOS format
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [encoding] Encoding. Default is UTF-8.
     * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
     * @param {Array<string>} [languages] Thesaurus languages
     * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
     * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
     * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
     * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
     * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
     * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
     * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
     * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
     * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importCsvAsThesaurus(
      type?: 'external' | 'local',
      dir?: string,
      encoding?: string,
      thesaurusNs?: string,
      languages?: Array<string>,
      thesaurusTitle?: string,
      conceptIdColumn?: string,
      conceptLabelColumn?: string,
      conceptDescriptionColumn?: string,
      conceptBroaderIdColumn?: string,
      conceptNarrowerIdColumn?: string,
      conceptRelatedIdColumn?: string,
      conceptLinkSeparator?: string,
      importAsThesaurus?: boolean,
      inlineObject5?: InlineObject5,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.importCsvAsThesaurus(
          type,
          dir,
          encoding,
          thesaurusNs,
          languages,
          thesaurusTitle,
          conceptIdColumn,
          conceptLabelColumn,
          conceptDescriptionColumn,
          conceptBroaderIdColumn,
          conceptNarrowerIdColumn,
          conceptRelatedIdColumn,
          conceptLinkSeparator,
          importAsThesaurus,
          inlineObject5,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
     * @summary Import spatial directory entries
     * @param {any} file The ZIP file to upload containing the Shapefile.
     * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
     * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
     * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
     * @param {string} [geomProjectionTo] geomProjectionTo
     * @param {boolean} [lenient] lenient
     * @param {string} [charset] Attribute table charset
     * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
     * @param {string} [process] Process
     * @param {string} [schema] Schema identifier
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {number} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importSpatialEntries(
      file: any,
      uuidAttribute?: string,
      uuidPattern?: string,
      descriptionAttribute?: string,
      geomProjectionTo?: string,
      lenient?: boolean,
      charset?: string,
      onlyBoundingBox?: boolean,
      process?: string,
      schema?: string,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SimpleMetadataProcessingReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.importSpatialEntries(
          file,
          uuidAttribute,
          uuidPattern,
          descriptionAttribute,
          geomProjectionTo,
          lenient,
          charset,
          onlyBoundingBox,
          process,
          schema,
          uuidProcessing,
          group,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Preview directory entries extracted from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewExtractedEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewExtractedEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Preview updated matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewUpdatedRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.previewUpdatedRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
     * @summary Search coordinate reference system (CRS)
     * @param {string} [q] Search value
     * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
     * @param {number} [rows] Number of results. Default is: 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCrs(
      q?: string,
      type?:
        | 'CoordinateReferenceSystem'
        | 'VerticalCRS'
        | 'GeographicCRS'
        | 'ProjectedCRS',
      rows?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Crs>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchCrs(
        q,
        type,
        rows,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Search keywords
     * @param {string} [q] Query
     * @param {string} [lang] Query in that language
     * @param {number} [rows] Number of rows
     * @param {number} [start] Start from
     * @param {Array<string>} [pLang] Return keyword information in one or more languages
     * @param {Array<string>} [thesaurus] Thesaurus identifier
     * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
     * @param {string} [uri] URI query
     * @param {string} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchKeywords(
      q?: string,
      lang?: string,
      rows?: number,
      start?: number,
      pLang?: Array<string>,
      thesaurus?: Array<string>,
      type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
      uri?: string,
      sort?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchKeywords(
        q,
        lang,
        rows,
        start,
        pLang,
        thesaurus,
        type,
        uri,
        sort,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Update matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from a file
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadThesaurus(
      type?: 'external' | 'local',
      dir?: string,
      stylesheet?: string,
      inlineObject4?: InlineObject4,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadThesaurus(
        type,
        dir,
        stylesheet,
        inlineObject4,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from URL or Registry
     * @param {string} [url] If set, try to download from the Internet.
     * @param {string} [registryUrl] If set, try to download from a registry.
     * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
     * @param {Array<string>} [registryLanguage] Languages to download from a registry.
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadThesaurusFromUrl(
      url?: string,
      registryUrl?: string,
      registryType?: 're3gistry' | 'ldRegistry',
      registryLanguage?: Array<string>,
      type?: 'external' | 'local',
      dir?: string,
      stylesheet?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uploadThesaurusFromUrl(
          url,
          registryUrl,
          registryType,
          registryLanguage,
          type,
          dir,
          stylesheet,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RegistriesApi - factory interface
 * @export
 */
export const RegistriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RegistriesApiFp(configuration);
  return {
    /**
     * Delete a thesaurus.
     * @summary Delete a thesaurus by name
     * @param {string} thesaurus Thesaurus to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThesaurus(thesaurus: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteThesaurus(thesaurus, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Extracts directory entries from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .extractEntries(xpath, uuids, bucket, identifierXpath, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get CRS
     * @param {string} id CRS identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrs(id: string, options?: any): AxiosPromise<Crs> {
      return localVarFp
        .getCrs(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of CRS type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrsTypes(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .getCrsTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
     * @summary Get a directory entry
     * @param {string} uuid Directory entry UUID.
     * @param {Array<string>} [process] Process
     * @param {string} [transformation] Transformation
     * @param {Array<string>} [lang] lang
     * @param {string} [schema] schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntry(
      uuid: string,
      process?: Array<string>,
      transformation?: string,
      lang?: Array<string>,
      schema?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getEntry(uuid, process, transformation, lang, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getKeywordById(
          id,
          thesaurus,
          lang,
          keywordOnly,
          transformation,
          langMap,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
     * @summary Get keyword by id
     * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
     * @param {string} thesaurus Thesaurus to look info for the keyword(s).
     * @param {Array<string>} [lang] Languages.
     * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
     * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
     * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
     * @param {string} [accept]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordById1(
      id: string,
      thesaurus: string,
      lang?: Array<string>,
      keywordOnly?: boolean,
      transformation?: string,
      langMap?: string,
      accept?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .getKeywordById1(
          id,
          thesaurus,
          lang,
          keywordOnly,
          transformation,
          langMap,
          accept,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Download the thesaurus in SKOS format.
     * @summary Download a thesaurus by name
     * @param {string} thesaurus Thesaurus to download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThesaurus(thesaurus: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getThesaurus(thesaurus, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
     * @summary Uploads a CSV file and convert it to SKOS format
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [encoding] Encoding. Default is UTF-8.
     * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
     * @param {Array<string>} [languages] Thesaurus languages
     * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
     * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
     * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
     * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
     * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
     * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
     * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
     * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
     * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importCsvAsThesaurus(
      type?: 'external' | 'local',
      dir?: string,
      encoding?: string,
      thesaurusNs?: string,
      languages?: Array<string>,
      thesaurusTitle?: string,
      conceptIdColumn?: string,
      conceptLabelColumn?: string,
      conceptDescriptionColumn?: string,
      conceptBroaderIdColumn?: string,
      conceptNarrowerIdColumn?: string,
      conceptRelatedIdColumn?: string,
      conceptLinkSeparator?: string,
      importAsThesaurus?: boolean,
      inlineObject5?: InlineObject5,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .importCsvAsThesaurus(
          type,
          dir,
          encoding,
          thesaurusNs,
          languages,
          thesaurusTitle,
          conceptIdColumn,
          conceptLabelColumn,
          conceptDescriptionColumn,
          conceptBroaderIdColumn,
          conceptNarrowerIdColumn,
          conceptRelatedIdColumn,
          conceptLinkSeparator,
          importAsThesaurus,
          inlineObject5,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
     * @summary Import spatial directory entries
     * @param {any} file The ZIP file to upload containing the Shapefile.
     * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
     * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
     * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
     * @param {string} [geomProjectionTo] geomProjectionTo
     * @param {boolean} [lenient] lenient
     * @param {string} [charset] Attribute table charset
     * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
     * @param {string} [process] Process
     * @param {string} [schema] Schema identifier
     * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
     * @param {number} [group] The group the record is attached to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importSpatialEntries(
      file: any,
      uuidAttribute?: string,
      uuidPattern?: string,
      descriptionAttribute?: string,
      geomProjectionTo?: string,
      lenient?: boolean,
      charset?: string,
      onlyBoundingBox?: boolean,
      process?: string,
      schema?: string,
      uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
      group?: number,
      options?: any
    ): AxiosPromise<SimpleMetadataProcessingReport> {
      return localVarFp
        .importSpatialEntries(
          file,
          uuidAttribute,
          uuidPattern,
          descriptionAttribute,
          geomProjectionTo,
          lenient,
          charset,
          onlyBoundingBox,
          process,
          schema,
          uuidProcessing,
          group,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
     * @summary Preview directory entries extracted from records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewExtractedEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewExtractedEntries(xpath, uuids, bucket, identifierXpath, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Preview updated matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewUpdatedRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .previewUpdatedRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
     * @summary Search coordinate reference system (CRS)
     * @param {string} [q] Search value
     * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
     * @param {number} [rows] Number of results. Default is: 100
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCrs(
      q?: string,
      type?:
        | 'CoordinateReferenceSystem'
        | 'VerticalCRS'
        | 'GeographicCRS'
        | 'ProjectedCRS',
      rows?: number,
      options?: any
    ): AxiosPromise<Array<Crs>> {
      return localVarFp
        .searchCrs(q, type, rows, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search keywords
     * @param {string} [q] Query
     * @param {string} [lang] Query in that language
     * @param {number} [rows] Number of rows
     * @param {number} [start] Start from
     * @param {Array<string>} [pLang] Return keyword information in one or more languages
     * @param {Array<string>} [thesaurus] Thesaurus identifier
     * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
     * @param {string} [uri] URI query
     * @param {string} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchKeywords(
      q?: string,
      lang?: string,
      rows?: number,
      start?: number,
      pLang?: Array<string>,
      thesaurus?: Array<string>,
      type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
      uri?: string,
      sort?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .searchKeywords(
          q,
          lang,
          rows,
          start,
          pLang,
          thesaurus,
          type,
          uri,
          sort,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
     * @summary Update matching entries in records
     * @param {string} xpath XPath of the elements to extract as entry.
     * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
     * @param {string} [bucket] Selection bucket name
     * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
     * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
     * @param {boolean} [substituteAsXLink] Replace entry by XLink.
     * @param {string} [fq] Filter query for directory search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecordEntries(
      xpath: string,
      uuids?: Array<string>,
      bucket?: string,
      identifierXpath?: string,
      propertiesToCopy?: Array<string>,
      substituteAsXLink?: boolean,
      fq?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .updateRecordEntries(
          xpath,
          uuids,
          bucket,
          identifierXpath,
          propertiesToCopy,
          substituteAsXLink,
          fq,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from a file
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurus(
      type?: 'external' | 'local',
      dir?: string,
      stylesheet?: string,
      inlineObject4?: InlineObject4,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .uploadThesaurus(type, dir, stylesheet, inlineObject4, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Uploads a new thesaurus.
     * @summary Uploads a new thesaurus from URL or Registry
     * @param {string} [url] If set, try to download from the Internet.
     * @param {string} [registryUrl] If set, try to download from a registry.
     * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
     * @param {Array<string>} [registryLanguage] Languages to download from a registry.
     * @param {'external' | 'local'} [type] Local or external (default).
     * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
     * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadThesaurusFromUrl(
      url?: string,
      registryUrl?: string,
      registryType?: 're3gistry' | 'ldRegistry',
      registryLanguage?: Array<string>,
      type?: 'external' | 'local',
      dir?: string,
      stylesheet?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .uploadThesaurusFromUrl(
          url,
          registryUrl,
          registryType,
          registryLanguage,
          type,
          dir,
          stylesheet,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RegistriesApi - object-oriented interface
 * @export
 * @class RegistriesApi
 * @extends {BaseAPI}
 */
export class RegistriesApi extends BaseAPI {
  /**
   * Delete a thesaurus.
   * @summary Delete a thesaurus by name
   * @param {string} thesaurus Thesaurus to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public deleteThesaurus(thesaurus: string, options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .deleteThesaurus(thesaurus, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
   * @summary Extracts directory entries from records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .extractEntries(xpath, uuids, bucket, identifierXpath, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get CRS
   * @param {string} id CRS identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getCrs(id: string, options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .getCrs(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of CRS type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getCrsTypes(options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .getCrsTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
   * @summary Get a directory entry
   * @param {string} uuid Directory entry UUID.
   * @param {Array<string>} [process] Process
   * @param {string} [transformation] Transformation
   * @param {Array<string>} [lang] lang
   * @param {string} [schema] schema
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .getEntry(uuid, process, transformation, lang, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
   * @summary Get keyword by id
   * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
   * @param {string} thesaurus Thesaurus to look info for the keyword(s).
   * @param {Array<string>} [lang] Languages.
   * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
   * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .getKeywordById(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \'to-iso19139-keyword\' is the default and return an ISO19139 snippet.\'to-iso19139-keyword-as-xlink\' return an XLinked element. Custom transformation can be create on a per schema basis.
   * @summary Get keyword by id
   * @param {string} id Keyword identifier or list of keyword identifiers comma separated.
   * @param {string} thesaurus Thesaurus to look info for the keyword(s).
   * @param {Array<string>} [lang] Languages.
   * @param {boolean} [keywordOnly] Only print the keyword, no thesaurus information.
   * @param {string} [transformation] XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param {string} [langMap] langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param {string} [accept]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .getKeywordById1(
        id,
        thesaurus,
        lang,
        keywordOnly,
        transformation,
        langMap,
        accept,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download the thesaurus in SKOS format.
   * @summary Download a thesaurus by name
   * @param {string} thesaurus Thesaurus to download.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public getThesaurus(thesaurus: string, options?: AxiosRequestConfig) {
    return RegistriesApiFp(this.configuration)
      .getThesaurus(thesaurus, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
   * @summary Uploads a CSV file and convert it to SKOS format
   * @param {'external' | 'local'} [type] Local or external (default).
   * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param {string} [encoding] Encoding. Default is UTF-8.
   * @param {string} [thesaurusNs] Thesaurus namespace. Default is filename.
   * @param {Array<string>} [languages] Thesaurus languages
   * @param {string} [thesaurusTitle] Thesaurus title. Default is filename.
   * @param {string} [conceptIdColumn] Column name for concept id. Default is id.
   * @param {string} [conceptLabelColumn] Column name for concept label. Default is label.
   * @param {string} [conceptDescriptionColumn] Column name for concept description. Default is description.
   * @param {string} [conceptBroaderIdColumn] Column name for broader concept id. Default is broader.
   * @param {string} [conceptNarrowerIdColumn] Column name for narrower concept id. Default is narrower.
   * @param {string} [conceptRelatedIdColumn] Column name for related concept id. Default is related.
   * @param {string} [conceptLinkSeparator] Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
   * @param {boolean} [importAsThesaurus] Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
   * @param {InlineObject5} [inlineObject5]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    inlineObject5?: InlineObject5,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .importCsvAsThesaurus(
        type,
        dir,
        encoding,
        thesaurusNs,
        languages,
        thesaurusTitle,
        conceptIdColumn,
        conceptLabelColumn,
        conceptDescriptionColumn,
        conceptBroaderIdColumn,
        conceptNarrowerIdColumn,
        conceptRelatedIdColumn,
        conceptLinkSeparator,
        importAsThesaurus,
        inlineObject5,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
   * @summary Import spatial directory entries
   * @param {any} file The ZIP file to upload containing the Shapefile.
   * @param {string} [uuidAttribute] Attribute to use for UUID. If none, random UUID are generated.
   * @param {string} [uuidPattern] Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
   * @param {string} [descriptionAttribute] Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
   * @param {string} [geomProjectionTo] geomProjectionTo
   * @param {boolean} [lenient] lenient
   * @param {string} [charset] Attribute table charset
   * @param {boolean} [onlyBoundingBox] Create only bounding box for each spatial objects.
   * @param {string} [process] Process
   * @param {string} [schema] Schema identifier
   * @param {'GENERATEUUID' | 'NOTHING' | 'OVERWRITE'} [uuidProcessing] Record identifier processing.
   * @param {number} [group] The group the record is attached to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public importSpatialEntries(
    file: any,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: number,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .importSpatialEntries(
        file,
        uuidAttribute,
        uuidPattern,
        descriptionAttribute,
        geomProjectionTo,
        lenient,
        charset,
        onlyBoundingBox,
        process,
        schema,
        uuidProcessing,
        group,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).<br/><br/>Only records that the current user can edit are analyzed.
   * @summary Preview directory entries extracted from records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .previewExtractedEntries(xpath, uuids, bucket, identifierXpath, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @summary Preview updated matching entries in records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
   * @param {boolean} [substituteAsXLink] Replace entry by XLink.
   * @param {string} [fq] Filter query for directory search.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .previewUpdatedRecordEntries(
        xpath,
        uuids,
        bucket,
        identifierXpath,
        propertiesToCopy,
        substituteAsXLink,
        fq,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
   * @summary Search coordinate reference system (CRS)
   * @param {string} [q] Search value
   * @param {'CoordinateReferenceSystem' | 'VerticalCRS' | 'GeographicCRS' | 'ProjectedCRS'} [type] Type of CRS
   * @param {number} [rows] Number of results. Default is: 100
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .searchCrs(q, type, rows, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search keywords
   * @param {string} [q] Query
   * @param {string} [lang] Query in that language
   * @param {number} [rows] Number of rows
   * @param {number} [start] Start from
   * @param {Array<string>} [pLang] Return keyword information in one or more languages
   * @param {Array<string>} [thesaurus] Thesaurus identifier
   * @param {'STARTS_WITH' | 'CONTAINS' | 'MATCH'} [type] Type of search
   * @param {string} [uri] URI query
   * @param {string} [sort] Sort by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .searchKeywords(
        q,
        lang,
        rows,
        start,
        pLang,
        thesaurus,
        type,
        uri,
        sort,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally properties are preserved.<br/><br/>The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @summary Update matching entries in records
   * @param {string} xpath XPath of the elements to extract as entry.
   * @param {Array<string>} [uuids] Record UUIDs. If null current selection is used.
   * @param {string} [bucket] Selection bucket name
   * @param {string} [identifierXpath] XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param {Array<string>} [propertiesToCopy] List of XPath of properties to copy from record to matching entry.
   * @param {boolean} [substituteAsXLink] Replace entry by XLink.
   * @param {string} [fq] Filter query for directory search.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .updateRecordEntries(
        xpath,
        uuids,
        bucket,
        identifierXpath,
        propertiesToCopy,
        substituteAsXLink,
        fq,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Uploads a new thesaurus.
   * @summary Uploads a new thesaurus from a file
   * @param {'external' | 'local'} [type] Local or external (default).
   * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
   * @param {InlineObject4} [inlineObject4]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    inlineObject4?: InlineObject4,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .uploadThesaurus(type, dir, stylesheet, inlineObject4, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Uploads a new thesaurus.
   * @summary Uploads a new thesaurus from URL or Registry
   * @param {string} [url] If set, try to download from the Internet.
   * @param {string} [registryUrl] If set, try to download from a registry.
   * @param {'re3gistry' | 'ldRegistry'} [registryType] If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
   * @param {Array<string>} [registryLanguage] Languages to download from a registry.
   * @param {'external' | 'local'} [type] Local or external (default).
   * @param {string} [dir] Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param {string} [stylesheet] XSL to be use to convert the thesaurus before load. Default _none_.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistriesApi
   */
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    options?: AxiosRequestConfig
  ) {
    return RegistriesApiFp(this.configuration)
      .uploadThesaurusFromUrl(
        url,
        registryUrl,
        registryType,
        registryLanguage,
        type,
        dir,
        stylesheet,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RelatedApi - axios parameter creator
 * @export
 */
export const RelatedApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to all requested records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources for all requested metadatas
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {Array<string>} [uuid] Uuids of the metadatas you request the relations from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociatedResourcesForRecords: async (
      type?: Array<
        | 'children'
        | 'parent'
        | 'brothersAndSisters'
        | 'siblings'
        | 'associated'
        | 'services'
        | 'datasets'
        | 'fcats'
        | 'hasfeaturecats'
        | 'sources'
        | 'hassources'
        | 'related'
        | 'onlines'
        | 'thumbnails'
      >,
      uuid?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/related`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      if (uuid) {
        localVarQueryParameter['uuid'] = uuid;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RelatedApi - functional programming interface
 * @export
 */
export const RelatedApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RelatedApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to all requested records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources for all requested metadatas
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {Array<string>} [uuid] Uuids of the metadatas you request the relations from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssociatedResourcesForRecords(
      type?: Array<
        | 'children'
        | 'parent'
        | 'brothersAndSisters'
        | 'siblings'
        | 'associated'
        | 'services'
        | 'datasets'
        | 'fcats'
        | 'hasfeaturecats'
        | 'sources'
        | 'hassources'
        | 'related'
        | 'onlines'
        | 'thumbnails'
      >,
      uuid?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: RelatedResponse }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAssociatedResourcesForRecords(
          type,
          uuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RelatedApi - factory interface
 * @export
 */
export const RelatedApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RelatedApiFp(configuration);
  return {
    /**
     * Retrieve related services, datasets, onlines, thumbnails, sources, ... to all requested records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
     * @summary Get record related resources for all requested metadatas
     * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
     * @param {Array<string>} [uuid] Uuids of the metadatas you request the relations from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociatedResourcesForRecords(
      type?: Array<
        | 'children'
        | 'parent'
        | 'brothersAndSisters'
        | 'siblings'
        | 'associated'
        | 'services'
        | 'datasets'
        | 'fcats'
        | 'hasfeaturecats'
        | 'sources'
        | 'hassources'
        | 'related'
        | 'onlines'
        | 'thumbnails'
      >,
      uuid?: Array<string>,
      options?: any
    ): AxiosPromise<{ [key: string]: RelatedResponse }> {
      return localVarFp
        .getAssociatedResourcesForRecords(type, uuid, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RelatedApi - object-oriented interface
 * @export
 * @class RelatedApi
 * @extends {BaseAPI}
 */
export class RelatedApi extends BaseAPI {
  /**
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to all requested records.<br/><a href=\'http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\'>More info</a>
   * @summary Get record related resources for all requested metadatas
   * @param {Array<'children' | 'parent' | 'brothersAndSisters' | 'siblings' | 'associated' | 'services' | 'datasets' | 'fcats' | 'hasfeaturecats' | 'sources' | 'hassources' | 'related' | 'onlines' | 'thumbnails'>} [type] Type of related resource. If none, all resources are returned.
   * @param {Array<string>} [uuid] Uuids of the metadatas you request the relations from.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelatedApi
   */
  public getAssociatedResourcesForRecords(
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    uuid?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return RelatedApiFp(this.configuration)
      .getAssociatedResourcesForRecords(type, uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
     * @summary Search endpoint
     * @param {string} [bucket]
     * @param {string} [body] JSON request based on Elasticsearch API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    msearch: async (
      bucket?: string,
      body?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/search/records/_msearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
     * @summary Search endpoint
     * @param {string} [bucket]
     * @param {string} [body] JSON request based on Elasticsearch API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search: async (
      bucket?: string,
      body?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/search/records/_search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration);
  return {
    /**
     * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
     * @summary Search endpoint
     * @param {string} [bucket]
     * @param {string} [body] JSON request based on Elasticsearch API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async msearch(
      bucket?: string,
      body?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.msearch(
        bucket,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
     * @summary Search endpoint
     * @param {string} [bucket]
     * @param {string} [body] JSON request based on Elasticsearch API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async search(
      bucket?: string,
      body?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.search(
        bucket,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SearchApiFp(configuration);
  return {
    /**
     * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
     * @summary Search endpoint
     * @param {string} [bucket]
     * @param {string} [body] JSON request based on Elasticsearch API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    msearch(bucket?: string, body?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .msearch(bucket, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
     * @summary Search endpoint
     * @param {string} [bucket]
     * @param {string} [body] JSON request based on Elasticsearch API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search(bucket?: string, body?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .search(bucket, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
  /**
   * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
   * @summary Search endpoint
   * @param {string} [bucket]
   * @param {string} [body] JSON request based on Elasticsearch API.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public msearch(bucket?: string, body?: string, options?: AxiosRequestConfig) {
    return SearchApiFp(this.configuration)
      .msearch(bucket, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * See https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html for search parameters details.
   * @summary Search endpoint
   * @param {string} [bucket]
   * @param {string} [body] JSON request based on Elasticsearch API.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public search(bucket?: string, body?: string, options?: AxiosRequestConfig) {
    return SearchApiFp(this.configuration)
      .search(bucket, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SelectionsApi - axios parameter creator
 * @export
 */
export const SelectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Select one or more items
     * @param {string} bucket Bucket name
     * @param {Array<string>} [uuid] One or more record UUIDs. If null, select all in current search if bucket name is \&#39;metadata\&#39; (TODO: remove this limitation?).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add: async (
      bucket: string,
      uuid?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bucket' is not null or undefined
      assertParamExists('add', 'bucket', bucket);
      const localVarPath = `/selections/{bucket}`.replace(
        `{${'bucket'}}`,
        encodeURIComponent(String(bucket))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuid) {
        localVarQueryParameter['uuid'] = uuid;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Clear selection or remove items
     * @param {string} bucket Selection bucket name
     * @param {Array<string>} [uuid] One or more record UUIDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clear: async (
      bucket: string,
      uuid?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bucket' is not null or undefined
      assertParamExists('clear', 'bucket', bucket);
      const localVarPath = `/selections/{bucket}`.replace(
        `{${'bucket'}}`,
        encodeURIComponent(String(bucket))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuid) {
        localVarQueryParameter['uuid'] = uuid;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get current selection
     * @param {string} bucket Bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (
      bucket: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bucket' is not null or undefined
      assertParamExists('get', 'bucket', bucket);
      const localVarPath = `/selections/{bucket}`.replace(
        `{${'bucket'}}`,
        encodeURIComponent(String(bucket))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SelectionsApi - functional programming interface
 * @export
 */
export const SelectionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SelectionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Select one or more items
     * @param {string} bucket Bucket name
     * @param {Array<string>} [uuid] One or more record UUIDs. If null, select all in current search if bucket name is \&#39;metadata\&#39; (TODO: remove this limitation?).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add(
      bucket: string,
      uuid?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add(
        bucket,
        uuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Clear selection or remove items
     * @param {string} bucket Selection bucket name
     * @param {Array<string>} [uuid] One or more record UUIDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clear(
      bucket: string,
      uuid?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.clear(
        bucket,
        uuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get current selection
     * @param {string} bucket Bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(
      bucket: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SelectionsApi - factory interface
 * @export
 */
export const SelectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SelectionsApiFp(configuration);
  return {
    /**
     *
     * @summary Select one or more items
     * @param {string} bucket Bucket name
     * @param {Array<string>} [uuid] One or more record UUIDs. If null, select all in current search if bucket name is \&#39;metadata\&#39; (TODO: remove this limitation?).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add(
      bucket: string,
      uuid?: Array<string>,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .add(bucket, uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Clear selection or remove items
     * @param {string} bucket Selection bucket name
     * @param {Array<string>} [uuid] One or more record UUIDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clear(
      bucket: string,
      uuid?: Array<string>,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .clear(bucket, uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get current selection
     * @param {string} bucket Bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(bucket: string, options?: any): AxiosPromise<Set<string>> {
      return localVarFp
        .get(bucket, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SelectionsApi - object-oriented interface
 * @export
 * @class SelectionsApi
 * @extends {BaseAPI}
 */
export class SelectionsApi extends BaseAPI {
  /**
   *
   * @summary Select one or more items
   * @param {string} bucket Bucket name
   * @param {Array<string>} [uuid] One or more record UUIDs. If null, select all in current search if bucket name is \&#39;metadata\&#39; (TODO: remove this limitation?).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SelectionsApi
   */
  public add(
    bucket: string,
    uuid?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return SelectionsApiFp(this.configuration)
      .add(bucket, uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Clear selection or remove items
   * @param {string} bucket Selection bucket name
   * @param {Array<string>} [uuid] One or more record UUIDs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SelectionsApi
   */
  public clear(
    bucket: string,
    uuid?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return SelectionsApiFp(this.configuration)
      .clear(bucket, uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get current selection
   * @param {string} bucket Bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SelectionsApi
   */
  public get(bucket: string, options?: AxiosRequestConfig) {
    return SelectionsApiFp(this.configuration)
      .get(bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SiteApi - axios parameter creator
 * @export
 */
export const SiteApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * May be used when indexing task is hanging.
     * @summary Force to commit pending documents in index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitIndexChanges: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/commit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get site informations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInformation: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get last activity
     * @param {number} [lines] Number of lines to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivity: async (
      lines?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/logging/activity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lines !== undefined) {
        localVarQueryParameter['lines'] = lines;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get last activity in a ZIP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivityInAZip: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/logging/activity/zip`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get log files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogFiles: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/logging`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary robots.txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotsText: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/robots.txt`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provides also setting properties.
     * @summary Get settings with details
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsDetails: async (
      set?: Array<
        | 'INSPIRE'
        | 'CSW'
        | 'HARVESTER'
        | 'USER_GROUP_ONLY'
        | 'AUTH'
        | 'READ_ONLY'
        | 'INDEX'
        | 'SYSTEMINFO'
        | 'STAGING_PROFILE'
        | 'TYPE'
      >,
      key?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/settings/details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (set) {
        localVarQueryParameter['set'] = set;
      }

      if (key) {
        localVarQueryParameter['key'] = key;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return public settings for anonymous users, internals are allowed for authenticated.
     * @summary Get settings
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsSet: async (
      set?: Array<
        | 'INSPIRE'
        | 'CSW'
        | 'HARVESTER'
        | 'USER_GROUP_ONLY'
        | 'AUTH'
        | 'READ_ONLY'
        | 'INDEX'
        | 'SYSTEMINFO'
        | 'STAGING_PROFILE'
        | 'TYPE'
      >,
      key?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (set) {
        localVarQueryParameter['set'] = set;
      }

      if (key) {
        localVarQueryParameter['key'] = key;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get site (or portal) description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSiteOrPortalDescription: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get sitemap
     * @param {string} [format] Format (xml or html).
     * @param {number} [doc] page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemap: async (
      format?: string,
      doc?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sitemap`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      if (doc !== undefined) {
        localVarQueryParameter['doc'] = doc;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * To know when and how this version of the application was built.
     * @summary Get build details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/build`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * XSL transformations may be applied while importing or harvesting records.
     * @summary Get XSL tranformations available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getXslTransformations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/transforms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index
     * @param {boolean} [reset] Drop and recreate index
     * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
     * @param {boolean} [havingXlinkOnly] Records having only XLinks
     * @param {Array<string>} [indices] Index. By default only remove record index.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index1: async (
      reset?: boolean,
      asynchronous?: boolean,
      havingXlinkOnly?: boolean,
      indices?: Array<string>,
      bucket?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (reset !== undefined) {
        localVarQueryParameter['reset'] = reset;
      }

      if (asynchronous !== undefined) {
        localVarQueryParameter['asynchronous'] = asynchronous;
      }

      if (havingXlinkOnly !== undefined) {
        localVarQueryParameter['havingXlinkOnly'] = havingXlinkOnly;
      }

      if (indices) {
        localVarQueryParameter['indices'] = indices;
      }

      if (bucket !== undefined) {
        localVarQueryParameter['bucket'] = bucket;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index synchronized with database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexAndDbSynchronizationStatus: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/synchronized`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexCommit: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/commit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Index status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexStatus: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/index/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Is CAS enabled?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCasEnabled: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/isCasEnabled`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Is indexing?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isIndexing: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/indexing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Is in read-only mode?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isReadOnly: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/site/info/readonly`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save settings
     * @param {{ [key: string]: string; }} allRequestParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveSettings: async (
      allRequestParams: { [key: string]: string },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'allRequestParams' is not null or undefined
      assertParamExists('saveSettings', 'allRequestParams', allRequestParams);
      const localVarPath = `/site/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (allRequestParams !== undefined) {
        localVarQueryParameter['allRequestParams'] = allRequestParams;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
     * @summary Set catalog logo
     * @param {string} file Logo to use for the catalog
     * @param {boolean} [asFavicon] Create favicon too
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLogo: async (
      file: string,
      asFavicon?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('setLogo', 'file', file);
      const localVarPath = `/site/logo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (file !== undefined) {
        localVarQueryParameter['file'] = file;
      }

      if (asFavicon !== undefined) {
        localVarQueryParameter['asFavicon'] = asFavicon;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * TODO: Needs doc
     * @summary Update staging profile
     * @param {'testing' | 'development' | 'production'} profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStagingProfile: async (
      profile: 'testing' | 'development' | 'production',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'profile' is not null or undefined
      assertParamExists('updateStagingProfile', 'profile', profile);
      const localVarPath = `/site/info/staging/{profile}`.replace(
        `{${'profile'}}`,
        encodeURIComponent(String(profile))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SiteApi - functional programming interface
 * @export
 */
export const SiteApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SiteApiAxiosParamCreator(configuration);
  return {
    /**
     * May be used when indexing task is hanging.
     * @summary Force to commit pending documents in index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commitIndexChanges(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.commitIndexChanges(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get site informations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInformation(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SiteInformation>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInformation(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get last activity
     * @param {number} [lines] Number of lines to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLastActivity(
      lines?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLastActivity(
        lines,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get last activity in a ZIP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLastActivityInAZip(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLastActivityInAZip(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get log files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogFiles(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<LogFileResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogFiles(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary robots.txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRobotsText(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRobotsText(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Provides also setting properties.
     * @summary Get settings with details
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettingsDetails(
      set?: Array<
        | 'INSPIRE'
        | 'CSW'
        | 'HARVESTER'
        | 'USER_GROUP_ONLY'
        | 'AUTH'
        | 'READ_ONLY'
        | 'INDEX'
        | 'SYSTEMINFO'
        | 'STAGING_PROFILE'
        | 'TYPE'
      >,
      key?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Setting>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSettingsDetails(set, key, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return public settings for anonymous users, internals are allowed for authenticated.
     * @summary Get settings
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettingsSet(
      set?: Array<
        | 'INSPIRE'
        | 'CSW'
        | 'HARVESTER'
        | 'USER_GROUP_ONLY'
        | 'AUTH'
        | 'READ_ONLY'
        | 'INDEX'
        | 'SYSTEMINFO'
        | 'STAGING_PROFILE'
        | 'TYPE'
      >,
      key?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SettingsListResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingsSet(
        set,
        key,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get site (or portal) description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSiteOrPortalDescription(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SettingsListResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSiteOrPortalDescription(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get sitemap
     * @param {string} [format] Format (xml or html).
     * @param {number} [doc] page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSitemap(
      format?: string,
      doc?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSitemap(
        format,
        doc,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * To know when and how this version of the application was built.
     * @summary Get build details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemInfo(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemInfo(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * XSL transformations may be applied while importing or harvesting records.
     * @summary Get XSL tranformations available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getXslTransformations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getXslTransformations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index
     * @param {boolean} [reset] Drop and recreate index
     * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
     * @param {boolean} [havingXlinkOnly] Records having only XLinks
     * @param {Array<string>} [indices] Index. By default only remove record index.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async index1(
      reset?: boolean,
      asynchronous?: boolean,
      havingXlinkOnly?: boolean,
      indices?: Array<string>,
      bucket?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.index1(
        reset,
        asynchronous,
        havingXlinkOnly,
        indices,
        bucket,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index synchronized with database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async indexAndDbSynchronizationStatus(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.indexAndDbSynchronizationStatus(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async indexCommit(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.indexCommit(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Index status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async indexStatus(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.indexStatus(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Is CAS enabled?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isCasEnabled(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isCasEnabled(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Is indexing?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isIndexing(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isIndexing(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Is in read-only mode?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isReadOnly(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isReadOnly(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Save settings
     * @param {{ [key: string]: string; }} allRequestParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveSettings(
      allRequestParams: { [key: string]: string },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveSettings(
        allRequestParams,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
     * @summary Set catalog logo
     * @param {string} file Logo to use for the catalog
     * @param {boolean} [asFavicon] Create favicon too
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setLogo(
      file: string,
      asFavicon?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setLogo(
        file,
        asFavicon,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * TODO: Needs doc
     * @summary Update staging profile
     * @param {'testing' | 'development' | 'production'} profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateStagingProfile(
      profile: 'testing' | 'development' | 'production',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateStagingProfile(profile, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SiteApi - factory interface
 * @export
 */
export const SiteApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SiteApiFp(configuration);
  return {
    /**
     * May be used when indexing task is hanging.
     * @summary Force to commit pending documents in index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitIndexChanges(options?: any): AxiosPromise<void> {
      return localVarFp
        .commitIndexChanges(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get site informations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInformation(options?: any): AxiosPromise<SiteInformation> {
      return localVarFp
        .getInformation(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get last activity
     * @param {number} [lines] Number of lines to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivity(lines?: number, options?: any): AxiosPromise<string> {
      return localVarFp
        .getLastActivity(lines, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get last activity in a ZIP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastActivityInAZip(options?: any): AxiosPromise<void> {
      return localVarFp
        .getLastActivityInAZip(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get log files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogFiles(options?: any): AxiosPromise<Array<LogFileResponse>> {
      return localVarFp
        .getLogFiles(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary robots.txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotsText(options?: any): AxiosPromise<string> {
      return localVarFp
        .getRobotsText(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Provides also setting properties.
     * @summary Get settings with details
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsDetails(
      set?: Array<
        | 'INSPIRE'
        | 'CSW'
        | 'HARVESTER'
        | 'USER_GROUP_ONLY'
        | 'AUTH'
        | 'READ_ONLY'
        | 'INDEX'
        | 'SYSTEMINFO'
        | 'STAGING_PROFILE'
        | 'TYPE'
      >,
      key?: Array<string>,
      options?: any
    ): AxiosPromise<Array<Setting>> {
      return localVarFp
        .getSettingsDetails(set, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return public settings for anonymous users, internals are allowed for authenticated.
     * @summary Get settings
     * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
     * @param {Array<string>} [key] Setting key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsSet(
      set?: Array<
        | 'INSPIRE'
        | 'CSW'
        | 'HARVESTER'
        | 'USER_GROUP_ONLY'
        | 'AUTH'
        | 'READ_ONLY'
        | 'INDEX'
        | 'SYSTEMINFO'
        | 'STAGING_PROFILE'
        | 'TYPE'
      >,
      key?: Array<string>,
      options?: any
    ): AxiosPromise<SettingsListResponse> {
      return localVarFp
        .getSettingsSet(set, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get site (or portal) description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSiteOrPortalDescription(
      options?: any
    ): AxiosPromise<SettingsListResponse> {
      return localVarFp
        .getSiteOrPortalDescription(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get sitemap
     * @param {string} [format] Format (xml or html).
     * @param {number} [doc] page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSitemap(
      format?: string,
      doc?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getSitemap(format, doc, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * To know when and how this version of the application was built.
     * @summary Get build details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo(options?: any): AxiosPromise<SystemInfo> {
      return localVarFp
        .getSystemInfo(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * XSL transformations may be applied while importing or harvesting records.
     * @summary Get XSL tranformations available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getXslTransformations(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .getXslTransformations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index
     * @param {boolean} [reset] Drop and recreate index
     * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
     * @param {boolean} [havingXlinkOnly] Records having only XLinks
     * @param {Array<string>} [indices] Index. By default only remove record index.
     * @param {string} [bucket] Selection bucket name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    index1(
      reset?: boolean,
      asynchronous?: boolean,
      havingXlinkOnly?: boolean,
      indices?: Array<string>,
      bucket?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .index1(reset, asynchronous, havingXlinkOnly, indices, bucket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index synchronized with database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexAndDbSynchronizationStatus(
      options?: any
    ): AxiosPromise<{ [key: string]: object }> {
      return localVarFp
        .indexAndDbSynchronizationStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexCommit(options?: any): AxiosPromise<void> {
      return localVarFp
        .indexCommit(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Index status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexStatus(options?: any): AxiosPromise<Status> {
      return localVarFp
        .indexStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Is CAS enabled?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCasEnabled(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .isCasEnabled(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Is indexing?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isIndexing(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .isIndexing(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Is in read-only mode?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isReadOnly(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .isReadOnly(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Save settings
     * @param {{ [key: string]: string; }} allRequestParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveSettings(
      allRequestParams: { [key: string]: string },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .saveSettings(allRequestParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
     * @summary Set catalog logo
     * @param {string} file Logo to use for the catalog
     * @param {boolean} [asFavicon] Create favicon too
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLogo(
      file: string,
      asFavicon?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .setLogo(file, asFavicon, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * TODO: Needs doc
     * @summary Update staging profile
     * @param {'testing' | 'development' | 'production'} profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStagingProfile(
      profile: 'testing' | 'development' | 'production',
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateStagingProfile(profile, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SiteApi - object-oriented interface
 * @export
 * @class SiteApi
 * @extends {BaseAPI}
 */
export class SiteApi extends BaseAPI {
  /**
   * May be used when indexing task is hanging.
   * @summary Force to commit pending documents in index.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public commitIndexChanges(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .commitIndexChanges(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get site informations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getInformation(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getInformation(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get last activity
   * @param {number} [lines] Number of lines to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getLastActivity(lines?: number, options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getLastActivity(lines, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get last activity in a ZIP
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getLastActivityInAZip(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getLastActivityInAZip(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get log files
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getLogFiles(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getLogFiles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary robots.txt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getRobotsText(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getRobotsText(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Provides also setting properties.
   * @summary Get settings with details
   * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
   * @param {Array<string>} [key] Setting key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSettingsDetails(
    set?: Array<
      | 'INSPIRE'
      | 'CSW'
      | 'HARVESTER'
      | 'USER_GROUP_ONLY'
      | 'AUTH'
      | 'READ_ONLY'
      | 'INDEX'
      | 'SYSTEMINFO'
      | 'STAGING_PROFILE'
      | 'TYPE'
    >,
    key?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .getSettingsDetails(set, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return public settings for anonymous users, internals are allowed for authenticated.
   * @summary Get settings
   * @param {Array<'INSPIRE' | 'CSW' | 'HARVESTER' | 'USER_GROUP_ONLY' | 'AUTH' | 'READ_ONLY' | 'INDEX' | 'SYSTEMINFO' | 'STAGING_PROFILE' | 'TYPE'>} [set] Setting set. A common set of settings to retrieve.
   * @param {Array<string>} [key] Setting key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSettingsSet(
    set?: Array<
      | 'INSPIRE'
      | 'CSW'
      | 'HARVESTER'
      | 'USER_GROUP_ONLY'
      | 'AUTH'
      | 'READ_ONLY'
      | 'INDEX'
      | 'SYSTEMINFO'
      | 'STAGING_PROFILE'
      | 'TYPE'
    >,
    key?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .getSettingsSet(set, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get site (or portal) description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSiteOrPortalDescription(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getSiteOrPortalDescription(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get sitemap
   * @param {string} [format] Format (xml or html).
   * @param {number} [doc] page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSitemap(
    format?: string,
    doc?: number,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .getSitemap(format, doc, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * To know when and how this version of the application was built.
   * @summary Get build details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getSystemInfo(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getSystemInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * XSL transformations may be applied while importing or harvesting records.
   * @summary Get XSL tranformations available
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public getXslTransformations(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .getXslTransformations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index
   * @param {boolean} [reset] Drop and recreate index
   * @param {boolean} [asynchronous] Asynchronous mode (only on all records. ie. no selection bucket)
   * @param {boolean} [havingXlinkOnly] Records having only XLinks
   * @param {Array<string>} [indices] Index. By default only remove record index.
   * @param {string} [bucket] Selection bucket name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public index1(
    reset?: boolean,
    asynchronous?: boolean,
    havingXlinkOnly?: boolean,
    indices?: Array<string>,
    bucket?: string,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .index1(reset, asynchronous, havingXlinkOnly, indices, bucket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index synchronized with database
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public indexAndDbSynchronizationStatus(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .indexAndDbSynchronizationStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index commit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public indexCommit(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .indexCommit(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Index status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public indexStatus(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .indexStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Is CAS enabled?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public isCasEnabled(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .isCasEnabled(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Is indexing?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public isIndexing(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .isIndexing(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Is in read-only mode?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public isReadOnly(options?: AxiosRequestConfig) {
    return SiteApiFp(this.configuration)
      .isReadOnly(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Save settings
   * @param {{ [key: string]: string; }} allRequestParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public saveSettings(
    allRequestParams: { [key: string]: string },
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .saveSettings(allRequestParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Logos are stored in the data directory resources/images/harvesting as PNG or GIF images. When a logo is assigned to the catalog, a new image is created in images/logos/<catalogUuid>.png.
   * @summary Set catalog logo
   * @param {string} file Logo to use for the catalog
   * @param {boolean} [asFavicon] Create favicon too
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public setLogo(
    file: string,
    asFavicon?: boolean,
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .setLogo(file, asFavicon, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * TODO: Needs doc
   * @summary Update staging profile
   * @param {'testing' | 'development' | 'production'} profile
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SiteApi
   */
  public updateStagingProfile(
    profile: 'testing' | 'development' | 'production',
    options?: AxiosRequestConfig
  ) {
    return SiteApiFp(this.configuration)
      .updateStagingProfile(profile, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add a source
     * @param {Source} source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSource: async (
      source: Source,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'source' is not null or undefined
      assertParamExists('addSource', 'source', source);
      const localVarPath = `/sources`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        source,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a source
     * @param {string} sourceIdentifier Source identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSource: async (
      sourceIdentifier: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sourceIdentifier' is not null or undefined
      assertParamExists('deleteSource', 'sourceIdentifier', sourceIdentifier);
      const localVarPath = `/sources/{sourceIdentifier}`.replace(
        `{${'sourceIdentifier'}}`,
        encodeURIComponent(String(sourceIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
     * @summary Get all sources by type
     * @param {'portal' | 'subportal' | 'externalportal' | 'harvester'} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSourcesByType: async (
      type: 'portal' | 'subportal' | 'externalportal' | 'harvester',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('getSourcesByType', 'type', type);
      const localVarPath = `/sources/{type}`.replace(
        `{${'type'}}`,
        encodeURIComponent(String(type))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
     * @summary Get all sources
     * @param {number} [group] Group owner of the source (only applies to subportal).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubPortals1: async (
      group?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sources`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a source
     * @param {string} sourceIdentifier Source identifier
     * @param {Source} source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSource: async (
      sourceIdentifier: string,
      source: Source,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sourceIdentifier' is not null or undefined
      assertParamExists('updateSource', 'sourceIdentifier', sourceIdentifier);
      // verify required parameter 'source' is not null or undefined
      assertParamExists('updateSource', 'source', source);
      const localVarPath = `/sources/{sourceIdentifier}`.replace(
        `{${'sourceIdentifier'}}`,
        encodeURIComponent(String(sourceIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        source,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SourcesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add a source
     * @param {Source} source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addSource(
      source: Source,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addSource(
        source,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a source
     * @param {string} sourceIdentifier Source identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSource(
      sourceIdentifier: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(
        sourceIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
     * @summary Get all sources by type
     * @param {'portal' | 'subportal' | 'externalportal' | 'harvester'} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSourcesByType(
      type: 'portal' | 'subportal' | 'externalportal' | 'harvester',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSourcesByType(type, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
     * @summary Get all sources
     * @param {number} [group] Group owner of the source (only applies to subportal).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubPortals1(
      group?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSubPortals1(
        group,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a source
     * @param {string} sourceIdentifier Source identifier
     * @param {Source} source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSource(
      sourceIdentifier: string,
      source: Source,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(
        sourceIdentifier,
        source,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SourcesApiFp(configuration);
  return {
    /**
     *
     * @summary Add a source
     * @param {Source} source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSource(source: Source, options?: any): AxiosPromise<string> {
      return localVarFp
        .addSource(source, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a source
     * @param {string} sourceIdentifier Source identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSource(
      sourceIdentifier: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .deleteSource(sourceIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
     * @summary Get all sources by type
     * @param {'portal' | 'subportal' | 'externalportal' | 'harvester'} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSourcesByType(
      type: 'portal' | 'subportal' | 'externalportal' | 'harvester',
      options?: any
    ): AxiosPromise<Array<Source>> {
      return localVarFp
        .getSourcesByType(type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
     * @summary Get all sources
     * @param {number} [group] Group owner of the source (only applies to subportal).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubPortals1(group?: number, options?: any): AxiosPromise<Array<Source>> {
      return localVarFp
        .getSubPortals1(group, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a source
     * @param {string} sourceIdentifier Source identifier
     * @param {Source} source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSource(
      sourceIdentifier: string,
      source: Source,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updateSource(sourceIdentifier, source, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
  /**
   *
   * @summary Add a source
   * @param {Source} source
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SourcesApi
   */
  public addSource(source: Source, options?: AxiosRequestConfig) {
    return SourcesApiFp(this.configuration)
      .addSource(source, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a source
   * @param {string} sourceIdentifier Source identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SourcesApi
   */
  public deleteSource(sourceIdentifier: string, options?: AxiosRequestConfig) {
    return SourcesApiFp(this.configuration)
      .deleteSource(sourceIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
   * @summary Get all sources by type
   * @param {'portal' | 'subportal' | 'externalportal' | 'harvester'} type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SourcesApi
   */
  public getSourcesByType(
    type: 'portal' | 'subportal' | 'externalportal' | 'harvester',
    options?: AxiosRequestConfig
  ) {
    return SourcesApiFp(this.configuration)
      .getSourcesByType(type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sources are the local catalogue, subportal, external catalogue (when importing MEF files) or harvesters.
   * @summary Get all sources
   * @param {number} [group] Group owner of the source (only applies to subportal).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SourcesApi
   */
  public getSubPortals1(group?: number, options?: AxiosRequestConfig) {
    return SourcesApiFp(this.configuration)
      .getSubPortals1(group, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a source
   * @param {string} sourceIdentifier Source identifier
   * @param {Source} source
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SourcesApi
   */
  public updateSource(
    sourceIdentifier: string,
    source: Source,
    options?: AxiosRequestConfig
  ) {
    return SourcesApiFp(this.configuration)
      .updateSource(sourceIdentifier, source, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StandardsApi - axios parameter creator
 * @export
 */
export const StandardsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
     * @summary Get multiple codelist translations
     * @param {string} schema Schema identifier
     * @param {Array<string>} codelist Codelist element name or alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCodelistsTranslations: async (
      schema: string,
      codelist: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('getCodelistsTranslations', 'schema', schema);
      // verify required parameter 'codelist' is not null or undefined
      assertParamExists('getCodelistsTranslations', 'codelist', codelist);
      const localVarPath = `/standards/{schema}/codelists`.replace(
        `{${'schema'}}`,
        encodeURIComponent(String(schema))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (codelist) {
        localVarQueryParameter['codelist'] = codelist;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get batch editor configuration for a standard
     * @param {string} schema Schema identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration: async (
      schema: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('getConfiguration', 'schema', schema);
      const localVarPath = `/standards/{schema}/batchconfiguration`.replace(
        `{${'schema'}}`,
        encodeURIComponent(String(schema))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get batch editor configuration for standards
     * @param {Array<string>} [schema] Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigurations: async (
      schema?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/standards/batchconfiguration`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (schema) {
        localVarQueryParameter['schema'] = schema;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get editor associated resources panel configuration
     * @param {string} schema Schema identifier
     * @param {string} name Configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEditorAssociatedPanelConfiguration: async (
      schema: string,
      name: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists(
        'getEditorAssociatedPanelConfiguration',
        'schema',
        schema
      );
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getEditorAssociatedPanelConfiguration', 'name', name);
      const localVarPath =
        `/standards/{schema}/editor/associatedpanel/config/{name}.json`
          .replace(`{${'schema'}}`, encodeURIComponent(String(schema)))
          .replace(`{${'name'}}`, encodeURIComponent(String(name)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get descriptor details
     * @param {string} schema Schema identifier
     * @param {string} element Descriptor name
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementDetails: async (
      schema: string,
      element: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('getElementDetails', 'schema', schema);
      // verify required parameter 'element' is not null or undefined
      assertParamExists('getElementDetails', 'element', element);
      const localVarPath = `/standards/{schema}/descriptors/{element}/details`
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)))
        .replace(`{${'element'}}`, encodeURIComponent(String(element)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parent !== undefined) {
        localVarQueryParameter['parent'] = parent;
      }

      if (displayIf !== undefined) {
        localVarQueryParameter['displayIf'] = displayIf;
      }

      if (xpath !== undefined) {
        localVarQueryParameter['xpath'] = xpath;
      }

      if (isoType !== undefined) {
        localVarQueryParameter['isoType'] = isoType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get codelist details
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
     * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
     * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
     * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaCodelistsWithDetails: async (
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('getSchemaCodelistsWithDetails', 'schema', schema);
      // verify required parameter 'codelist' is not null or undefined
      assertParamExists('getSchemaCodelistsWithDetails', 'codelist', codelist);
      const localVarPath = `/standards/{schema}/codelists/{codelist}/details`
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)))
        .replace(`{${'codelist'}}`, encodeURIComponent(String(codelist)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parent !== undefined) {
        localVarQueryParameter['parent'] = parent;
      }

      if (displayIf !== undefined) {
        localVarQueryParameter['displayIf'] = displayIf;
      }

      if (xpath !== undefined) {
        localVarQueryParameter['xpath'] = xpath;
      }

      if (isoType !== undefined) {
        localVarQueryParameter['isoType'] = isoType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get codelist translations
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaTranslations: async (
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('getSchemaTranslations', 'schema', schema);
      // verify required parameter 'codelist' is not null or undefined
      assertParamExists('getSchemaTranslations', 'codelist', codelist);
      const localVarPath = `/standards/{schema}/codelists/{codelist}`
        .replace(`{${'schema'}}`, encodeURIComponent(String(schema)))
        .replace(`{${'codelist'}}`, encodeURIComponent(String(codelist)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parent !== undefined) {
        localVarQueryParameter['parent'] = parent;
      }

      if (displayIf !== undefined) {
        localVarQueryParameter['displayIf'] = displayIf;
      }

      if (xpath !== undefined) {
        localVarQueryParameter['xpath'] = xpath;
      }

      if (isoType !== undefined) {
        localVarQueryParameter['isoType'] = isoType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStandardConfigurations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/standards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reload standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reloadSchema: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/standards/reload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StandardsApi - functional programming interface
 * @export
 */
export const StandardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StandardsApiAxiosParamCreator(configuration);
  return {
    /**
     * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
     * @summary Get multiple codelist translations
     * @param {string} schema Schema identifier
     * @param {Array<string>} codelist Codelist element name or alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCodelistsTranslations(
      schema: string,
      codelist: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCodelistsTranslations(
          schema,
          codelist,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get batch editor configuration for a standard
     * @param {string} schema Schema identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfiguration(
      schema: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: BatchEditing }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConfiguration(schema, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get batch editor configuration for standards
     * @param {Array<string>} [schema] Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfigurations(
      schema?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: BatchEditing }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConfigurations(schema, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get editor associated resources panel configuration
     * @param {string} schema Schema identifier
     * @param {string} name Configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEditorAssociatedPanelConfiguration(
      schema: string,
      name: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEditorAssociatedPanelConfiguration(
          schema,
          name,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get descriptor details
     * @param {string} schema Schema identifier
     * @param {string} element Descriptor name
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getElementDetails(
      schema: string,
      element: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Element>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getElementDetails(
          schema,
          element,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get codelist details
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
     * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
     * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
     * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSchemaCodelistsWithDetails(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Codelist>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSchemaCodelistsWithDetails(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get codelist translations
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSchemaTranslations(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSchemaTranslations(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStandardConfigurations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStandardConfigurations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Reload standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reloadSchema(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reloadSchema(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * StandardsApi - factory interface
 * @export
 */
export const StandardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StandardsApiFp(configuration);
  return {
    /**
     * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
     * @summary Get multiple codelist translations
     * @param {string} schema Schema identifier
     * @param {Array<string>} codelist Codelist element name or alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCodelistsTranslations(
      schema: string,
      codelist: Array<string>,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getCodelistsTranslations(schema, codelist, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get batch editor configuration for a standard
     * @param {string} schema Schema identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(
      schema: string,
      options?: any
    ): AxiosPromise<{ [key: string]: BatchEditing }> {
      return localVarFp
        .getConfiguration(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get batch editor configuration for standards
     * @param {Array<string>} [schema] Schema identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigurations(
      schema?: Array<string>,
      options?: any
    ): AxiosPromise<{ [key: string]: BatchEditing }> {
      return localVarFp
        .getConfigurations(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get editor associated resources panel configuration
     * @param {string} schema Schema identifier
     * @param {string} name Configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEditorAssociatedPanelConfiguration(
      schema: string,
      name: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getEditorAssociatedPanelConfiguration(schema, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get descriptor details
     * @param {string} schema Schema identifier
     * @param {string} element Descriptor name
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementDetails(
      schema: string,
      element: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: any
    ): AxiosPromise<Element> {
      return localVarFp
        .getElementDetails(
          schema,
          element,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get codelist details
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
     * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
     * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
     * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaCodelistsWithDetails(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: any
    ): AxiosPromise<Codelist> {
      return localVarFp
        .getSchemaCodelistsWithDetails(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get codelist translations
     * @param {string} schema Schema identifier
     * @param {string} codelist Codelist element name or alias
     * @param {string} [parent]
     * @param {string} [displayIf]
     * @param {string} [xpath]
     * @param {string} [isoType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchemaTranslations(
      schema: string,
      codelist: string,
      parent?: string,
      displayIf?: string,
      xpath?: string,
      isoType?: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getSchemaTranslations(
          schema,
          codelist,
          parent,
          displayIf,
          xpath,
          isoType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStandardConfigurations(options?: any): AxiosPromise<void> {
      return localVarFp
        .getStandardConfigurations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Reload standards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reloadSchema(options?: any): AxiosPromise<void> {
      return localVarFp
        .reloadSchema(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StandardsApi - object-oriented interface
 * @export
 * @class StandardsApi
 * @extends {BaseAPI}
 */
export class StandardsApi extends BaseAPI {
  /**
   * All translations are combined in the same object. No distinction by codelist. This is useful if you need lots of codelists terms to be loaded.
   * @summary Get multiple codelist translations
   * @param {string} schema Schema identifier
   * @param {Array<string>} codelist Codelist element name or alias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getCodelistsTranslations(
    schema: string,
    codelist: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getCodelistsTranslations(schema, codelist, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get batch editor configuration for a standard
   * @param {string} schema Schema identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getConfiguration(schema: string, options?: AxiosRequestConfig) {
    return StandardsApiFp(this.configuration)
      .getConfiguration(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get batch editor configuration for standards
   * @param {Array<string>} [schema] Schema identifiers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getConfigurations(
    schema?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getConfigurations(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get editor associated resources panel configuration
   * @param {string} schema Schema identifier
   * @param {string} name Configuration identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getEditorAssociatedPanelConfiguration(
    schema: string,
    name: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getEditorAssociatedPanelConfiguration(schema, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get descriptor details
   * @param {string} schema Schema identifier
   * @param {string} element Descriptor name
   * @param {string} [parent]
   * @param {string} [displayIf]
   * @param {string} [xpath]
   * @param {string} [isoType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getElementDetails(
    schema: string,
    element: string,
    parent?: string,
    displayIf?: string,
    xpath?: string,
    isoType?: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getElementDetails(
        schema,
        element,
        parent,
        displayIf,
        xpath,
        isoType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get codelist details
   * @param {string} schema Schema identifier
   * @param {string} codelist Codelist element name or alias
   * @param {string} [parent] Parent name with namespace which may indicate a more precise label as defined in context attribute.
   * @param {string} [displayIf] Display if condition as defined in the codelist.xml file. Allows to select a more precise codelist when more than one is defined for same name.
   * @param {string} [xpath] XPath of the element to target which may indicate a more precise label as defined in context attribute.
   * @param {string} [isoType] ISO type of the element to target which may indicate a more precise label as defined in context attribute. (Same as context. TODO: Deprecate ?)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getSchemaCodelistsWithDetails(
    schema: string,
    codelist: string,
    parent?: string,
    displayIf?: string,
    xpath?: string,
    isoType?: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getSchemaCodelistsWithDetails(
        schema,
        codelist,
        parent,
        displayIf,
        xpath,
        isoType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get codelist translations
   * @param {string} schema Schema identifier
   * @param {string} codelist Codelist element name or alias
   * @param {string} [parent]
   * @param {string} [displayIf]
   * @param {string} [xpath]
   * @param {string} [isoType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getSchemaTranslations(
    schema: string,
    codelist: string,
    parent?: string,
    displayIf?: string,
    xpath?: string,
    isoType?: string,
    options?: AxiosRequestConfig
  ) {
    return StandardsApiFp(this.configuration)
      .getSchemaTranslations(
        schema,
        codelist,
        parent,
        displayIf,
        xpath,
        isoType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get standards
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public getStandardConfigurations(options?: AxiosRequestConfig) {
    return StandardsApiFp(this.configuration)
      .getStandardConfigurations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Reload standards
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandardsApi
   */
  public reloadSchema(options?: AxiosRequestConfig) {
    return StandardsApiFp(this.configuration)
      .reloadSchema(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete all record history and status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllHistoryAndStatus: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get status by type
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatusByType: async (
      type: 'workflow' | 'task' | 'event',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('getStatusByType', 'type', type);
      const localVarPath = `/status/{type}`.replace(
        `{${'type'}}`,
        encodeURIComponent(String(type))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatusList: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete all record history and status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAllHistoryAndStatus(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAllHistoryAndStatus(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get status by type
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatusByType(
      type: 'workflow' | 'task' | 'event',
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StatusValue>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusByType(
        type,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatusList(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StatusValue>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusList(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StatusApiFp(configuration);
  return {
    /**
     *
     * @summary Delete all record history and status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllHistoryAndStatus(options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteAllHistoryAndStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get status by type
     * @param {'workflow' | 'task' | 'event'} type Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatusByType(
      type: 'workflow' | 'task' | 'event',
      options?: any
    ): AxiosPromise<Array<StatusValue>> {
      return localVarFp
        .getStatusByType(type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatusList(options?: any): AxiosPromise<Array<StatusValue>> {
      return localVarFp
        .getStatusList(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
  /**
   *
   * @summary Delete all record history and status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public deleteAllHistoryAndStatus(options?: AxiosRequestConfig) {
    return StatusApiFp(this.configuration)
      .deleteAllHistoryAndStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get status by type
   * @param {'workflow' | 'task' | 'event'} type Type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public getStatusByType(
    type: 'workflow' | 'task' | 'event',
    options?: AxiosRequestConfig
  ) {
    return StatusApiFp(this.configuration)
      .getStatusByType(type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public getStatusList(options?: AxiosRequestConfig) {
    return StatusApiFp(this.configuration)
      .getStatusList(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Remove a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTag: async (
      tagIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tagIdentifier' is not null or undefined
      assertParamExists('deleteTag', 'tagIdentifier', tagIdentifier);
      const localVarPath = `/tags/{tagIdentifier}`.replace(
        `{${'tagIdentifier'}}`,
        encodeURIComponent(String(tagIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTag: async (
      tagIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tagIdentifier' is not null or undefined
      assertParamExists('getTag', 'tagIdentifier', tagIdentifier);
      const localVarPath = `/tags/{tagIdentifier}`.replace(
        `{${'tagIdentifier'}}`,
        encodeURIComponent(String(tagIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If labels are not defined, a default label is created with the category name for all languages.
     * @summary Create a tag
     * @param {MetadataCategory} metadataCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTag: async (
      metadataCategory: MetadataCategory,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataCategory' is not null or undefined
      assertParamExists('putTag', 'metadataCategory', metadataCategory);
      const localVarPath = `/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        metadataCategory,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {MetadataCategory} metadataCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTag: async (
      tagIdentifier: number,
      metadataCategory: MetadataCategory,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tagIdentifier' is not null or undefined
      assertParamExists('updateTag', 'tagIdentifier', tagIdentifier);
      // verify required parameter 'metadataCategory' is not null or undefined
      assertParamExists('updateTag', 'metadataCategory', metadataCategory);
      const localVarPath = `/tags/{tagIdentifier}`.replace(
        `{${'tagIdentifier'}}`,
        encodeURIComponent(String(tagIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        metadataCategory,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Remove a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTag(
      tagIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(
        tagIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTag(
      tagIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetadataCategory>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(
        tagIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTags(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MetadataCategory>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * If labels are not defined, a default label is created with the category name for all languages.
     * @summary Create a tag
     * @param {MetadataCategory} metadataCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putTag(
      metadataCategory: MetadataCategory,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putTag(
        metadataCategory,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {MetadataCategory} metadataCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTag(
      tagIdentifier: number,
      metadataCategory: MetadataCategory,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(
        tagIdentifier,
        metadataCategory,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TagsApiFp(configuration);
  return {
    /**
     *
     * @summary Remove a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTag(tagIdentifier: number, options?: any): AxiosPromise<string> {
      return localVarFp
        .deleteTag(tagIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTag(
      tagIdentifier: number,
      options?: any
    ): AxiosPromise<MetadataCategory> {
      return localVarFp
        .getTag(tagIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTags(options?: any): AxiosPromise<Array<MetadataCategory>> {
      return localVarFp
        .getTags(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * If labels are not defined, a default label is created with the category name for all languages.
     * @summary Create a tag
     * @param {MetadataCategory} metadataCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putTag(
      metadataCategory: MetadataCategory,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .putTag(metadataCategory, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a tag
     * @param {number} tagIdentifier Tag identifier
     * @param {MetadataCategory} metadataCategory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTag(
      tagIdentifier: number,
      metadataCategory: MetadataCategory,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updateTag(tagIdentifier, metadataCategory, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
  /**
   *
   * @summary Remove a tag
   * @param {number} tagIdentifier Tag identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public deleteTag(tagIdentifier: number, options?: AxiosRequestConfig) {
    return TagsApiFp(this.configuration)
      .deleteTag(tagIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a tag
   * @param {number} tagIdentifier Tag identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public getTag(tagIdentifier: number, options?: AxiosRequestConfig) {
    return TagsApiFp(this.configuration)
      .getTag(tagIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get tags
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public getTags(options?: AxiosRequestConfig) {
    return TagsApiFp(this.configuration)
      .getTags(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * If labels are not defined, a default label is created with the category name for all languages.
   * @summary Create a tag
   * @param {MetadataCategory} metadataCategory
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public putTag(
    metadataCategory: MetadataCategory,
    options?: AxiosRequestConfig
  ) {
    return TagsApiFp(this.configuration)
      .putTag(metadataCategory, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a tag
   * @param {number} tagIdentifier Tag identifier
   * @param {MetadataCategory} metadataCategory
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public updateTag(
    tagIdentifier: number,
    metadataCategory: MetadataCategory,
    options?: AxiosRequestConfig
  ) {
    return TagsApiFp(this.configuration)
      .updateTag(tagIdentifier, metadataCategory, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ToolsApi - axios parameter creator
 * @export
 */
export const ToolsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add or update all database translations.
     * @param {Array<Translations>} translations
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslations: async (
      translations: Array<Translations>,
      replace?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'translations' is not null or undefined
      assertParamExists('addTranslations', 'translations', translations);
      const localVarPath = `/i18n/db/translations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (replace !== undefined) {
        localVarQueryParameter['replace'] = replace;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        translations,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add or update database translations for a key.
     * @param {string} key
     * @param {{ [key: string]: string; }} requestBody
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslationsFor: async (
      key: string,
      requestBody: { [key: string]: string },
      replace?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists('addTranslationsFor', 'key', key);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('addTranslationsFor', 'requestBody', requestBody);
      const localVarPath = `/i18n/db/translations/{key}`.replace(
        `{${'key'}}`,
        encodeURIComponent(String(key))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (replace !== undefined) {
        localVarQueryParameter['replace'] = replace;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
     * @summary Generate a SLD with a new filter
     * @param {string} url The WMS server URL
     * @param {string} layers The layers
     * @param {string} filters The filters in JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    buildSLD: async (
      url: string,
      layers: string,
      filters: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'url' is not null or undefined
      assertParamExists('buildSLD', 'url', url);
      // verify required parameter 'layers' is not null or undefined
      assertParamExists('buildSLD', 'layers', layers);
      // verify required parameter 'filters' is not null or undefined
      assertParamExists('buildSLD', 'filters', filters);
      const localVarPath = `/tools/ogc/sld`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (url !== undefined) {
        localVarQueryParameter['url'] = url;
      }

      if (layers !== undefined) {
        localVarQueryParameter['layers'] = layers;
      }

      if (filters !== undefined) {
        localVarQueryParameter['filters'] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Call a migration step
     * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callStep: async (
      stepName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stepName' is not null or undefined
      assertParamExists('callStep', 'stepName', stepName);
      const localVarPath = `/tools/migration/steps/{stepName}`.replace(
        `{${'stepName'}}`,
        encodeURIComponent(String(stepName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Clean translation packages cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanTranslationsPackagesCache: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/cache`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete database translations.
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTranslations: async (
      key: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists('deleteTranslations', 'key', key);
      const localVarPath = `/i18n/db/translations/{key}`.replace(
        `{${'key'}}`,
        encodeURIComponent(String(key))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Clean all SLD generated previously
     * @summary Remove all SLD files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deteleSLD: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tools/ogc/sld`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download a SLD
     * @param {number} id The SLD identifier
     * @param {string} extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSLD: async (
      id: number,
      extension: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('downloadSLD', 'id', id);
      // verify required parameter 'extension' is not null or undefined
      assertParamExists('downloadSLD', 'extension', extension);
      const localVarPath = `/tools/ogc/sld/{id}.{extension}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'extension'}}`, encodeURIComponent(String(extension)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List custom user translations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomTranslations: async (
      type?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db/custom`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List database translations (used to overrides client application translations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDbTranslations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db/translations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the list of SLD available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSLD: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/tools/ogc/sld`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List translations for database description table
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslations: async (
      type?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of translation packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/packages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a translation package.
     * @param {string} pack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage1: async (
      pack: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pack' is not null or undefined
      assertParamExists('getTranslationsPackage1', 'pack', pack);
      const localVarPath = `/i18n/packages/{pack}`.replace(
        `{${'pack'}}`,
        encodeURIComponent(String(pack))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove all database translations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAllTranslations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/i18n/db/translations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send an email to the catalog feedback email.
     * @summary Test mail configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testMailConfiguration: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tools/mail/test`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ToolsApi - functional programming interface
 * @export
 */
export const ToolsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ToolsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add or update all database translations.
     * @param {Array<Translations>} translations
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTranslations(
      translations: Array<Translations>,
      replace?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTranslations(
        translations,
        replace,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add or update database translations for a key.
     * @param {string} key
     * @param {{ [key: string]: string; }} requestBody
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTranslationsFor(
      key: string,
      requestBody: { [key: string]: string },
      replace?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addTranslationsFor(
          key,
          requestBody,
          replace,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
     * @summary Generate a SLD with a new filter
     * @param {string} url The WMS server URL
     * @param {string} layers The layers
     * @param {string} filters The filters in JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async buildSLD(
      url: string,
      layers: string,
      filters: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.buildSLD(
        url,
        layers,
        filters,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Call a migration step
     * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callStep(
      stepName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callStep(
        stepName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Clean translation packages cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cleanTranslationsPackagesCache(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cleanTranslationsPackagesCache(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete database translations.
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTranslations(
      key: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteTranslations(key, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Clean all SLD generated previously
     * @summary Remove all SLD files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deteleSLD(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deteleSLD(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Download a SLD
     * @param {number} id The SLD identifier
     * @param {string} extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadSLD(
      id: number,
      extension: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSLD(
        id,
        extension,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List custom user translations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomTranslations(
      type?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Translations>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCustomTranslations(type, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List database translations (used to overrides client application translations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDbTranslations(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDbTranslations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the list of SLD available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSLD(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSLD(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List translations for database description table
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranslations(
      type?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTranslations(
        type,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of translation packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranslationsPackage(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: Array<string> }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTranslationsPackage(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a translation package.
     * @param {string} pack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranslationsPackage1(
      pack: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTranslationsPackage1(pack, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove all database translations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeAllTranslations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeAllTranslations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Send an email to the catalog feedback email.
     * @summary Test mail configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async testMailConfiguration(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.testMailConfiguration(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ToolsApi - factory interface
 * @export
 */
export const ToolsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ToolsApiFp(configuration);
  return {
    /**
     *
     * @summary Add or update all database translations.
     * @param {Array<Translations>} translations
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslations(
      translations: Array<Translations>,
      replace?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .addTranslations(translations, replace, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add or update database translations for a key.
     * @param {string} key
     * @param {{ [key: string]: string; }} requestBody
     * @param {boolean} [replace]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranslationsFor(
      key: string,
      requestBody: { [key: string]: string },
      replace?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .addTranslationsFor(key, requestBody, replace, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
     * @summary Generate a SLD with a new filter
     * @param {string} url The WMS server URL
     * @param {string} layers The layers
     * @param {string} filters The filters in JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    buildSLD(
      url: string,
      layers: string,
      filters: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .buildSLD(url, layers, filters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Call a migration step
     * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callStep(stepName: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .callStep(stepName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Clean translation packages cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cleanTranslationsPackagesCache(options?: any): AxiosPromise<void> {
      return localVarFp
        .cleanTranslationsPackagesCache(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete database translations.
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTranslations(key: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteTranslations(key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Clean all SLD generated previously
     * @summary Remove all SLD files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deteleSLD(options?: any): AxiosPromise<void> {
      return localVarFp
        .deteleSLD(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download a SLD
     * @param {number} id The SLD identifier
     * @param {string} extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSLD(
      id: number,
      extension: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadSLD(id, extension, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List custom user translations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomTranslations(
      type?: Array<string>,
      options?: any
    ): AxiosPromise<Array<Translations>> {
      return localVarFp
        .getCustomTranslations(type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List database translations (used to overrides client application translations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDbTranslations(options?: any): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getDbTranslations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the list of SLD available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSLD(options?: any): AxiosPromise<Array<string>> {
      return localVarFp
        .getSLD(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List translations for database description table
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslations(
      type?: Array<string>,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getTranslations(type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of translation packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage(
      options?: any
    ): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp
        .getTranslationsPackage(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a translation package.
     * @param {string} pack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranslationsPackage1(
      pack: string,
      options?: any
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getTranslationsPackage1(pack, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove all database translations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAllTranslations(options?: any): AxiosPromise<void> {
      return localVarFp
        .removeAllTranslations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Send an email to the catalog feedback email.
     * @summary Test mail configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testMailConfiguration(options?: any): AxiosPromise<string> {
      return localVarFp
        .testMailConfiguration(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ToolsApi - object-oriented interface
 * @export
 * @class ToolsApi
 * @extends {BaseAPI}
 */
export class ToolsApi extends BaseAPI {
  /**
   *
   * @summary Add or update all database translations.
   * @param {Array<Translations>} translations
   * @param {boolean} [replace]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public addTranslations(
    translations: Array<Translations>,
    replace?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .addTranslations(translations, replace, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add or update database translations for a key.
   * @param {string} key
   * @param {{ [key: string]: string; }} requestBody
   * @param {boolean} [replace]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public addTranslationsFor(
    key: string,
    requestBody: { [key: string]: string },
    replace?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .addTranslationsFor(key, requestBody, replace, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the currend SLD for the requested layers, add new filters in, save the SLD and return the new SLD URL.
   * @summary Generate a SLD with a new filter
   * @param {string} url The WMS server URL
   * @param {string} layers The layers
   * @param {string} filters The filters in JSON
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public buildSLD(
    url: string,
    layers: string,
    filters: string,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .buildSLD(url, layers, filters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Call a migration step
   * @param {string} stepName Class name to execute corresponding to a migration step. See DatabaseMigrationTask.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public callStep(stepName: string, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .callStep(stepName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Clean translation packages cache.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public cleanTranslationsPackagesCache(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .cleanTranslationsPackagesCache(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete database translations.
   * @param {string} key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public deleteTranslations(key: string, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .deleteTranslations(key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Clean all SLD generated previously
   * @summary Remove all SLD files
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public deteleSLD(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .deteleSLD(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download a SLD
   * @param {number} id The SLD identifier
   * @param {string} extension
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public downloadSLD(
    id: number,
    extension: string,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .downloadSLD(id, extension, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List custom user translations
   * @param {Array<string>} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getCustomTranslations(
    type?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ToolsApiFp(this.configuration)
      .getCustomTranslations(type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List database translations (used to overrides client application translations).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getDbTranslations(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getDbTranslations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the list of SLD available
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getSLD(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getSLD(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List translations for database description table
   * @param {Array<string>} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getTranslations(type?: Array<string>, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getTranslations(type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of translation packages.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getTranslationsPackage(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getTranslationsPackage(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a translation package.
   * @param {string} pack
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public getTranslationsPackage1(pack: string, options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .getTranslationsPackage1(pack, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove all database translations.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public removeAllTranslations(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .removeAllTranslations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send an email to the catalog feedback email.
   * @summary Test mail configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ToolsApi
   */
  public testMailConfiguration(options?: AxiosRequestConfig) {
    return ToolsApiFp(this.configuration)
      .testMailConfiguration(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UiApi - axios parameter creator
 * @export
 */
export const UiApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Remove a UI Configuration
     * @param {string} uiIdentifier UI configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUiConfiguration: async (
      uiIdentifier: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uiIdentifier' is not null or undefined
      assertParamExists('deleteUiConfiguration', 'uiIdentifier', uiIdentifier);
      const localVarPath = `/ui/{uiIdentifier}`.replace(
        `{${'uiIdentifier'}}`,
        encodeURIComponent(String(uiIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a UI configuration
     * @param {string} uiIdentifier UI identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUiConfiguration: async (
      uiIdentifier: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uiIdentifier' is not null or undefined
      assertParamExists('getUiConfiguration', 'uiIdentifier', uiIdentifier);
      const localVarPath = `/ui/{uiIdentifier}`.replace(
        `{${'uiIdentifier'}}`,
        encodeURIComponent(String(uiIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get UI configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUiConfigurations: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ui`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a UI configuration
     * @param {UiSetting} uiSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUiConfiguration: async (
      uiSetting: UiSetting,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uiSetting' is not null or undefined
      assertParamExists('putUiConfiguration', 'uiSetting', uiSetting);
      const localVarPath = `/ui`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uiSetting,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a UI configuration
     * @param {string} uiIdentifier UI configuration identifier
     * @param {UiSetting} uiSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUiConfiguration: async (
      uiIdentifier: string,
      uiSetting: UiSetting,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uiIdentifier' is not null or undefined
      assertParamExists('updateUiConfiguration', 'uiIdentifier', uiIdentifier);
      // verify required parameter 'uiSetting' is not null or undefined
      assertParamExists('updateUiConfiguration', 'uiSetting', uiSetting);
      const localVarPath = `/ui/{uiIdentifier}`.replace(
        `{${'uiIdentifier'}}`,
        encodeURIComponent(String(uiIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uiSetting,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UiApi - functional programming interface
 * @export
 */
export const UiApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UiApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Remove a UI Configuration
     * @param {string} uiIdentifier UI configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUiConfiguration(
      uiIdentifier: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUiConfiguration(
          uiIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a UI configuration
     * @param {string} uiIdentifier UI identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUiConfiguration(
      uiIdentifier: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UiSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUiConfiguration(
          uiIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get UI configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUiConfigurations(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UiSetting>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUiConfigurations(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a UI configuration
     * @param {UiSetting} uiSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUiConfiguration(
      uiSetting: UiSetting,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putUiConfiguration(uiSetting, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a UI configuration
     * @param {string} uiIdentifier UI configuration identifier
     * @param {UiSetting} uiSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUiConfiguration(
      uiIdentifier: string,
      uiSetting: UiSetting,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateUiConfiguration(
          uiIdentifier,
          uiSetting,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UiApi - factory interface
 * @export
 */
export const UiApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UiApiFp(configuration);
  return {
    /**
     *
     * @summary Remove a UI Configuration
     * @param {string} uiIdentifier UI configuration identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUiConfiguration(
      uiIdentifier: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .deleteUiConfiguration(uiIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a UI configuration
     * @param {string} uiIdentifier UI identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUiConfiguration(
      uiIdentifier: string,
      options?: any
    ): AxiosPromise<UiSetting> {
      return localVarFp
        .getUiConfiguration(uiIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get UI configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUiConfigurations(options?: any): AxiosPromise<Array<UiSetting>> {
      return localVarFp
        .getUiConfigurations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a UI configuration
     * @param {UiSetting} uiSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUiConfiguration(
      uiSetting: UiSetting,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .putUiConfiguration(uiSetting, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a UI configuration
     * @param {string} uiIdentifier UI configuration identifier
     * @param {UiSetting} uiSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUiConfiguration(
      uiIdentifier: string,
      uiSetting: UiSetting,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updateUiConfiguration(uiIdentifier, uiSetting, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UiApi - object-oriented interface
 * @export
 * @class UiApi
 * @extends {BaseAPI}
 */
export class UiApi extends BaseAPI {
  /**
   *
   * @summary Remove a UI Configuration
   * @param {string} uiIdentifier UI configuration identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UiApi
   */
  public deleteUiConfiguration(
    uiIdentifier: string,
    options?: AxiosRequestConfig
  ) {
    return UiApiFp(this.configuration)
      .deleteUiConfiguration(uiIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a UI configuration
   * @param {string} uiIdentifier UI identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UiApi
   */
  public getUiConfiguration(
    uiIdentifier: string,
    options?: AxiosRequestConfig
  ) {
    return UiApiFp(this.configuration)
      .getUiConfiguration(uiIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get UI configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UiApi
   */
  public getUiConfigurations(options?: AxiosRequestConfig) {
    return UiApiFp(this.configuration)
      .getUiConfigurations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a UI configuration
   * @param {UiSetting} uiSetting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UiApi
   */
  public putUiConfiguration(
    uiSetting: UiSetting,
    options?: AxiosRequestConfig
  ) {
    return UiApiFp(this.configuration)
      .putUiConfiguration(uiSetting, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a UI configuration
   * @param {string} uiIdentifier UI configuration identifier
   * @param {UiSetting} uiSetting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UiApi
   */
  public updateUiConfiguration(
    uiIdentifier: string,
    uiSetting: UiSetting,
    options?: AxiosRequestConfig
  ) {
    return UiApiFp(this.configuration)
      .updateUiConfiguration(uiIdentifier, uiSetting, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserfeedbackApi - axios parameter creator
 * @export
 */
export const UserfeedbackApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Removes a user feedback
     * @summary Removes a user feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFeedback: async (
      uuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteUserFeedback', 'uuid', uuid);
      const localVarPath = `/userfeedback/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Provides an average rating for a metadata record
     * @param {string} metadataUuid Metadata record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRating: async (
      metadataUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('getMetadataRating', 'metadataUuid', metadataUuid);
      const localVarPath = `/records/{metadataUuid}/userfeedbackrating`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of rating criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRatingCriteria: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/userfeedback/ratingcriteria`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Finds a specific user feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserComment: async (
      uuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getUserComment', 'uuid', uuid);
      const localVarPath = `/userfeedback/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  This list will include also the draft user feedback if the client is logged as reviewer.
     * @summary Finds a list of user feedback records.
     * @param {string} [metadataUuid] Metadata record UUID.
     * @param {number} [size] Maximum number of feedback to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserComments: async (
      metadataUuid?: string,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/userfeedback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (metadataUuid !== undefined) {
        localVarQueryParameter['metadataUuid'] = metadataUuid;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  This list will include also the draft user feedback if the client is logged as reviewer.
     * @summary Finds a list of user feedback for a specific records.
     * @param {string} metadataUuid Metadata record UUID.
     * @param {number} [size] Maximum number of feedback to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCommentsOnARecord: async (
      metadataUuid: string,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists(
        'getUserCommentsOnARecord',
        'metadataUuid',
        metadataUuid
      );
      const localVarPath = `/records/{metadataUuid}/userfeedback`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a user feedback in draft status if the user is not logged in.
     * @summary Creates a user feedback
     * @param {UserFeedbackDTO} userFeedbackDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newUserFeedback: async (
      userFeedbackDTO: UserFeedbackDTO,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userFeedbackDTO' is not null or undefined
      assertParamExists('newUserFeedback', 'userFeedbackDTO', userFeedbackDTO);
      const localVarPath = `/userfeedback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userFeedbackDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * For reviewers
     * @summary Publishes a feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishFeedback: async (
      uuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('publishFeedback', 'uuid', uuid);
      const localVarPath = `/userfeedback/{uuid}/publish`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send an email to catalogue administrator or record\'s contact
     * @param {string} metadataUuid Metadata record UUID.
     * @param {string} name User name.
     * @param {string} org User organisation.
     * @param {string} email User email address.
     * @param {string} comments A comment or question.
     * @param {string} [recaptcha] Recaptcha validation key.
     * @param {string} [phone] User phone number.
     * @param {string} [subject] Email subject.
     * @param {string} [_function] User function.
     * @param {string} [type] Comment type.
     * @param {string} [category] Comment category.
     * @param {string} [metadataEmail] List of record\&#39;s contact to send this email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailToContact: async (
      metadataUuid: string,
      name: string,
      org: string,
      email: string,
      comments: string,
      recaptcha?: string,
      phone?: string,
      subject?: string,
      _function?: string,
      type?: string,
      category?: string,
      metadataEmail?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'metadataUuid' is not null or undefined
      assertParamExists('sendEmailToContact', 'metadataUuid', metadataUuid);
      // verify required parameter 'name' is not null or undefined
      assertParamExists('sendEmailToContact', 'name', name);
      // verify required parameter 'org' is not null or undefined
      assertParamExists('sendEmailToContact', 'org', org);
      // verify required parameter 'email' is not null or undefined
      assertParamExists('sendEmailToContact', 'email', email);
      // verify required parameter 'comments' is not null or undefined
      assertParamExists('sendEmailToContact', 'comments', comments);
      const localVarPath = `/records/{metadataUuid}/alert`.replace(
        `{${'metadataUuid'}}`,
        encodeURIComponent(String(metadataUuid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (recaptcha !== undefined) {
        localVarQueryParameter['recaptcha'] = recaptcha;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (org !== undefined) {
        localVarQueryParameter['org'] = org;
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (comments !== undefined) {
        localVarQueryParameter['comments'] = comments;
      }

      if (phone !== undefined) {
        localVarQueryParameter['phone'] = phone;
      }

      if (subject !== undefined) {
        localVarQueryParameter['subject'] = subject;
      }

      if (_function !== undefined) {
        localVarQueryParameter['function'] = _function;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (metadataEmail !== undefined) {
        localVarQueryParameter['metadataEmail'] = metadataEmail;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserfeedbackApi - functional programming interface
 * @export
 */
export const UserfeedbackApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserfeedbackApiAxiosParamCreator(configuration);
  return {
    /**
     * Removes a user feedback
     * @summary Removes a user feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserFeedback(
      uuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserFeedback(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Provides an average rating for a metadata record
     * @param {string} metadataUuid Metadata record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMetadataRating(
      metadataUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingAverage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMetadataRating(
          metadataUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of rating criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRatingCriteria(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RatingCriteria>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRatingCriteria(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Finds a specific user feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserComment(
      uuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserFeedbackDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserComment(
        uuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *  This list will include also the draft user feedback if the client is logged as reviewer.
     * @summary Finds a list of user feedback records.
     * @param {string} [metadataUuid] Metadata record UUID.
     * @param {number} [size] Maximum number of feedback to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserComments(
      metadataUuid?: string,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserFeedbackDTO>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserComments(
        metadataUuid,
        size,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *  This list will include also the draft user feedback if the client is logged as reviewer.
     * @summary Finds a list of user feedback for a specific records.
     * @param {string} metadataUuid Metadata record UUID.
     * @param {number} [size] Maximum number of feedback to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserCommentsOnARecord(
      metadataUuid: string,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserFeedbackDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserCommentsOnARecord(
          metadataUuid,
          size,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Creates a user feedback in draft status if the user is not logged in.
     * @summary Creates a user feedback
     * @param {UserFeedbackDTO} userFeedbackDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async newUserFeedback(
      userFeedbackDTO: UserFeedbackDTO,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.newUserFeedback(
        userFeedbackDTO,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * For reviewers
     * @summary Publishes a feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishFeedback(
      uuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publishFeedback(
        uuid,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Send an email to catalogue administrator or record\'s contact
     * @param {string} metadataUuid Metadata record UUID.
     * @param {string} name User name.
     * @param {string} org User organisation.
     * @param {string} email User email address.
     * @param {string} comments A comment or question.
     * @param {string} [recaptcha] Recaptcha validation key.
     * @param {string} [phone] User phone number.
     * @param {string} [subject] Email subject.
     * @param {string} [_function] User function.
     * @param {string} [type] Comment type.
     * @param {string} [category] Comment category.
     * @param {string} [metadataEmail] List of record\&#39;s contact to send this email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendEmailToContact(
      metadataUuid: string,
      name: string,
      org: string,
      email: string,
      comments: string,
      recaptcha?: string,
      phone?: string,
      subject?: string,
      _function?: string,
      type?: string,
      category?: string,
      metadataEmail?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendEmailToContact(
          metadataUuid,
          name,
          org,
          email,
          comments,
          recaptcha,
          phone,
          subject,
          _function,
          type,
          category,
          metadataEmail,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserfeedbackApi - factory interface
 * @export
 */
export const UserfeedbackApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserfeedbackApiFp(configuration);
  return {
    /**
     * Removes a user feedback
     * @summary Removes a user feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFeedback(uuid: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .deleteUserFeedback(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Provides an average rating for a metadata record
     * @param {string} metadataUuid Metadata record UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetadataRating(
      metadataUuid: string,
      options?: any
    ): AxiosPromise<RatingAverage> {
      return localVarFp
        .getMetadataRating(metadataUuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of rating criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRatingCriteria(options?: any): AxiosPromise<Array<RatingCriteria>> {
      return localVarFp
        .getRatingCriteria(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Finds a specific user feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserComment(uuid: string, options?: any): AxiosPromise<UserFeedbackDTO> {
      return localVarFp
        .getUserComment(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  This list will include also the draft user feedback if the client is logged as reviewer.
     * @summary Finds a list of user feedback records.
     * @param {string} [metadataUuid] Metadata record UUID.
     * @param {number} [size] Maximum number of feedback to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserComments(
      metadataUuid?: string,
      size?: number,
      options?: any
    ): AxiosPromise<Array<UserFeedbackDTO>> {
      return localVarFp
        .getUserComments(metadataUuid, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  This list will include also the draft user feedback if the client is logged as reviewer.
     * @summary Finds a list of user feedback for a specific records.
     * @param {string} metadataUuid Metadata record UUID.
     * @param {number} [size] Maximum number of feedback to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCommentsOnARecord(
      metadataUuid: string,
      size?: number,
      options?: any
    ): AxiosPromise<Array<UserFeedbackDTO>> {
      return localVarFp
        .getUserCommentsOnARecord(metadataUuid, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a user feedback in draft status if the user is not logged in.
     * @summary Creates a user feedback
     * @param {UserFeedbackDTO} userFeedbackDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newUserFeedback(
      userFeedbackDTO: UserFeedbackDTO,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .newUserFeedback(userFeedbackDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * For reviewers
     * @summary Publishes a feedback
     * @param {string} uuid User feedback UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishFeedback(uuid: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .publishFeedback(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Send an email to catalogue administrator or record\'s contact
     * @param {string} metadataUuid Metadata record UUID.
     * @param {string} name User name.
     * @param {string} org User organisation.
     * @param {string} email User email address.
     * @param {string} comments A comment or question.
     * @param {string} [recaptcha] Recaptcha validation key.
     * @param {string} [phone] User phone number.
     * @param {string} [subject] Email subject.
     * @param {string} [_function] User function.
     * @param {string} [type] Comment type.
     * @param {string} [category] Comment category.
     * @param {string} [metadataEmail] List of record\&#39;s contact to send this email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailToContact(
      metadataUuid: string,
      name: string,
      org: string,
      email: string,
      comments: string,
      recaptcha?: string,
      phone?: string,
      subject?: string,
      _function?: string,
      type?: string,
      category?: string,
      metadataEmail?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .sendEmailToContact(
          metadataUuid,
          name,
          org,
          email,
          comments,
          recaptcha,
          phone,
          subject,
          _function,
          type,
          category,
          metadataEmail,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserfeedbackApi - object-oriented interface
 * @export
 * @class UserfeedbackApi
 * @extends {BaseAPI}
 */
export class UserfeedbackApi extends BaseAPI {
  /**
   * Removes a user feedback
   * @summary Removes a user feedback
   * @param {string} uuid User feedback UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public deleteUserFeedback(uuid: string, options?: AxiosRequestConfig) {
    return UserfeedbackApiFp(this.configuration)
      .deleteUserFeedback(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Provides an average rating for a metadata record
   * @param {string} metadataUuid Metadata record UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public getMetadataRating(metadataUuid: string, options?: AxiosRequestConfig) {
    return UserfeedbackApiFp(this.configuration)
      .getMetadataRating(metadataUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of rating criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public getRatingCriteria(options?: AxiosRequestConfig) {
    return UserfeedbackApiFp(this.configuration)
      .getRatingCriteria(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Finds a specific user feedback
   * @param {string} uuid User feedback UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public getUserComment(uuid: string, options?: AxiosRequestConfig) {
    return UserfeedbackApiFp(this.configuration)
      .getUserComment(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  This list will include also the draft user feedback if the client is logged as reviewer.
   * @summary Finds a list of user feedback records.
   * @param {string} [metadataUuid] Metadata record UUID.
   * @param {number} [size] Maximum number of feedback to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public getUserComments(
    metadataUuid?: string,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return UserfeedbackApiFp(this.configuration)
      .getUserComments(metadataUuid, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  This list will include also the draft user feedback if the client is logged as reviewer.
   * @summary Finds a list of user feedback for a specific records.
   * @param {string} metadataUuid Metadata record UUID.
   * @param {number} [size] Maximum number of feedback to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public getUserCommentsOnARecord(
    metadataUuid: string,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return UserfeedbackApiFp(this.configuration)
      .getUserCommentsOnARecord(metadataUuid, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a user feedback in draft status if the user is not logged in.
   * @summary Creates a user feedback
   * @param {UserFeedbackDTO} userFeedbackDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public newUserFeedback(
    userFeedbackDTO: UserFeedbackDTO,
    options?: AxiosRequestConfig
  ) {
    return UserfeedbackApiFp(this.configuration)
      .newUserFeedback(userFeedbackDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * For reviewers
   * @summary Publishes a feedback
   * @param {string} uuid User feedback UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public publishFeedback(uuid: string, options?: AxiosRequestConfig) {
    return UserfeedbackApiFp(this.configuration)
      .publishFeedback(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Send an email to catalogue administrator or record\'s contact
   * @param {string} metadataUuid Metadata record UUID.
   * @param {string} name User name.
   * @param {string} org User organisation.
   * @param {string} email User email address.
   * @param {string} comments A comment or question.
   * @param {string} [recaptcha] Recaptcha validation key.
   * @param {string} [phone] User phone number.
   * @param {string} [subject] Email subject.
   * @param {string} [_function] User function.
   * @param {string} [type] Comment type.
   * @param {string} [category] Comment category.
   * @param {string} [metadataEmail] List of record\&#39;s contact to send this email.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserfeedbackApi
   */
  public sendEmailToContact(
    metadataUuid: string,
    name: string,
    org: string,
    email: string,
    comments: string,
    recaptcha?: string,
    phone?: string,
    subject?: string,
    _function?: string,
    type?: string,
    category?: string,
    metadataEmail?: string,
    options?: AxiosRequestConfig
  ) {
    return UserfeedbackApiFp(this.configuration)
      .sendEmailToContact(
        metadataUuid,
        name,
        org,
        email,
        comments,
        recaptcha,
        phone,
        subject,
        _function,
        type,
        category,
        metadataEmail,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Check if a user property already exist
     * @param {string} property The user property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserPropertyExist: async (
      property: string,
      exist: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'property' is not null or undefined
      assertParamExists('checkUserPropertyExist', 'property', property);
      // verify required parameter 'exist' is not null or undefined
      assertParamExists('checkUserPropertyExist', 'exist', exist);
      const localVarPath = `/users/properties/{property}`.replace(
        `{${'property'}}`,
        encodeURIComponent(String(property))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (exist !== undefined) {
        localVarQueryParameter['exist'] = exist;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a catalog user.
     * @summary Creates a user
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      userDto: UserDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userDto' is not null or undefined
      assertParamExists('createUser', 'userDto', userDto);
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a catalog user by identifier.
     * @summary Delete a user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('deleteUser', 'userIdentifier', userIdentifier);
      const localVarPath = `/users/{userIdentifier}`.replace(
        `{${'userIdentifier'}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return users who actually owns one or more records.
     * @summary Get owners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordOwners: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/owners`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (
      userIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('getUser', 'userIdentifier', userIdentifier);
      const localVarPath = `/users/{userIdentifier}`.replace(
        `{${'userIdentifier'}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user identicon
     * @param {number} userIdentifier User identifier.
     * @param {number} [size] Size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdenticon: async (
      userIdentifier: number,
      size?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('getUserIdenticon', 'userIdentifier', userIdentifier);
      const localVarPath = `/users/{userIdentifier}.png`.replace(
        `{${'userIdentifier'}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
     * @summary Create user account
     * @param {UserRegisterDto} userRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      userRegisterDto: UserRegisterDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userRegisterDto' is not null or undefined
      assertParamExists('registerUser', 'userRegisterDto', userRegisterDto);
      const localVarPath = `/user/actions/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRegisterDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resets the user password.
     * @summary Resets user password
     * @param {number} userIdentifier User identifier.
     * @param {PasswordResetDto} passwordResetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword: async (
      userIdentifier: number,
      passwordResetDto: PasswordResetDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('resetUserPassword', 'userIdentifier', userIdentifier);
      // verify required parameter 'passwordResetDto' is not null or undefined
      assertParamExists(
        'resetUserPassword',
        'passwordResetDto',
        passwordResetDto
      );
      const localVarPath =
        `/users/{userIdentifier}/actions/forget-password`.replace(
          `{${'userIdentifier'}}`,
          encodeURIComponent(String(userIdentifier))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        passwordResetDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAllUserGroups: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve the user groups.
     * @summary Retrieve user groups
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveUserGroups: async (
      userIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('retrieveUserGroups', 'userIdentifier', userIdentifier);
      const localVarPath = `/users/{userIdentifier}/groups`.replace(
        `{${'userIdentifier'}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Transfer privileges
     * @param {TransferRequest} transferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOwners: async (
      transferRequest: TransferRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'transferRequest' is not null or undefined
      assertParamExists('saveOwners', 'transferRequest', transferRequest);
      const localVarPath = `/users/owners`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        transferRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
     * @summary Send user password reminder by email
     * @param {string} username The user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPasswordByEmail: async (
      username: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('sendPasswordByEmail', 'username', username);
      const localVarPath = `/user/{username}/actions/forgot-password`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a valid changekey by email first and then update your password.
     * @summary Update user password
     * @param {string} username The user name
     * @param {PasswordUpdateParameter} passwordUpdateParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword: async (
      username: string,
      passwordUpdateParameter: PasswordUpdateParameter,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('updatePassword', 'username', username);
      // verify required parameter 'passwordUpdateParameter' is not null or undefined
      assertParamExists(
        'updatePassword',
        'passwordUpdateParameter',
        passwordUpdateParameter
      );
      const localVarPath = `/user/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        passwordUpdateParameter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a catalog user.
     * @summary Update a user
     * @param {number} userIdentifier User identifier.
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userIdentifier: number,
      userDto: UserDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('updateUser', 'userIdentifier', userIdentifier);
      // verify required parameter 'userDto' is not null or undefined
      assertParamExists('updateUser', 'userDto', userDto);
      const localVarPath = `/users/{userIdentifier}`.replace(
        `{${'userIdentifier'}}`,
        encodeURIComponent(String(userIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Check if a user property already exist
     * @param {string} property The user property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkUserPropertyExist(
      property: string,
      exist: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkUserPropertyExist(
          property,
          exist,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Creates a catalog user.
     * @summary Creates a user
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      userDto: UserDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        userDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes a catalog user by identifier.
     * @summary Delete a user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        userIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return users who actually owns one or more records.
     * @summary Get owners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecordOwners(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OwnerResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordOwners(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        userIdentifier,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user identicon
     * @param {number} userIdentifier User identifier.
     * @param {number} [size] Size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserIdenticon(
      userIdentifier: number,
      size?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserIdenticon(
          userIdentifier,
          size,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
     * @summary Create user account
     * @param {UserRegisterDto} userRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      userRegisterDto: UserRegisterDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        userRegisterDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Resets the user password.
     * @summary Resets user password
     * @param {number} userIdentifier User identifier.
     * @param {PasswordResetDto} passwordResetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetUserPassword(
      userIdentifier: number,
      passwordResetDto: PasswordResetDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resetUserPassword(
          userIdentifier,
          passwordResetDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Retrieve all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveAllUserGroups(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserGroupsResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.retrieveAllUserGroups(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve the user groups.
     * @summary Retrieve user groups
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveUserGroups(
      userIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserGroup>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.retrieveUserGroups(
          userIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Transfer privileges
     * @param {TransferRequest} transferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveOwners(
      transferRequest: TransferRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveOwners(
        transferRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
     * @summary Send user password reminder by email
     * @param {string} username The user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendPasswordByEmail(
      username: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendPasswordByEmail(username, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a valid changekey by email first and then update your password.
     * @summary Update user password
     * @param {string} username The user name
     * @param {PasswordUpdateParameter} passwordUpdateParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePassword(
      username: string,
      passwordUpdateParameter: PasswordUpdateParameter,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(
        username,
        passwordUpdateParameter,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Updates a catalog user.
     * @summary Update a user
     * @param {number} userIdentifier User identifier.
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userIdentifier: number,
      userDto: UserDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        userIdentifier,
        userDto,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Check if a user property already exist
     * @param {string} property The user property to check
     * @param {string} exist The value to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserPropertyExist(
      property: string,
      exist: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .checkUserPropertyExist(property, exist, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a catalog user.
     * @summary Creates a user
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(userDto: UserDto, options?: any): AxiosPromise<string> {
      return localVarFp
        .createUser(userDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a catalog user by identifier.
     * @summary Delete a user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userIdentifier: number, options?: any): AxiosPromise<string> {
      return localVarFp
        .deleteUser(userIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return users who actually owns one or more records.
     * @summary Get owners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecordOwners(options?: any): AxiosPromise<Array<OwnerResponse>> {
      return localVarFp
        .getRecordOwners(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userIdentifier: number, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUser(userIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user identicon
     * @param {number} userIdentifier User identifier.
     * @param {number} [size] Size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdenticon(
      userIdentifier: number,
      size?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getUserIdenticon(userIdentifier, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
     * @summary Create user account
     * @param {UserRegisterDto} userRegisterDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      userRegisterDto: UserRegisterDto,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .registerUser(userRegisterDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Resets the user password.
     * @summary Resets user password
     * @param {number} userIdentifier User identifier.
     * @param {PasswordResetDto} passwordResetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(
      userIdentifier: number,
      passwordResetDto: PasswordResetDto,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .resetUserPassword(userIdentifier, passwordResetDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAllUserGroups(
      options?: any
    ): AxiosPromise<Array<UserGroupsResponse>> {
      return localVarFp
        .retrieveAllUserGroups(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve the user groups.
     * @summary Retrieve user groups
     * @param {number} userIdentifier User identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveUserGroups(
      userIdentifier: number,
      options?: any
    ): AxiosPromise<Array<UserGroup>> {
      return localVarFp
        .retrieveUserGroups(userIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Transfer privileges
     * @param {TransferRequest} transferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOwners(
      transferRequest: TransferRequest,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .saveOwners(transferRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
     * @summary Send user password reminder by email
     * @param {string} username The user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPasswordByEmail(username: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .sendPasswordByEmail(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a valid changekey by email first and then update your password.
     * @summary Update user password
     * @param {string} username The user name
     * @param {PasswordUpdateParameter} passwordUpdateParameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword(
      username: string,
      passwordUpdateParameter: PasswordUpdateParameter,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updatePassword(username, passwordUpdateParameter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a catalog user.
     * @summary Update a user
     * @param {number} userIdentifier User identifier.
     * @param {UserDto} userDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      userIdentifier: number,
      userDto: UserDto,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updateUser(userIdentifier, userDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Check if a user property already exist
   * @param {string} property The user property to check
   * @param {string} exist The value to search
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public checkUserPropertyExist(
    property: string,
    exist: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .checkUserPropertyExist(property, exist, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a catalog user.
   * @summary Creates a user
   * @param {UserDto} userDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(userDto: UserDto, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createUser(userDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a catalog user by identifier.
   * @summary Delete a user
   * @param {number} userIdentifier User identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(userIdentifier: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUser(userIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return users who actually owns one or more records.
   * @summary Get owners
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getRecordOwners(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getRecordOwners(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user
   * @param {number} userIdentifier User identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUser(userIdentifier: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUser(userIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user identicon
   * @param {number} userIdentifier User identifier.
   * @param {number} [size] Size.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserIdenticon(
    userIdentifier: number,
    size?: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUserIdenticon(userIdentifier, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * User is created with a registered user profile. username field is ignored and the email is used as username. Password is sent by email. Catalog administrator is also notified.
   * @summary Create user account
   * @param {UserRegisterDto} userRegisterDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public registerUser(
    userRegisterDto: UserRegisterDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .registerUser(userRegisterDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Resets the user password.
   * @summary Resets user password
   * @param {number} userIdentifier User identifier.
   * @param {PasswordResetDto} passwordResetDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public resetUserPassword(
    userIdentifier: number,
    passwordResetDto: PasswordResetDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .resetUserPassword(userIdentifier, passwordResetDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve all user groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public retrieveAllUserGroups(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .retrieveAllUserGroups(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve the user groups.
   * @summary Retrieve user groups
   * @param {number} userIdentifier User identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public retrieveUserGroups(
    userIdentifier: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .retrieveUserGroups(userIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Transfer privileges
   * @param {TransferRequest} transferRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public saveOwners(
    transferRequest: TransferRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .saveOwners(transferRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * An email is sent to the requested user with a link to reset his password. User MUST have an email to get the link. LDAP users will not be able to retrieve their password using this service.
   * @summary Send user password reminder by email
   * @param {string} username The user name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public sendPasswordByEmail(username: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .sendPasswordByEmail(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a valid changekey by email first and then update your password.
   * @summary Update user password
   * @param {string} username The user name
   * @param {PasswordUpdateParameter} passwordUpdateParameter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updatePassword(
    username: string,
    passwordUpdateParameter: PasswordUpdateParameter,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updatePassword(username, passwordUpdateParameter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates a catalog user.
   * @summary Update a user
   * @param {number} userIdentifier User identifier.
   * @param {UserDto} userDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(
    userIdentifier: number,
    userDto: UserDto,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateUser(userIdentifier, userDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersearchesApi - axios parameter creator
 * @export
 */
export const UsersearchesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a user search.
     * @summary Creates a user search
     * @param {UserSearchDto} userSearchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserCustomSearch: async (
      userSearchDto: UserSearchDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userSearchDto' is not null or undefined
      assertParamExists(
        'createUserCustomSearch',
        'userSearchDto',
        userSearchDto
      );
      const localVarPath = `/usersearches`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userSearchDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a user search by identifier.
     * @summary Delete a user search
     * @param {number} searchIdentifier Search identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserCustomSerach: async (
      searchIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchIdentifier' is not null or undefined
      assertParamExists(
        'deleteUserCustomSerach',
        'searchIdentifier',
        searchIdentifier
      );
      const localVarPath = `/usersearches/{searchIdentifier}`.replace(
        `{${'searchIdentifier'}}`,
        encodeURIComponent(String(searchIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user custom searches for all users (no paginated)
     * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured type search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserCustomSearches: async (
      featuredType?: 'HOME' | 'EDITOR_BOARD',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/usersearches/all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (featuredType !== undefined) {
        localVarQueryParameter['featuredType'] = featuredType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user custom searches for all users (paginated)
     * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured  type search.
     * @param {string} [search]
     * @param {number} [offset] From page
     * @param {number} [limit] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserCustomSearchesPage: async (
      featuredType?: 'HOME' | 'EDITOR_BOARD',
      search?: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/usersearches/allpaginated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (featuredType !== undefined) {
        localVarQueryParameter['featuredType'] = featuredType;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get featured user custom searches
     * @param {'HOME' | 'EDITOR_BOARD'} [type] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeaturedUserCustomSearches: async (
      type?: 'HOME' | 'EDITOR_BOARD',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/usersearches/featured`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get custom search
     * @param {number} searchIdentifier User search identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCustomSearch: async (
      searchIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchIdentifier' is not null or undefined
      assertParamExists(
        'getUserCustomSearch',
        'searchIdentifier',
        searchIdentifier
      );
      const localVarPath = `/usersearches/{searchIdentifier}`.replace(
        `{${'searchIdentifier'}}`,
        encodeURIComponent(String(searchIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user custom searches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCustomSearches: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/usersearches`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a user search
     * @param {number} searchIdentifier User search identifier
     * @param {UserSearchDto} userSearchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCustomUserSearch: async (
      searchIdentifier: number,
      userSearchDto: UserSearchDto,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchIdentifier' is not null or undefined
      assertParamExists(
        'updateCustomUserSearch',
        'searchIdentifier',
        searchIdentifier
      );
      // verify required parameter 'userSearchDto' is not null or undefined
      assertParamExists(
        'updateCustomUserSearch',
        'userSearchDto',
        userSearchDto
      );
      const localVarPath = `/usersearches/{searchIdentifier}`.replace(
        `{${'searchIdentifier'}}`,
        encodeURIComponent(String(searchIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userSearchDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersearchesApi - functional programming interface
 * @export
 */
export const UsersearchesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UsersearchesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a user search.
     * @summary Creates a user search
     * @param {UserSearchDto} userSearchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserCustomSearch(
      userSearchDto: UserSearchDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createUserCustomSearch(
          userSearchDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes a user search by identifier.
     * @summary Delete a user search
     * @param {number} searchIdentifier Search identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserCustomSerach(
      searchIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserCustomSerach(
          searchIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user custom searches for all users (no paginated)
     * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured type search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUserCustomSearches(
      featuredType?: 'HOME' | 'EDITOR_BOARD',
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserSearchDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllUserCustomSearches(
          featuredType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user custom searches for all users (paginated)
     * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured  type search.
     * @param {string} [search]
     * @param {number} [offset] From page
     * @param {number} [limit] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUserCustomSearchesPage(
      featuredType?: 'HOME' | 'EDITOR_BOARD',
      search?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PaginatedUserSearchResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllUserCustomSearchesPage(
          featuredType,
          search,
          offset,
          limit,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get featured user custom searches
     * @param {'HOME' | 'EDITOR_BOARD'} [type] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeaturedUserCustomSearches(
      type?: 'HOME' | 'EDITOR_BOARD',
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserSearchDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFeaturedUserCustomSearches(
          type,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get custom search
     * @param {number} searchIdentifier User search identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserCustomSearch(
      searchIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearchDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserCustomSearch(
          searchIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user custom searches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserCustomSearches(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserSearchDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserCustomSearches(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a user search
     * @param {number} searchIdentifier User search identifier
     * @param {UserSearchDto} userSearchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCustomUserSearch(
      searchIdentifier: number,
      userSearchDto: UserSearchDto,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateCustomUserSearch(
          searchIdentifier,
          userSearchDto,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersearchesApi - factory interface
 * @export
 */
export const UsersearchesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersearchesApiFp(configuration);
  return {
    /**
     * Creates a user search.
     * @summary Creates a user search
     * @param {UserSearchDto} userSearchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserCustomSearch(
      userSearchDto: UserSearchDto,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .createUserCustomSearch(userSearchDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a user search by identifier.
     * @summary Delete a user search
     * @param {number} searchIdentifier Search identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserCustomSerach(
      searchIdentifier: number,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .deleteUserCustomSerach(searchIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user custom searches for all users (no paginated)
     * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured type search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserCustomSearches(
      featuredType?: 'HOME' | 'EDITOR_BOARD',
      options?: any
    ): AxiosPromise<Array<UserSearchDto>> {
      return localVarFp
        .getAllUserCustomSearches(featuredType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user custom searches for all users (paginated)
     * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured  type search.
     * @param {string} [search]
     * @param {number} [offset] From page
     * @param {number} [limit] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserCustomSearchesPage(
      featuredType?: 'HOME' | 'EDITOR_BOARD',
      search?: string,
      offset?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<PaginatedUserSearchResponse> {
      return localVarFp
        .getAllUserCustomSearchesPage(
          featuredType,
          search,
          offset,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get featured user custom searches
     * @param {'HOME' | 'EDITOR_BOARD'} [type] Number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFeaturedUserCustomSearches(
      type?: 'HOME' | 'EDITOR_BOARD',
      options?: any
    ): AxiosPromise<Array<UserSearchDto>> {
      return localVarFp
        .getFeaturedUserCustomSearches(type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get custom search
     * @param {number} searchIdentifier User search identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCustomSearch(
      searchIdentifier: number,
      options?: any
    ): AxiosPromise<UserSearchDto> {
      return localVarFp
        .getUserCustomSearch(searchIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user custom searches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCustomSearches(options?: any): AxiosPromise<Array<UserSearchDto>> {
      return localVarFp
        .getUserCustomSearches(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a user search
     * @param {number} searchIdentifier User search identifier
     * @param {UserSearchDto} userSearchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCustomUserSearch(
      searchIdentifier: number,
      userSearchDto: UserSearchDto,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateCustomUserSearch(searchIdentifier, userSearchDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersearchesApi - object-oriented interface
 * @export
 * @class UsersearchesApi
 * @extends {BaseAPI}
 */
export class UsersearchesApi extends BaseAPI {
  /**
   * Creates a user search.
   * @summary Creates a user search
   * @param {UserSearchDto} userSearchDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public createUserCustomSearch(
    userSearchDto: UserSearchDto,
    options?: AxiosRequestConfig
  ) {
    return UsersearchesApiFp(this.configuration)
      .createUserCustomSearch(userSearchDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a user search by identifier.
   * @summary Delete a user search
   * @param {number} searchIdentifier Search identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public deleteUserCustomSerach(
    searchIdentifier: number,
    options?: AxiosRequestConfig
  ) {
    return UsersearchesApiFp(this.configuration)
      .deleteUserCustomSerach(searchIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user custom searches for all users (no paginated)
   * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured type search.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public getAllUserCustomSearches(
    featuredType?: 'HOME' | 'EDITOR_BOARD',
    options?: AxiosRequestConfig
  ) {
    return UsersearchesApiFp(this.configuration)
      .getAllUserCustomSearches(featuredType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user custom searches for all users (paginated)
   * @param {'HOME' | 'EDITOR_BOARD'} [featuredType] Featured  type search.
   * @param {string} [search]
   * @param {number} [offset] From page
   * @param {number} [limit] Number of records to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public getAllUserCustomSearchesPage(
    featuredType?: 'HOME' | 'EDITOR_BOARD',
    search?: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig
  ) {
    return UsersearchesApiFp(this.configuration)
      .getAllUserCustomSearchesPage(
        featuredType,
        search,
        offset,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get featured user custom searches
   * @param {'HOME' | 'EDITOR_BOARD'} [type] Number of records to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public getFeaturedUserCustomSearches(
    type?: 'HOME' | 'EDITOR_BOARD',
    options?: AxiosRequestConfig
  ) {
    return UsersearchesApiFp(this.configuration)
      .getFeaturedUserCustomSearches(type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get custom search
   * @param {number} searchIdentifier User search identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public getUserCustomSearch(
    searchIdentifier: number,
    options?: AxiosRequestConfig
  ) {
    return UsersearchesApiFp(this.configuration)
      .getUserCustomSearch(searchIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user custom searches
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public getUserCustomSearches(options?: AxiosRequestConfig) {
    return UsersearchesApiFp(this.configuration)
      .getUserCustomSearches(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a user search
   * @param {number} searchIdentifier User search identifier
   * @param {UserSearchDto} userSearchDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersearchesApi
   */
  public updateCustomUserSearch(
    searchIdentifier: number,
    userSearchDto: UserSearchDto,
    options?: AxiosRequestConfig
  ) {
    return UsersearchesApiFp(this.configuration)
      .updateCustomUserSearch(searchIdentifier, userSearchDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserselectionsApi - axios parameter creator
 * @export
 */
export const UserselectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add items to a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuid] One or more record UUIDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addToUserSelection: async (
      selectionIdentifier: number,
      userIdentifier: number,
      uuid?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'selectionIdentifier' is not null or undefined
      assertParamExists(
        'addToUserSelection',
        'selectionIdentifier',
        selectionIdentifier
      );
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists('addToUserSelection', 'userIdentifier', userIdentifier);
      const localVarPath =
        `/userselections/{selectionIdentifier}/{userIdentifier}`
          .replace(
            `{${'selectionIdentifier'}}`,
            encodeURIComponent(String(selectionIdentifier))
          )
          .replace(
            `{${'userIdentifier'}}`,
            encodeURIComponent(String(userIdentifier))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuid) {
        localVarQueryParameter['uuid'] = uuid;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a user selection set
     * @param {Selection} selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPersistentSelectionType: async (
      selection: Selection,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'selection' is not null or undefined
      assertParamExists(
        'createPersistentSelectionType',
        'selection',
        selection
      );
      const localVarPath = `/userselections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        selection,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove items to a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuid] One or more record UUIDs. If null, remove all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFromUserSelection: async (
      selectionIdentifier: number,
      userIdentifier: number,
      uuid?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'selectionIdentifier' is not null or undefined
      assertParamExists(
        'deleteFromUserSelection',
        'selectionIdentifier',
        selectionIdentifier
      );
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists(
        'deleteFromUserSelection',
        'userIdentifier',
        userIdentifier
      );
      const localVarPath =
        `/userselections/{selectionIdentifier}/{userIdentifier}`
          .replace(
            `{${'selectionIdentifier'}}`,
            encodeURIComponent(String(selectionIdentifier))
          )
          .replace(
            `{${'userIdentifier'}}`,
            encodeURIComponent(String(userIdentifier))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (uuid) {
        localVarQueryParameter['uuid'] = uuid;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSelection: async (
      selectionIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'selectionIdentifier' is not null or undefined
      assertParamExists(
        'deleteUserSelection',
        'selectionIdentifier',
        selectionIdentifier
      );
      const localVarPath = `/userselections/{selectionIdentifier}`.replace(
        `{${'selectionIdentifier'}}`,
        encodeURIComponent(String(selectionIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of user selection sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSelectionList: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/userselections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get record in a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSelectionRecords: async (
      selectionIdentifier: number,
      userIdentifier: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'selectionIdentifier' is not null or undefined
      assertParamExists(
        'getSelectionRecords',
        'selectionIdentifier',
        selectionIdentifier
      );
      // verify required parameter 'userIdentifier' is not null or undefined
      assertParamExists(
        'getSelectionRecords',
        'userIdentifier',
        userIdentifier
      );
      const localVarPath =
        `/userselections/{selectionIdentifier}/{userIdentifier}`
          .replace(
            `{${'selectionIdentifier'}}`,
            encodeURIComponent(String(selectionIdentifier))
          )
          .replace(
            `{${'userIdentifier'}}`,
            encodeURIComponent(String(userIdentifier))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {Selection} selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserSelection: async (
      selectionIdentifier: number,
      selection: Selection,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'selectionIdentifier' is not null or undefined
      assertParamExists(
        'updateUserSelection',
        'selectionIdentifier',
        selectionIdentifier
      );
      // verify required parameter 'selection' is not null or undefined
      assertParamExists('updateUserSelection', 'selection', selection);
      const localVarPath = `/userselections/{selectionIdentifier}`.replace(
        `{${'selectionIdentifier'}}`,
        encodeURIComponent(String(selectionIdentifier))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        selection,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserselectionsApi - functional programming interface
 * @export
 */
export const UserselectionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserselectionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add items to a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuid] One or more record UUIDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addToUserSelection(
      selectionIdentifier: number,
      userIdentifier: number,
      uuid?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addToUserSelection(
          selectionIdentifier,
          userIdentifier,
          uuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add a user selection set
     * @param {Selection} selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPersistentSelectionType(
      selection: Selection,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPersistentSelectionType(
          selection,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove items to a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuid] One or more record UUIDs. If null, remove all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFromUserSelection(
      selectionIdentifier: number,
      userIdentifier: number,
      uuid?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFromUserSelection(
          selectionIdentifier,
          userIdentifier,
          uuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserSelection(
      selectionIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserSelection(
          selectionIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get list of user selection sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSelectionList(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Selection>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSelectionList(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get record in a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSelectionRecords(
      selectionIdentifier: number,
      userIdentifier: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSelectionRecords(
          selectionIdentifier,
          userIdentifier,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {Selection} selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserSelection(
      selectionIdentifier: number,
      selection: Selection,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateUserSelection(
          selectionIdentifier,
          selection,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserselectionsApi - factory interface
 * @export
 */
export const UserselectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserselectionsApiFp(configuration);
  return {
    /**
     *
     * @summary Add items to a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuid] One or more record UUIDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addToUserSelection(
      selectionIdentifier: number,
      userIdentifier: number,
      uuid?: Array<string>,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .addToUserSelection(selectionIdentifier, userIdentifier, uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a user selection set
     * @param {Selection} selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPersistentSelectionType(
      selection: Selection,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .createPersistentSelectionType(selection, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove items to a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {Array<string>} [uuid] One or more record UUIDs. If null, remove all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFromUserSelection(
      selectionIdentifier: number,
      userIdentifier: number,
      uuid?: Array<string>,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .deleteFromUserSelection(
          selectionIdentifier,
          userIdentifier,
          uuid,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSelection(
      selectionIdentifier: number,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .deleteUserSelection(selectionIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of user selection sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSelectionList(options?: any): AxiosPromise<Array<Selection>> {
      return localVarFp
        .getSelectionList(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get record in a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {number} userIdentifier User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSelectionRecords(
      selectionIdentifier: number,
      userIdentifier: number,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getSelectionRecords(selectionIdentifier, userIdentifier, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a user selection set
     * @param {number} selectionIdentifier Selection identifier
     * @param {Selection} selection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserSelection(
      selectionIdentifier: number,
      selection: Selection,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .updateUserSelection(selectionIdentifier, selection, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserselectionsApi - object-oriented interface
 * @export
 * @class UserselectionsApi
 * @extends {BaseAPI}
 */
export class UserselectionsApi extends BaseAPI {
  /**
   *
   * @summary Add items to a user selection set
   * @param {number} selectionIdentifier Selection identifier
   * @param {number} userIdentifier User identifier
   * @param {Array<string>} [uuid] One or more record UUIDs.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserselectionsApi
   */
  public addToUserSelection(
    selectionIdentifier: number,
    userIdentifier: number,
    uuid?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return UserselectionsApiFp(this.configuration)
      .addToUserSelection(selectionIdentifier, userIdentifier, uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a user selection set
   * @param {Selection} selection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserselectionsApi
   */
  public createPersistentSelectionType(
    selection: Selection,
    options?: AxiosRequestConfig
  ) {
    return UserselectionsApiFp(this.configuration)
      .createPersistentSelectionType(selection, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove items to a user selection set
   * @param {number} selectionIdentifier Selection identifier
   * @param {number} userIdentifier User identifier
   * @param {Array<string>} [uuid] One or more record UUIDs. If null, remove all.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserselectionsApi
   */
  public deleteFromUserSelection(
    selectionIdentifier: number,
    userIdentifier: number,
    uuid?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return UserselectionsApiFp(this.configuration)
      .deleteFromUserSelection(
        selectionIdentifier,
        userIdentifier,
        uuid,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a user selection set
   * @param {number} selectionIdentifier Selection identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserselectionsApi
   */
  public deleteUserSelection(
    selectionIdentifier: number,
    options?: AxiosRequestConfig
  ) {
    return UserselectionsApiFp(this.configuration)
      .deleteUserSelection(selectionIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of user selection sets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserselectionsApi
   */
  public getSelectionList(options?: AxiosRequestConfig) {
    return UserselectionsApiFp(this.configuration)
      .getSelectionList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get record in a user selection set
   * @param {number} selectionIdentifier Selection identifier
   * @param {number} userIdentifier User identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserselectionsApi
   */
  public getSelectionRecords(
    selectionIdentifier: number,
    userIdentifier: number,
    options?: AxiosRequestConfig
  ) {
    return UserselectionsApiFp(this.configuration)
      .getSelectionRecords(selectionIdentifier, userIdentifier, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a user selection set
   * @param {number} selectionIdentifier Selection identifier
   * @param {Selection} selection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserselectionsApi
   */
  public updateUserSelection(
    selectionIdentifier: number,
    selection: Selection,
    options?: AxiosRequestConfig
  ) {
    return UserselectionsApiFp(this.configuration)
      .updateUserSelection(selectionIdentifier, selection, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
